{
 "ba4314e80a8a07418367b2d5a2371ffc6d2d29978606950e4232f82891f6f171": [
  "voidp zcalloc (voidp opaque, unsigned items, unsigned size)\n{\n    voidp buf;\n    ulg bsize = (ulg)items*size;\n\n    if (bsize < 65536L) {\n\tbuf = farmalloc(bsize);\n\tif (*(ush*)&buf != 0) return buf;\n    } else {\n\tbuf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "zutil.c"
   ],
   "v0.79": [
    "2011-09-09 22:52:17",
    "zutil.c"
   ]
  }
 ],
 "ff0d4901779bf852e8425bc889b62b7a831e508b0608ea93bb3fa4b0083249fd": [
  "void  zcfree (voidp opaque, voidp ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n\tfarfree(ptr);\n\treturn;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n\tif (ptr != table[n].new_ptr) continue;\n\n\tfarfree(table[n].org_ptr);\n\twhile (++n < next_ptr) {\n\t    table[n-1] = table[n];\n\t}\n\tnext_ptr--;\n\treturn;\n    }\n    z_error(\"zcfree: ptr not found\");\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "zutil.c"
   ],
   "v0.79": [
    "2011-09-09 22:52:17",
    "zutil.c"
   ]
  }
 ],
 "2283f8c20e7939fad44bffbb6b95c1c31d9c1d8dbe91fedae9995dc8555b05e9": [
  "voidp zcalloc (voidp opaque, unsigned items, unsigned size)\n{\n    return _halloc((long)items, size);\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "zutil.c"
   ],
   "v0.79": [
    "2011-09-09 22:52:17",
    "zutil.c"
   ]
  }
 ],
 "7d7b1361018dc3bc18a90020c9878fa08375e5d823bb88bcdd55e5333501e7bb": [
  "void  zcfree (voidp opaque, voidp ptr)\n{\n    return _hfree(ptr);\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "zutil.c"
   ]
  }
 ],
 "f36bbf8a27bf7604b6b023e786f2ce257cd5c4e4650ae460cc53b3a435ea2b11": [
  "void test_compress()\n{\n    local Byte compr[BUFLEN];\n    uLong comprLen = sizeof(compr);\n    local Byte uncompr[BUFLEN];\n    uLong uncomprLen = sizeof(uncompr);\n    int err;\n    uLong len = strlen(hello)+1;\n\n    err = compress(compr, &comprLen, hello, len);\n    CHECK_ERR(err, \"compress\");\n\n    strcpy(uncompr, \"garbage\");\n\n    err = uncompress(uncompr, &uncomprLen, compr, comprLen);\n    CHECK_ERR(err, \"uncompress\");\n\n    if (strcmp(uncompr, hello)) {\n\tfprintf(stderr, \"bad uncompress\\n\");\n    } else {\n\tprintf(\"uncompress(): %s\\n\", uncompr);\n    }\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "example.c"
   ],
   "v0.79": [
    "2011-09-09 22:52:17",
    "example.c"
   ]
  }
 ],
 "8f6d81658ab8d9e9f433ab48c0fb0a07c08d9c5688f4831f6d5b9a883d01d347": [
  "void make_crc_table()\n{\n  uLong c;\n  int n, k;\n \n  for (n = 0; n &lt; 256; n++)\n  {\n    c = (uLong)n;\n    for (k = 0; k &lt; 8; k++)\n      c = c & 1 ? 0xedb88320L ^ (c >> 1) : c >> 1;\n    crc_table[n] = c;\n  }\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "crc32.c"
   ],
   "v0.79": [
    "2011-09-09 22:52:17",
    "crc32.c"
   ],
   "v0.8": [
    "2011-09-09 23:03:14",
    "crc32.c"
   ]
  }
 ],
 "42f7c90690253ed625c13ae59370009ff565021ba02310b643214933370d8740": [
  "void main()\n{\n  int a, r;\n  char c;\n  z_stream z;\n\n  z.zalloc = Z_NULL;\n  z.zfree = Z_NULL;\n  r = inflateInit(&z);\n  if (r != Z_OK)\n    fprintf(stderr, \"init error: %s\\n\", z_errmsg[1 - r]);\n  while ((a = getchar()) != EOF)\n  {\n    /* feed one byte of input */\n    z.avail_out = 0;\n    c = (char)a;\n    z.next_in = (Byte*)&c;\n    z.avail_in = 1;\n    r = inflate(&z, 0);\n    if (r == Z_STREAM_END)\n      break;\n    if (r != Z_OK)\n    {\n      fprintf(stderr, \"inflate error: %s\\n\", z_errmsg[1 - r]);\n      break;\n    }\n    if (z.avail_in != 0)\n    {\n      fprintf(stderr, \"inflate didn't eat byte and didn't say buf err!\\n\");\n      break;\n    }\n\n    /* empty output one byte at a time */\n    while (1)\n    {\n      z.next_out = (Byte*)&c;\n      z.avail_out = 1;\n      r = inflate(&z, 0);\n      if (r == Z_STREAM_END)\n\tbreak;\n      if (r != Z_OK && r != Z_BUF_ERROR)\n      {\n\tfprintf(stderr, \"inflate error: %s\\n\", z_errmsg[1 - r]);\n\tbreak;\n      }\n      if (z.avail_out == 0)\n        putchar(c);\n      else\n        break;\n    }\n    if (r != Z_OK && r != Z_BUF_ERROR)\n      break;\n  }\n  inflateEnd(&z);\n  fprintf(stderr, \"%d bytes in, %d bytes out\\n\", z.total_in, z.total_out);\n  if (z.msg != NULL)\n    fprintf(stderr, \"msg is <%s>\\n\", z.msg);\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "inftest.c"
   ],
   "v0.79": [
    "2011-09-09 22:52:17",
    "inftest.c"
   ]
  }
 ],
 "b66c71d34a75a64224ed392878b8b486f5f6c80575f48bc9f3827ad33fc89a10": [
  "local void ct_static_init()\n{\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"ct_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"ct_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"ct_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse(n, 5);\n    }\n}",
  {
   "v0.71": [
    "2011-09-09 22:36:31",
    "trees.c"
   ],
   "v0.79": [
    "2011-09-09 22:52:17",
    "trees.c"
   ],
   "v0.8": [
    "2011-09-09 23:03:14",
    "trees.c"
   ],
   "v0.9": [
    "2011-09-09 23:06:52",
    "trees.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "trees.c"
   ],
   "v0.92": [
    "2011-09-09 23:08:07",
    "trees.c"
   ],
   "v0.93": [
    "2011-09-09 23:08:28",
    "trees.c"
   ],
   "v0.94": [
    "2011-09-09 23:09:18",
    "trees.c"
   ],
   "v0.95": [
    "2011-09-09 23:10:21",
    "trees.c"
   ]
  }
 ],
 "73dc07c00e3da8a45e8189733f4da7c446a629bbb94c2d5f7d4dfe8fd914e560": [
  "void  zcfree (voidp opaque, voidp ptr)\n{\n    _hfree(ptr);\n}",
  {
   "v0.79": [
    "2011-09-09 22:52:17",
    "zutil.c"
   ]
  }
 ],
 "36a5a90550ca34cdd0676e459e1ee278625093e74077117aaa8cacbdce577ddc": [
  "voidp zcalloc (voidp opaque, unsigned items, unsigned size)\n{\n    voidp buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    if (bsize < 65536L) {\n\tbuf = farmalloc(bsize);\n\tif (*(ush*)&buf != 0) return buf;\n    } else {\n\tbuf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
  {
   "v0.8": [
    "2011-09-09 23:03:14",
    "zutil.c"
   ],
   "v0.9": [
    "2011-09-09 23:06:52",
    "zutil.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "zutil.c"
   ],
   "v0.92": [
    "2011-09-09 23:08:07",
    "zutil.c"
   ],
   "v0.93": [
    "2011-09-09 23:08:28",
    "zutil.c"
   ],
   "v0.94": [
    "2011-09-09 23:09:18",
    "zutil.c"
   ]
  }
 ],
 "c5544ca757bc99f71b503e144d1f2aadfb610b4a6811e5cc66a8cbc08dcfb3b9": [
  "void  zcfree (voidp opaque, voidp ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n\tfarfree(ptr);\n\treturn;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n\tif (ptr != table[n].new_ptr) continue;\n\n\tfarfree(table[n].org_ptr);\n\twhile (++n < next_ptr) {\n\t    table[n-1] = table[n];\n\t}\n\tnext_ptr--;\n\treturn;\n    }\n    ptr = opaque; /* just to make some compilers happy */\n    z_error(\"zcfree: ptr not found\");\n}",
  {
   "v0.8": [
    "2011-09-09 23:03:14",
    "zutil.c"
   ],
   "v0.9": [
    "2011-09-09 23:06:52",
    "zutil.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "zutil.c"
   ],
   "v0.92": [
    "2011-09-09 23:08:07",
    "zutil.c"
   ],
   "v0.93": [
    "2011-09-09 23:08:28",
    "zutil.c"
   ],
   "v0.94": [
    "2011-09-09 23:09:18",
    "zutil.c"
   ]
  }
 ],
 "0a37d60b20eed86a9688c2164c9657632df5b69cf5e46feabad5d8b95646f969": [
  "voidp zcalloc (voidp opaque, unsigned items, unsigned size)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n}",
  {
   "v0.8": [
    "2011-09-09 23:03:14",
    "zutil.c"
   ],
   "v0.9": [
    "2011-09-09 23:06:52",
    "zutil.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "zutil.c"
   ],
   "v0.92": [
    "2011-09-09 23:08:07",
    "zutil.c"
   ],
   "v0.93": [
    "2011-09-09 23:08:28",
    "zutil.c"
   ],
   "v0.94": [
    "2011-09-09 23:09:18",
    "zutil.c"
   ]
  }
 ],
 "1d4a57177ca07f66f54d8037d45d0e900e21008066a7418bb1c0f0441ca237fb": [
  "void  zcfree (voidp opaque, voidp ptr)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    _hfree(ptr);\n}",
  {
   "v0.8": [
    "2011-09-09 23:03:14",
    "zutil.c"
   ],
   "v0.9": [
    "2011-09-09 23:06:52",
    "zutil.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "zutil.c"
   ],
   "v0.92": [
    "2011-09-09 23:08:07",
    "zutil.c"
   ],
   "v0.93": [
    "2011-09-09 23:08:28",
    "zutil.c"
   ],
   "v0.94": [
    "2011-09-09 23:09:18",
    "zutil.c"
   ]
  }
 ],
 "3c8af4fdf75163573a6ea92361e98e71195d8ca29077bc878154073a6eee569a": [
  "void test_compress()\n{\n    local Byte compr[BUFLEN];\n    uLong comprLen = sizeof(compr);\n    local Byte uncompr[BUFLEN];\n    uLong uncomprLen = sizeof(uncompr);\n    int err;\n    uLong len = strlen(hello)+1;\n\n    err = compress(compr, &comprLen, (Byte*)hello, len);\n    CHECK_ERR(err, \"compress\");\n\n    strcpy((char*)uncompr, \"garbage\");\n\n    err = uncompress(uncompr, &uncomprLen, compr, comprLen);\n    CHECK_ERR(err, \"uncompress\");\n\n    if (strcmp((char*)uncompr, hello)) {\n\tfprintf(stderr, \"bad uncompress\\n\");\n    } else {\n\tprintf(\"uncompress(): %s\\n\", uncompr);\n    }\n}",
  {
   "v0.8": [
    "2011-09-09 23:03:14",
    "example.c"
   ],
   "v0.9": [
    "2011-09-09 23:06:52",
    "example.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "example.c"
   ],
   "v0.92": [
    "2011-09-09 23:08:07",
    "example.c"
   ],
   "v0.93": [
    "2011-09-09 23:08:28",
    "example.c"
   ],
   "v0.94": [
    "2011-09-09 23:09:18",
    "example.c"
   ],
   "v0.95": [
    "2011-09-09 23:10:21",
    "example.c"
   ]
  }
 ],
 "bef24e1e529276f709613653be7b20864ecb3206a01c64aef4b77b4f645349f3": [
  "void main()\n{\n  int a, r;\n  char c;\n  z_stream z;\n\n  z.zalloc = Z_NULL;\n  z.zfree = Z_NULL;\n  r = inflateInit(&z);\n  if (r != Z_OK)\n    fprintf(stderr, \"init error: %s\\n\", z_errmsg[1 - r]);\n  while ((a = getchar()) != EOF)\n  {\n    /* feed one byte of input */\n    z.avail_out = 0;\n    c = (char)a;\n    z.next_in = (Byte*)&c;\n    z.avail_in = 1;\n    r = inflate(&z, 0);\n    if (r == Z_STREAM_END)\n      break;\n    if (r != Z_OK)\n    {\n      fprintf(stderr, \"inflate error: %s\\n\", z_errmsg[1 - r]);\n      break;\n    }\n    if (z.avail_in != 0)\n    {\n      fprintf(stderr, \"inflate didn't eat byte and didn't say buf err!\\n\");\n      break;\n    }\n\n    /* empty output one byte at a time */\n    while (1)\n    {\n      z.next_out = (Byte*)&c;\n      z.avail_out = 1;\n      r = inflate(&z, 0);\n      if (r == Z_STREAM_END)\n\tbreak;\n      if (r != Z_OK && r != Z_BUF_ERROR)\n      {\n\tfprintf(stderr, \"inflate error: %s\\n\", z_errmsg[1 - r]);\n\tbreak;\n      }\n      if (z.avail_out == 0)\n        putchar(c);\n      else\n        break;\n    }\n    if (r != Z_OK && r != Z_BUF_ERROR)\n      break;\n  }\n  inflateEnd(&z);\n  fprintf(stderr, \"%ld bytes in, %ld bytes out\\n\", z.total_in, z.total_out);\n  if (z.msg != NULL)\n    fprintf(stderr, \"msg is <%s>\\n\", z.msg);\n}",
  {
   "v0.8": [
    "2011-09-09 23:03:14",
    "inftest.c"
   ],
   "v0.9": [
    "2011-09-09 23:06:52",
    "inftest.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "inftest.c"
   ]
  }
 ],
 "e4b9ef05783f6ecd6bc0ebeb3c7d2008c7c3cb671613472c5cff86ea5637a110": [
  "local void make_crc_table()\n{\n  uLong c;\n  int n, k;\n \n  for (n = 0; n &lt; 256; n++)\n  {\n    c = (uLong)n;\n    for (k = 0; k &lt; 8; k++)\n      c = c & 1 ? 0xedb88320L ^ (c >> 1) : c >> 1;\n    crc_table[n] = c;\n  }\n}",
  {
   "v0.9": [
    "2011-09-09 23:06:52",
    "crc32.c"
   ],
   "v0.91": [
    "2011-09-09 23:07:35",
    "crc32.c"
   ],
   "v0.92": [
    "2011-09-09 23:08:07",
    "crc32.c"
   ]
  }
 ],
 "b173796f0b6db30ee8c33d129bf5cfb52417c6a5603060d218fdeb4eb05ca59f": [
  "local void make_crc_table()\n{\n  uLong c;\n  int n, k;\n \n  for (n = 0; n < 256; n++)\n  {\n    c = (uLong)n;\n    for (k = 0; k < 8; k++)\n      c = c & 1 ? 0xedb88320L ^ (c >> 1) : c >> 1;\n    crc_table[n] = c;\n  }\n  crc_table_empty = 0;\n}",
  {
   "v0.93": [
    "2011-09-09 23:08:28",
    "crc32.c"
   ],
   "v0.94": [
    "2011-09-09 23:09:18",
    "crc32.c"
   ],
   "v0.95": [
    "2011-09-09 23:10:21",
    "crc32.c"
   ],
   "v1.0-pre": [
    "2011-09-09 23:13:27",
    "crc32.c"
   ]
  }
 ],
 "23cf88b727c345fdfcc1339c40ecf4ca46c4aff492aeb13a62ed6c0a82ce9c95": [
  "voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    if (bsize < 65536L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
  {
   "v0.95": [
    "2011-09-09 23:10:21",
    "zutil.c"
   ]
  }
 ],
 "1b20931ac7918c42c8716f760be57d09b973c8e94a4fa09273f3042d87b07434": [
  "void  zcfree (voidpf opaque, voidpf ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    ptr = opaque; /* just to make some compilers happy */\n    z_error(\"zcfree: ptr not found\");\n}",
  {
   "v0.95": [
    "2011-09-09 23:10:21",
    "zutil.c"
   ],
   "v0.99": [
    "2011-09-09 23:11:37",
    "zutil.c"
   ],
   "v1.0-pre": [
    "2011-09-09 23:13:27",
    "zutil.c"
   ],
   "v1.0.1": [
    "2011-09-09 23:14:39",
    "zutil.c"
   ],
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "zutil.c"
   ]
  }
 ],
 "aee86d1f13c52c7d43d094ad41cfc7feccab190bac9899a42583f821e320b6ae": [
  "voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n}",
  {
   "v0.95": [
    "2011-09-09 23:10:21",
    "zutil.c"
   ],
   "v0.99": [
    "2011-09-09 23:11:37",
    "zutil.c"
   ],
   "v1.0-pre": [
    "2011-09-09 23:13:27",
    "zutil.c"
   ],
   "v1.0.1": [
    "2011-09-09 23:14:39",
    "zutil.c"
   ],
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "zutil.c"
   ],
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "zutil.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "zutil.c"
   ],
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "zutil.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "zutil.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "zutil.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "zutil.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "zutil.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "zutil.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "zutil.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "zutil.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "zutil.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "zutil.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "zutil.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "zutil.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "zutil.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "zutil.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "zutil.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "zutil.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "zutil.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "zutil.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "zutil.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "zutil.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "zutil.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "zutil.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "zutil.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "zutil.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "zutil.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "zutil.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "zutil.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "zutil.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "zutil.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "zutil.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "zutil.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "zutil.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "zutil.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "zutil.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "zutil.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "zutil.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "zutil.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "zutil.c"
   ]
  }
 ],
 "f8cf0b10527d2dcfc3e9a4c0f6f8a90b6442dd9d210af3dadc13fcb9baf272d1": [
  "void  zcfree (voidpf opaque, voidpf ptr)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    _hfree(ptr);\n}",
  {
   "v0.95": [
    "2011-09-09 23:10:21",
    "zutil.c"
   ],
   "v0.99": [
    "2011-09-09 23:11:37",
    "zutil.c"
   ],
   "v1.0-pre": [
    "2011-09-09 23:13:27",
    "zutil.c"
   ],
   "v1.0.1": [
    "2011-09-09 23:14:39",
    "zutil.c"
   ],
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "zutil.c"
   ],
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "zutil.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "zutil.c"
   ],
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "zutil.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "zutil.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "zutil.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "zutil.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "zutil.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "zutil.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "zutil.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "zutil.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "zutil.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "zutil.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "zutil.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "zutil.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "zutil.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "zutil.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "zutil.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "zutil.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "zutil.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "zutil.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "zutil.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "zutil.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "zutil.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "zutil.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "zutil.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "zutil.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "zutil.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "zutil.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "zutil.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "zutil.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "zutil.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "zutil.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "zutil.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "zutil.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "zutil.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "zutil.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "zutil.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "zutil.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "zutil.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "zutil.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "zutil.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "zutil.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "zutil.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "zutil.c"
   ]
  }
 ],
 "1fc55851dd8b1fe432d255f58f5fe2059ae55fa094249d550dce1902b9bf1d24": [
  "voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
  {
   "v0.99": [
    "2011-09-09 23:11:37",
    "zutil.c"
   ],
   "v1.0.1": [
    "2011-09-09 23:14:39",
    "zutil.c"
   ],
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "zutil.c"
   ],
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "zutil.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "zutil.c"
   ],
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "zutil.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "zutil.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "zutil.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "zutil.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "zutil.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "zutil.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "zutil.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "zutil.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "zutil.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "zutil.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "zutil.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "zutil.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "zutil.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "zutil.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "zutil.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "zutil.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "zutil.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "zutil.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "zutil.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "zutil.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "zutil.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "zutil.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "zutil.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "zutil.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "zutil.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "zutil.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "zutil.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "zutil.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "zutil.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "zutil.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "zutil.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "zutil.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "zutil.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "zutil.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "zutil.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "zutil.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "zutil.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "zutil.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "zutil.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "zutil.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "zutil.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "zutil.c"
   ]
  }
 ],
 "df0707f9c7f8b38edb03d0d6eb7f8034c5ae0c5d7d22589f3233d6caeba7000e": [
  "local void make_crc_table()\n{\n  uLong c;\n  int n, k;\n  uLong poly;            /* polynomial exclusive-or pattern */\n  /* terms of polynomial defining this crc (except x^32): */\n  static Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n  /* make exclusive-or pattern from polynomial (0xedb88320L) */\n  poly = 0L;\n  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)\n    poly |= 1L << (31 - p[n]);\n \n  for (n = 0; n < 256; n++)\n  {\n    c = (uLong)n;\n    for (k = 0; k < 8; k++)\n      c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n    crc_table[n] = c;\n  }\n  crc_table_empty = 0;\n}",
  {
   "v0.99": [
    "2011-09-09 23:11:37",
    "crc32.c"
   ],
   "v1.0.1": [
    "2011-09-09 23:14:39",
    "crc32.c"
   ],
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "crc32.c"
   ],
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "crc32.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "crc32.c"
   ],
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "crc32.c"
   ]
  }
 ],
 "ff1b56f21a310e854114c4e01bbef99cdca7bbe6914e9f01f425e605ffea30d4": [
  "uLongf *get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n  if (crc_table_empty) make_crc_table();\n#endif\n  return (uLongf *)crc_table;\n}",
  {
   "v0.99": [
    "2011-09-09 23:11:37",
    "crc32.c"
   ],
   "v1.0.1": [
    "2011-09-09 23:14:39",
    "crc32.c"
   ],
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "crc32.c"
   ],
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "crc32.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "crc32.c"
   ]
  }
 ],
 "3e4e99ba9b0a0999b5edf7fddaaffd1b415bb6a69a1d26c6cf943e13ff13ba9b": [
  "local void tr_static_init()\n{\n    static static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n}",
  {
   "v0.99": [
    "2011-09-09 23:11:37",
    "trees.c"
   ]
  }
 ],
 "286f9c971361aa97545751c878586eb74a54b72c814d1608468f8a683725ce2f": [
  "voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n#ifdef DEBUG\n        zmemzero(buf, (uInt)bsize);\n#endif\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n#ifdef DEBUG\n    zmemzero(buf, (uInt)65535);\n    ((uch*)buf)[65535] = 0;\n#endif\n    return buf;\n}",
  {
   "v1.0-pre": [
    "2011-09-09 23:13:27",
    "zutil.c"
   ]
  }
 ],
 "19bd5a0b7e7b759c45ef5c95e2edfc861e22865080be21056dbd30fca58ff5b2": [
  "local void tr_static_init()\n{\n    static static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse(n, 5);\n    }\n    static_init_done = 1;\n}",
  {
   "v1.0-pre": [
    "2011-09-09 23:13:27",
    "trees.c"
   ]
  }
 ],
 "ddcfaf594356f43c9cb9eeda3e11c74c7f7632cc9f653be9ad64ff413909d969": [
  "local void tr_static_init()\n{\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n}",
  {
   "v1.0.1": [
    "2011-09-09 23:14:39",
    "trees.c"
   ],
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "trees.c"
   ],
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "trees.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "trees.c"
   ],
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "trees.c"
   ]
  }
 ],
 "c7edeb7507566d308efc2e4a42487feb8c24341227bedbe54ca36644971612cf": [
  "char *zlibVersion()\n{\n    return ZLIB_VERSION;\n}",
  {
   "v1.0.2": [
    "2011-09-09 23:15:17",
    "zutil.c"
   ]
  }
 ],
 "9b6bb4d97694ae286bf5c8419978bea917c56b986c0eed38d616437cf2dbc5a1": [
  "const char *zlibVersion()\n{\n    return ZLIB_VERSION;\n}",
  {
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "zutil.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "zutil.c"
   ]
  }
 ],
 "e4a2cf6d55e0ace94bf595736b363ac88e5e0148cf0b53cab55c9947d2f5cb3b": [
  "void  zcfree (voidpf opaque, voidpf ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    ptr = opaque; /* just to make some compilers happy */\n    Assert(0, \"zcfree: ptr not found\");\n}",
  {
   "v1.0.4": [
    "2011-09-09 23:17:02",
    "zutil.c"
   ],
   "v1.0.5": [
    "2011-09-09 23:17:17",
    "zutil.c"
   ],
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "zutil.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "zutil.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "zutil.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "zutil.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "zutil.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "zutil.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "zutil.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "zutil.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "zutil.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "zutil.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "zutil.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "zutil.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "zutil.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "zutil.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "zutil.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "zutil.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "zutil.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "zutil.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "zutil.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "zutil.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "zutil.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "zutil.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "zutil.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "zutil.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "zutil.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "zutil.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "zutil.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "zutil.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "zutil.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "zutil.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "zutil.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "zutil.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "zutil.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "zutil.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "zutil.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "zutil.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "zutil.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "zutil.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "zutil.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "zutil.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "zutil.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "zutil.c"
   ]
  }
 ],
 "f97311619f96ba86e036d02ce0efc420001d5bc096bf510b18bab103cb97c987": [
  "void main() {\n\tchar h[256] = \"Hello\";\n\tchar* g = \"Goodbye\";\n\tozstream out(\"temp.gz\");\n    out < \"This works well\" < h < g;\n    out.close();\n\n    izstream in(\"temp.gz\"); // read it back\n    char *x = read_string(in), *y = new char[256], z[256];\n    in > y > z;\n    in.close();\n    cout << x << endl << y << endl << z << endl;\n\n    out.open(\"temp.gz\"); // try ascii output; zcat temp.gz to see the results\n    out << setw(50) << setfill('#') << setprecision(20) << x << endl << y << endl << z << endl;\n    out << z << endl << y << endl << x << endl;\n    out << 1.1234567890123456789 << endl;\n\n    delete[] x; delete[] y;\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream2/zstream_test.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream2/zstream_test.cpp"
   ]
  }
 ],
 "d10142a22eb39be655d83f7573077350fdb2cf6ee46a4c9ff8bb750b63638e6c": [
  "void match_init()\n{\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/masmx86/gvmat32c.c"
   ]
  }
 ],
 "6960d67e4045273d2987e6f16e7365359cea46d2f39e41928f7d35cf87dcd2c1": [
  "uInt longest_match(\n    deflate_state *s,\n    IPos cur_match)                             /* current match */\n{\n    if (s->w_mask == 0x7fff)\n        return longest_match_asm7fff(s,cur_match);\n    return longest_match_c(s,cur_match);\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/asm386/gvmat32c.c"
   ]
  }
 ],
 "948a35ab5fbd28594410985823da1c26a0c94dca083df54ddf7190135df20aa3": [
  "int getoct(char *p,int width)\n{\n  int result = 0;\n  char c;\n  \n  while (width --)\n    {\n      c = *p++;\n      if (c == ' ')\n\tcontinue;\n      if (c == 0)\n\tbreak;\n      result = result * 8 + (c - '0');\n    }\n  return result;\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "8ce666bdf3708a9b8aec3097706dd8c55245cc8f638058b60da698296f301bd8": [
  "char *strtime (time_t *t)\n{\n  struct tm   *local;\n  static char result[32];\n\n  local = localtime(t);\n  sprintf(result,\"%2d/%02d/%4d %02d:%02d:%02d\",\n\t  local->tm_mday, local->tm_mon+1, local->tm_year+1900,\n\t  local->tm_hour, local->tm_min,   local->tm_sec);\n  return result;\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "11a4f843dad6b22e94442324242ded7bd28ca8314306f3a7a5713d91b87a552a": [
  "int ExprMatch(char *string,char *expr)\n{\n  while (1)\n    {\n      if (ISSPECIAL(*expr))\n\t{\n\t  if (*expr == '/')\n\t    {\n\t      if (*string != '\\\\' && *string != '/')\n\t\treturn 0;\n\t      string ++; expr++;\n\t    }\n\t  else if (*expr == '*')\n\t    {\n\t      if (*expr ++ == 0)\n\t\treturn 1;\n\t      while (*++string != *expr)\n\t\tif (*string == 0)\n\t\t  return 0;\n\t    }\n\t}\n      else\n\t{\n\t  if (*string != *expr)\n\t    return 0;\n\t  if (*expr++ == 0)\n\t    return 1;\n\t  string++;\n\t}\n    }\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "e144d228956f2493b835083f8ff26c47632eb9efa23b92d808d90bd4c665c316": [
  "int makedir (char *newdir)\n{\n  char *buffer = strdup(newdir);\n  char *p;\n  int  len = strlen(buffer);\n  \n  if (len <= 0) {\n    free(buffer);\n    return 0;\n  }\n  if (buffer[len-1] == '/') {\n    buffer[len-1] = '\\0';\n  }\n  if (mkdir(buffer, 0775) == 0)\n    {\n      free(buffer);\n      return 1;\n    }\n\n  p = buffer+1;\n  while (1)\n    {\n      char hold;\n      \n      while(*p && *p != '\\\\' && *p != '/')\n\tp++;\n      hold = *p;\n      *p = 0;\n      if ((mkdir(buffer, 0775) == -1) && (errno == ENOENT))\n\t{\n\t  fprintf(stderr,\"%s: couldn't create directory %s\\n\",prog,buffer);\n\t  free(buffer);\n\t  return 0;\n\t}\n      if (hold == 0)\n\tbreak;\n      *p++ = hold;\n    }\n  free(buffer);\n  return 1;\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "72eec01487e0816b032cb823853d30542863fd5396772cbe6b7578b787e58469": [
  "int matchname (int arg,int argc,char **argv,char *fname)\n{\n  if (arg == argc)\t\t/* no arguments given (untgz tgzarchive) */\n    return 1;\n\n  while (arg < argc)\n    if (ExprMatch(fname,argv[arg++]))\n      return 1;\n\n  return 0; /* ignore this for the moment being */\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "7bfafdf60f435a86aabfd16d6a2587f6ab7ded27ca10cd33a782dd7e7d59c4c2": [
  "int tar (gzFile in,int action,int arg,int argc,char **argv)\n{\n  union  tar_buffer buffer;\n  int    len;\n  int    err;\n  int    getheader = 1;\n  int    remaining = 0;\n  FILE   *outfile = NULL;\n  char   fname[BLOCKSIZE];\n  time_t tartime;\n  \n  if (action == TGZ_LIST)\n    printf(\"     day      time     size                       file\\n\"\n\t   \" ---------- -------- --------- -------------------------------------\\n\");\n  while (1)\n    {\n      len = gzread(in, &buffer, BLOCKSIZE);\n      if (len < 0)\n\terror (gzerror(in, &err));\n      /*\n       * if we met the end of the tar\n       * or the end-of-tar block,\n       * we are done\n       */\n      if ((len == 0)  || (buffer.header.name[0]== 0))\n\tbreak;\n      \n      /*\n       * Always expect complete blocks to process\n       * the tar information.\n       */\n      if (len != BLOCKSIZE)\n\terror(\"gzread: incomplete block read\");\n      \n      /*\n       * If we have to get a tar header\n       */\n      if (getheader == 1)\n\t{\n\t  tartime = (time_t)getoct(buffer.header.mtime,12);\n\t  strcpy(fname,buffer.header.name);\n\t  \n\t  switch (buffer.header.typeflag)\n\t    {\n\t    case DIRTYPE:\n\t      if (action == TGZ_LIST)\n\t\tprintf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n\t      if (action == TGZ_EXTRACT)\n\t\tmakedir(fname);\n\t      break;\n\t    case REGTYPE:\n\t    case AREGTYPE:\n\t      remaining = getoct(buffer.header.size,12);\n\t      if (action == TGZ_LIST)\n\t\tprintf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n\t      if (action == TGZ_EXTRACT)\n\t\t{\n\t\t  if ((remaining) && (matchname(arg,argc,argv,fname)))\n\t\t    {\n\t\t      outfile = fopen(fname,\"wb\");\n\t\t      if (outfile == NULL) {\n\t\t\t/* try creating directory */\n\t\t\tchar *p = strrchr(fname, '/');\n\t\t\tif (p != NULL) {\n\t\t\t  *p = '\\0';\n\t\t\t  makedir(fname);\n\t\t\t  *p = '/';\n\t\t\t  outfile = fopen(fname,\"wb\");\n\t\t\t}\n\t\t      }\n\t\t      fprintf(stderr,\n\t\t\t      \"%s %s\\n\",\n\t\t\t      (outfile) ? \"Extracting\" : \"Couldn't create\",\n\t\t\t      fname);\n\t\t    }\n\t\t  else\n\t\t    outfile = NULL;\n\t\t}\n\t      /*\n\t       * could have no contents\n\t       */\n\t      getheader = (remaining) ? 0 : 1;\n\t      break;\n\t    default:\n\t      if (action == TGZ_LIST)\n\t\tprintf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n\n\t  if ((action == TGZ_EXTRACT) && (outfile != NULL))\n\t    {\n\t      if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n\t\t{\n\t\t  fprintf(stderr,\"%s : error writing %s skipping...\\n\",prog,fname);\n\t\t  fclose(outfile);\n\t\t  unlink(fname);\n\t\t}\n\t    }\n\t  remaining -= bytes;\n\t  if (remaining == 0)\n\t    {\n\t      getheader = 1;\n\t      if ((action == TGZ_EXTRACT) && (outfile != NULL))\n\t\t{\n\t\t  struct utimbuf settime;\n\n\t\t  settime.actime = settime.modtime = tartime;\n\n\t\t  fclose(outfile);\n\t\t  outfile = NULL;\n\t\t  utime(fname,&settime);\n\t\t}\n\t    }\n\t}\n    }\n  \n  if (gzclose(in) != Z_OK)\n    error(\"failed gzclose\");\n\n  return 0;\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "ea78ce4ffc8067383bbf5366572a210e9fc2def732fdaeda69677e0f1da6949c": [
  "void help(int exitval)\n{\n  fprintf(stderr,\n\t  \"untgz v 0.1\\n\"\n\t  \" an sample application of zlib 1.0.4\\n\\n\"\n          \"Usage : untgz TGZfile            to extract all files\\n\"\n          \"        untgz TGZfile fname ...  to extract selected files\\n\"\n          \"        untgz -l TGZfile         to list archive contents\\n\"\n          \"        untgz -h                 to display this help\\n\\n\");\n  exit(exitval);\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "a5d34c057afb63dfb21373fa66c0b59f2f7a9754731b9d5c86864ea2e07a294e": [
  "void error(const char *msg)\n{\n    fprintf(stderr, \"%s: %s\\n\", prog, msg);\n    exit(1);\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "5902c86b98cf47893317a5669f718b2702cabc239a612759b0a58dda9a9df6b7": [
  "int main(int argc,char **argv)\n{\n    int \taction = TGZ_EXTRACT;\n    int \targ = 1;\n    char\t*TGZfile;\n    gzFile\t*f;\n    \n\n    prog = strrchr(argv[0],'\\\\');\n    if (prog == NULL)\n      {\n\tprog = strrchr(argv[0],'/');\n\tif (prog == NULL)\n\t  {\n\t    prog = strrchr(argv[0],':');\n\t    if (prog == NULL)\n\t      prog = argv[0];\n\t    else\n\t      prog++;\n\t  }\n\telse\n\t  prog++;\n      }\n    else\n      prog++;\n    \n    if (argc == 1)\n      help(0);\n\n    if (strcmp(argv[arg],\"-l\") == 0)\n      {\n\taction = TGZ_LIST;\n\tif (argc == ++arg)\n\t  help(0);\n      }\n    else if (strcmp(argv[arg],\"-h\") == 0)\n      {\n\thelp(0);\n      }\n\n    if ((TGZfile = TGZfname(argv[arg])) == NULL)\n      TGZnotfound(argv[arg]);            \n\n    ++arg;\n    if ((action == TGZ_LIST) && (arg != argc))\n      help(1);\n\n/*\n *  Process the TGZ file\n */\n    switch(action)\n      {\n      case TGZ_LIST:\n      case TGZ_EXTRACT:\n\tf = gzopen(TGZfile,\"rb\");\n\tif (f == NULL)\n\t  {\n\t    fprintf(stderr,\"%s: Couldn't gzopen %s\\n\",\n\t\t    prog,\n\t\t    TGZfile);\n\t    return 1;\n\t  }\n\texit(tar(f, action, arg, argc, argv));\n      break;\n\t\n      default:\n\terror(\"Unknown option!\");\n\texit(1);\n      }\n\n    return 0;\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "0440d53cb7bcd2b7a7e7ef9ed8bb46500f8d24b59a2c338f0a2be0a23359b4cd": [
  "gzfilebuf::gzfilebuf() :\n  file(NULL),\n  mode(0),\n  own_file_descriptor(0)\n{ }",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "06c6ac117f1d44729e610784af8101dadbc9b249ee559e68be16a8ca42d2cac5": [
  "gzfilebuf::~gzfilebuf() {\n\n  sync();\n  if ( own_file_descriptor )\n    close();\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "f8b1ba7f728d4341c43e0568b3c2ec25f8e05e98bf5299d9c9470cb2f448f4d6": [
  "gzfilebuf *gzfilebuf::open( const char *name,\n\t\t\t    int io_mode ) {\n\n  if ( is_open() )\n    return NULL;\n\n  char char_mode[10];\n  char *p;\n  memset(char_mode,'\\0',10);\n  p = char_mode;\n\n  if ( io_mode & ios::in ) {\n    mode = ios::in;\n    *p++ = 'r';\n  } else if ( io_mode & ios::app ) {\n    mode = ios::app;\n    *p++ = 'a';\n  } else {\n    mode = ios::out;\n    *p++ = 'w';\n  }\n\n  if ( io_mode & ios::binary ) {\n    mode |= ios::binary;\n    *p++ = 'b';\n  }\n\n  // Hard code the compression level\n  if ( io_mode & (ios::out|ios::app )) {\n    *p++ = '9';\n  }\n\n  if ( (file = gzopen(name, char_mode)) == NULL )\n    return NULL;\n\n  own_file_descriptor = 1;\n\n  return this;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "1a30be2607e5b148728c78f214c681013a5ac16f1d817b984bff2a5c5d3977c7": [
  "gzfilebuf *gzfilebuf::attach( int file_descriptor,\n\t\t\t      int io_mode ) {\n\n  if ( is_open() )\n    return NULL;\n\n  char char_mode[10];\n  char *p;\n  memset(char_mode,'\\0',10);\n  p = char_mode;\n\n  if ( io_mode & ios::in ) {\n    mode = ios::in;\n    *p++ = 'r';\n  } else if ( io_mode & ios::app ) {\n    mode = ios::app;\n    *p++ = 'a';\n  } else {\n    mode = ios::out;\n    *p++ = 'w';\n  }\n\n  if ( io_mode & ios::binary ) {\n    mode |= ios::binary;\n    *p++ = 'b';\n  }\n\n  // Hard code the compression level\n  if ( io_mode & (ios::out|ios::app )) {\n    *p++ = '9';\n  }\n\n  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )\n    return NULL;\n\n  own_file_descriptor = 0;\n\n  return this;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "4efec753251fecd410c41afb71051cdba1ef93766e26977d2a7361c1582a9d85": [
  "gzfilebuf *gzfilebuf::close() {\n\n  if ( is_open() ) {\n\n    sync();\n    gzclose( file );\n    file = NULL;\n\n  }\n\n  return this;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "716e6e2d2503b04690cb56f37f7c1785f20230c5cfc3b928cfbb216cd50539f3": [
  "int gzfilebuf::setcompressionlevel( short comp_level ) {\n\n  return gzsetparams(file, comp_level, -2);\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "284c786dbe49a73b425464fe36ef4fd875ef2501bb1e4bf02ade9d9446f32bfa": [
  "int gzfilebuf::setcompressionstrategy( short comp_strategy ) {\n\n  return gzsetparams(file, -2, comp_strategy);\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "6d2221644e0fe25cac712b1dcb179311444dfe8e145efc10f9cd88b2c987d9cb": [
  "streampos gzfilebuf::seekoff( streamoff off, ios::seek_dir dir, int which ) {\n\n  return streampos(EOF);\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "4c329ee181e6a5964c0a2aa176c6662f9a8d9cc425b8dd9f6c1f36f5931003fc": [
  "int gzfilebuf::underflow() {\n\n  // If the file hasn't been opened for reading, error.\n  if ( !is_open() || !(mode & ios::in) )\n    return EOF;\n\n  // if a buffer doesn't exists, allocate one.\n  if ( !base() ) {\n\n    if ( (allocate()) == EOF )\n      return EOF;\n    setp(0,0);\n\n  } else {\n\n    if ( in_avail() )\n      return (unsigned char) *gptr();\n\n    if ( out_waiting() ) {\n      if ( flushbuf() == EOF )\n\treturn EOF;\n    }\n\n  }\n\n  // Attempt to fill the buffer.\n\n  int result = fillbuf();\n  if ( result == EOF ) {\n    // disable get area\n    setg(0,0,0);\n    return EOF;\n  }\n\n  return (unsigned char) *gptr();\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "abe6efa9c81918e14b3485bc0320285ab3112bff68d0d0f81647d16a9c7fdc8d": [
  "int gzfilebuf::overflow( int c ) {\n\n  if ( !is_open() || !(mode & ios::out) )\n    return EOF;\n\n  if ( !base() ) {\n    if ( allocate() == EOF )\n      return EOF;\n    setg(0,0,0);\n  } else {\n    if (in_avail()) {\n\treturn EOF;\n    }\n    if (out_waiting()) {\n      if (flushbuf() == EOF)\n\treturn EOF;\n    }\n  }\n\n  int bl = blen();\n  setp( base(), base() + bl);\n\n  if ( c != EOF ) {\n\n    *pptr() = c;\n    pbump(1);\n\n  }\n\n  return 0;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "6deb81a4bda83b336224c2716da7c8bbb255a1bb49bae96064ec03be119d7d81": [
  "int gzfilebuf::sync() {\n\n  if ( !is_open() )\n    return EOF;\n\n  if ( out_waiting() )\n    return flushbuf();\n\n  return 0;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "6914cd1e9e6b66a81ab7dda5bee92ed31ae7a97e491e3bc34ffdf26f8267415c": [
  "int gzfilebuf::flushbuf() {\n\n  int n;\n  char *q;\n\n  q = pbase();\n  n = pptr() - q;\n\n  if ( gzwrite( file, q, n) < n )\n    return EOF;\n\n  setp(0,0);\n\n  return 0;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "3d991e91078f94b84fb0d7cf62e1c33b839db301d6a4e5961657ea3898a143d3": [
  "int gzfilebuf::fillbuf() {\n\n  int required;\n  char *p;\n\n  p = base();\n\n  required = blen();\n\n  int t = gzread( file, p, required );\n\n  if ( t <= 0) return EOF;\n\n  setg( base(), base(), base()+t);\n\n  return t;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "1f7cdc4ad642f93aaedd9f64ff97e7834d3efca539cdafeccb303ee02c47ccd9": [
  "gzfilestream_common::gzfilestream_common() :\n  ios( gzfilestream_common::rdbuf() )\n{ }",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "b77bfde1af9c69915d2470e6971a688f2dc1a7f3c13728817f4bd2704bdcf457": [
  "gzfilestream_common::~gzfilestream_common()\n{ }",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "dc16c05f1aecda0708f6b2ede0be09641090a3c00ef309e390a100c9c2c33724": [
  "void gzfilestream_common::attach( int fd, int io_mode ) {\n\n  if ( !buffer.attach( fd, io_mode) )\n    clear( ios::failbit | ios::badbit );\n  else\n    clear();\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "92c6e1fdc96477c3580803510ee31c9ba5b1d1b037f182038e6d795ce2934c15": [
  "void gzfilestream_common::open( const char *name, int io_mode ) {\n\n  if ( !buffer.open( name, io_mode ) )\n    clear( ios::failbit | ios::badbit );\n  else\n    clear();\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "033e485f35a9a942e11f82d911814f4cbf6013dfd8d4c3e68a218e76baa23708": [
  "void gzfilestream_common::close() {\n\n  if ( !buffer.close() )\n    clear( ios::failbit | ios::badbit );\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "c4ce648cf1aad693eafc2d4cd076ab8768ad3c51904961287d646424450a647a": [
  "gzfilebuf *gzfilestream_common::rdbuf() {\n\n  return &buffer;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "0403b6fcf104171bea7d900ee464f2366a1543eb4813adddfcb8d9b7e92db695": [
  "gzifstream::gzifstream() :\n  ios( gzfilestream_common::rdbuf() )\n{\n  clear( ios::badbit );\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "94b859a30eb0c68a144e2055a9cdbf4ee8ab019197068bf380b2e76eb2196ae2": [
  "gzifstream::gzifstream( const char *name, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::open( name, io_mode );\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "8fca3dc7a24485441399a9e995d5e9c9fa07a8c814b97a37a4238111761bea70": [
  "gzifstream::gzifstream( int fd, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::attach( fd, io_mode );\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "6fafc2833fcb9a89e01fb8195585c8d5cfeec1821b8ce4a72540a82fdd58d157": [
  "gzifstream::~gzifstream() { }",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "b810129181f09e907bf026b293eb8966104169a84aa47aacbfc23ea0c25d77b2": [
  "gzofstream::gzofstream() :\n  ios( gzfilestream_common::rdbuf() )\n{\n  clear( ios::badbit );\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "134bd04d94def704c0b71eaa50ec32dd0552988341497466e7f2611d1cc9df2a": [
  "gzofstream::gzofstream( const char *name, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::open( name, io_mode );\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "6509ebb2658d76fc6c566c13e8dc8243c60013f05536a497cd7b2b21f336228f": [
  "gzofstream::gzofstream( int fd, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::attach( fd, io_mode );\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "2ed0d9471f5c0423c6202f5afea97b7e7b7175ea757db580779ec5e4993da864": [
  "gzofstream::~gzofstream() { }",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "e74de8be59833024396762746825d83856fcc87d0792fc38fb502430d6ad62f7": [
  "int main() {\n\n  // Construct a stream object with this filebuffer.  Anything sent\n  // to this stream will go to standard out.\n  gzofstream os( 1, ios::out );\n\n  // This text is getting compressed and sent to stdout.\n  // To prove this, run 'test | zcat'.\n  os << \"Hello, Mommy\" << endl;\n\n  os << setcompressionlevel( Z_NO_COMPRESSION );\n  os << \"hello, hello, hi, ho!\" << endl;\n\n  setcompressionlevel( os, Z_DEFAULT_COMPRESSION )\n    << \"I'm compressing again\" << endl;\n\n  os.close();\n\n  return 0;\n\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "contrib/iostream/test.cpp"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "contrib/iostream/test.cpp"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/iostream/test.cpp"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/iostream/test.cpp"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/iostream/test.cpp"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/iostream/test.cpp"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/iostream/test.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/test.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/test.cpp"
   ]
  }
 ],
 "35d460695d27242ad6803493fe3433890fff949151f1de3593458dc61fb8e6f6": [
  "const char * EXPORT zlibVersion()\n{\n    return ZLIB_VERSION;\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "zutil.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "zutil.c"
   ]
  }
 ],
 "9d4a3aa7fbe833db11c0b9d8fc6a0f8ec461234541ab29f204ea4fc5368a8c1f": [
  "int EXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n{\n    char buf[Z_BUFSIZE];\n    va_list va;\n    int len;\n\n    va_start(va, format);\n#ifdef HAS_vsnprintf\n    len = vsnprintf(buf, sizeof(buf), format, va);\n#else\n    len = vsprintf(buf, format, va);\n#endif\n    va_end(va);\n    if (len <= 0) return 0;\n\n    return gzwrite(file, buf, (unsigned)len);\n}",
  {
   "v1.0.7": [
    "2011-09-09 23:17:33",
    "gzio.c"
   ],
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "gzio.c"
   ]
  }
 ],
 "8f5e2d7ffc5030dd44c6e945ce189db4e0d27c5186b837aa44adad807815936f": [
  "int hello() {return getchar();}",
  {
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "test.c"
   ]
  }
 ],
 "c13bd81affef4fb8912a06d12b3f055a404f9a2d4d61c33d9cc65b7000ad4f6c": [
  "int hello() {return 0;}",
  {
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "ztest28975.c"
   ]
  }
 ],
 "fc73ed04ccad29576223c4008ae06b08c41d39657c43e9cbfcb699152e841732": [
  "local void make_crc_table()\n{\n  uLong c;\n  int n, k;\n  uLong poly;            /* polynomial exclusive-or pattern */\n  /* terms of polynomial defining this crc (except x^32): */\n  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n  /* make exclusive-or pattern from polynomial (0xedb88320L) */\n  poly = 0L;\n  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)\n    poly |= 1L << (31 - p[n]);\n \n  for (n = 0; n < 256; n++)\n  {\n    c = (uLong)n;\n    for (k = 0; k < 8; k++)\n      c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n    crc_table[n] = c;\n  }\n  crc_table_empty = 0;\n}",
  {
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "crc32.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "crc32.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "crc32.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "crc32.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "crc32.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "crc32.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "crc32.c"
   ]
  }
 ],
 "5a8ef5a74f511968cdb0350f6cb547d399b8142675912d577119b304b79b47a8": [
  "const uLongf * EXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n  if (crc_table_empty) make_crc_table();\n#endif\n  return (const uLongf *)crc_table;\n}",
  {
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "crc32.c"
   ]
  }
 ],
 "d5ff29665aae0bdb78676bbea223b420034a7b049068c3f07594ed9f0aa3a470": [
  "local void tr_static_init()\n{\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}",
  {
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "trees.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "trees.c"
   ]
  }
 ],
 "e254b9287f6b1ea99544c72436fcce3d590b41424231d874a25cfb8ca0417ec2": [
  "void gen_trees_header()\n{\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header != NULL, \"Can't open trees.h\");\n    fprintf(header,\n\t    \"/* header created automatically with -DGEN_TREES_H */\\n\\n\");\n\n    fprintf(header, \"local const ct_data static_ltree[L_CODES+2] = {\\n\");\n    for (i = 0; i < L_CODES+2; i++) {\n\tfprintf(header, \"{{%3u},{%3u}}%s\", static_ltree[i].Code,\n\t\tstatic_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));\n    }\n\n    fprintf(header, \"local const ct_data static_dtree[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n\tfprintf(header, \"{{%2u},{%2u}}%s\", static_dtree[i].Code,\n\t\tstatic_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));\n    }\n\n    fprintf(header, \"local const uch dist_code[DIST_CODE_LEN] = {\\n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) {\n\tfprintf(header, \"%2u%s\", dist_code[i],\n\t\tSEPARATOR(i, DIST_CODE_LEN-1, 20));\n    }\n\n    fprintf(header, \"local const uch length_code[MAX_MATCH-MIN_MATCH+1]= {\\n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {\n\tfprintf(header, \"%2u%s\", length_code[i],\n\t\tSEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    }\n\n    fprintf(header, \"local const int base_length[LENGTH_CODES] = {\\n\");\n    for (i = 0; i < LENGTH_CODES; i++) {\n\tfprintf(header, \"%1u%s\", base_length[i],\n\t\tSEPARATOR(i, LENGTH_CODES-1, 20));\n    }\n\n    fprintf(header, \"local const int base_dist[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n\tfprintf(header, \"%5u%s\", base_dist[i],\n\t\tSEPARATOR(i, D_CODES-1, 10));\n    }\n\n    fclose(header);\n}",
  {
   "v1.0.8": [
    "2011-09-09 23:18:57",
    "trees.c"
   ],
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "trees.c"
   ]
  }
 ],
 "e9cf0f92576e15a0a5fd2907dd0a176a1e1c55cd1ed403da09fa82180f62d1db": [
  "uInt longest_match(\n    deflate_state *s,\n    IPos cur_match)                             /* current match */\n{\n\tstatic uInt iIsPPro=2;\n\n    if ((s->w_mask == 0x7fff) && (iIsPPro==0))\n        return longest_match_7fff(s,cur_match);\n\n\tif (iIsPPro==2)\n\t\tiIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\n\n\treturn longest_match_c(s,cur_match);\n}",
  {
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/asm386/gvmat32c.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/asm386/gvmat32c.c"
   ]
  }
 ],
 "4a2662d818e7450271c4c103617bfdd6d64caefcd6739a297a3c9a5be9701b06": [
  "const char * ZEXPORT zlibVersion()\n{\n    return ZLIB_VERSION;\n}",
  {
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "zutil.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "zutil.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "zutil.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "zutil.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "zutil.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "zutil.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "zutil.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "zutil.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "zutil.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "zutil.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "zutil.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "zutil.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "zutil.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "zutil.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "zutil.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "zutil.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "zutil.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "zutil.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "zutil.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "zutil.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "zutil.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "zutil.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "zutil.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "zutil.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "zutil.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "zutil.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "zutil.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "zutil.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "zutil.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "zutil.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "zutil.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "zutil.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "zutil.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "zutil.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "zutil.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "zutil.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "zutil.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "zutil.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "zutil.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "zutil.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "zutil.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "zutil.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "zutil.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "zutil.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "zutil.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "zutil.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "zutil.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "zutil.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "zutil.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "zutil.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "zutil.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "zutil.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "zutil.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "zutil.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "zutil.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "zutil.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "zutil.c"
   ]
  }
 ],
 "9e52ba8b3bd128235a08b095c013a17017db3d66bd101e62a8e50000d8e4f838": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n{\n    char buf[Z_BUFSIZE];\n    va_list va;\n    int len;\n\n    va_start(va, format);\n#ifdef HAS_vsnprintf\n    (void)vsnprintf(buf, sizeof(buf), format, va);\n#else\n    (void)vsprintf(buf, format, va);\n#endif\n    va_end(va);\n    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */\n    if (len <= 0) return 0;\n\n    return gzwrite(file, buf, (unsigned)len);\n}",
  {
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "gzio.c"
   ]
  }
 ],
 "d9add204d8c52af2a85ce0ad02dd6204f8915d36ca4133947acc8bde1d8c9d40": [
  "const uLongf * ZEXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n  if (crc_table_empty) make_crc_table();\n#endif\n  return (const uLongf *)crc_table;\n}",
  {
   "v1.0.9": [
    "2011-09-09 23:19:21",
    "crc32.c"
   ],
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "crc32.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "crc32.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "crc32.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "crc32.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "crc32.c"
   ]
  }
 ],
 "417169c2851e8b168a5523ba4df8e15899ba8c7336d3a747467b1db02b420af1": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n{\n    char buf[Z_PRINTF_BUFSIZE];\n    va_list va;\n    int len;\n\n    va_start(va, format);\n#ifdef HAS_vsnprintf\n    (void)vsnprintf(buf, sizeof(buf), format, va);\n#else\n    (void)vsprintf(buf, format, va);\n#endif\n    va_end(va);\n    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */\n    if (len <= 0) return 0;\n\n    return gzwrite(file, buf, (unsigned)len);\n}",
  {
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "gzio.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "gzio.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "gzio.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "gzio.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "gzio.c"
   ]
  }
 ],
 "34cf20a31304d42b69827e402b7e50f79aa3a807a351629c1e8a2bd541e071ea": [
  "local void tr_static_init()\n{\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            _length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            _dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            _dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}",
  {
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "trees.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "trees.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "trees.c"
   ]
  }
 ],
 "02bc75ed14e37009522755117d5b3bc2b46251547f6e12a84032dc50e65ab091": [
  "void gen_trees_header()\n{\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header != NULL, \"Can't open trees.h\");\n    fprintf(header,\n\t    \"/* header created automatically with -DGEN_TREES_H */\\n\\n\");\n\n    fprintf(header, \"local const ct_data static_ltree[L_CODES+2] = {\\n\");\n    for (i = 0; i < L_CODES+2; i++) {\n\tfprintf(header, \"{{%3u},{%3u}}%s\", static_ltree[i].Code,\n\t\tstatic_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));\n    }\n\n    fprintf(header, \"local const ct_data static_dtree[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n\tfprintf(header, \"{{%2u},{%2u}}%s\", static_dtree[i].Code,\n\t\tstatic_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));\n    }\n\n    fprintf(header, \"const uch _dist_code[DIST_CODE_LEN] = {\\n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) {\n\tfprintf(header, \"%2u%s\", _dist_code[i],\n\t\tSEPARATOR(i, DIST_CODE_LEN-1, 20));\n    }\n\n    fprintf(header, \"const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\\n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {\n\tfprintf(header, \"%2u%s\", _length_code[i],\n\t\tSEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    }\n\n    fprintf(header, \"local const int base_length[LENGTH_CODES] = {\\n\");\n    for (i = 0; i < LENGTH_CODES; i++) {\n\tfprintf(header, \"%1u%s\", base_length[i],\n\t\tSEPARATOR(i, LENGTH_CODES-1, 20));\n    }\n\n    fprintf(header, \"local const int base_dist[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n\tfprintf(header, \"%5u%s\", base_dist[i],\n\t\tSEPARATOR(i, D_CODES-1, 10));\n    }\n\n    fclose(header);\n}",
  {
   "v1.1.0": [
    "2011-09-09 23:19:55",
    "trees.c"
   ],
   "v1.1.1": [
    "2011-09-09 23:20:07",
    "trees.c"
   ],
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "trees.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "trees.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "trees.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "trees.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "trees.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "trees.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "trees.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "trees.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "trees.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "trees.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "trees.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "trees.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "trees.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "trees.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "trees.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "trees.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "trees.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "trees.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "trees.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "trees.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "trees.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "trees.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "trees.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "trees.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "trees.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "trees.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "trees.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "trees.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "trees.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "trees.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "trees.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "trees.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "trees.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "trees.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "trees.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "trees.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "trees.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "trees.c"
   ]
  }
 ],
 "ea552d264822e88c0ce86aea1945d045ff561cdedc138c866e414f6e9534aceb": [
  "void do_banner()\n{\n\tprintf(\"MiniZip 0.15, demo of zLib + Zip package written by Gilles Vollant\\n\");\n\tprintf(\"more info at http://wwww.winimage/zLibDll/unzip.htm\\n\\n\");\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/minizip/minizip.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/minizip/minizip.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "69ca59eb214f210ef1829f65a62077927179cfce3e35d84deefea43f4acfcdfc": [
  "void do_help()\n{\t\n\tprintf(\"Usage : minizip [-o] file.zip [files_to_add]\\n\\n\") ;\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/minizip/minizip.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/minizip/minizip.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "712065fa51c155b95f0a9ac0d2bab3a676b67426985d1534de7c54d79eb6a6bc": [
  "local linkedlist_datablock_internal* allocate_new_datablock()\n{\n    linkedlist_datablock_internal* ldi;\n    ldi = (linkedlist_datablock_internal*)\n                 ALLOC(sizeof(linkedlist_datablock_internal));\n    if (ldi!=NULL)\n    {\n        ldi->next_datablock = NULL ;\n        ldi->filled_in_this_block = 0 ;\n        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;\n    }\n    return ldi;\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/minizip/zip.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/minizip/zip.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/minizip/zip.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/minizip/zip.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/minizip/zip.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/minizip/zip.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/minizip/zip.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/minizip/zip.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/minizip/zip.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "3a093322ca781a5b6c7aa470ab1b2fbb8f9f9960b6dfc10357001ead6b476aec": [
  "void do_banner()\n{\n\tprintf(\"MiniUnz 0.15, demo of zLib + Unz package written by Gilles Vollant\\n\");\n\tprintf(\"more info at http://wwww.winimage/zLibDll/unzip.htm\\n\\n\");\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/minizip/miniunz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/minizip/miniunz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "21d2506c0021a69b8e3039f73159453e5eb7ade4b4c0f4a65891e1e3a6121300": [
  "void do_help()\n{\t\n\tprintf(\"Usage : miniunz [-exvlo] file.zip [file_to_extract]\\n\\n\") ;\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "contrib/minizip/miniunz.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/minizip/miniunz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "29666093f39483af8cf7784abc34989b445c0380c56da20df4311b1c7110bec2": [
  "void showtree(uInt b, inflate_huft *t, int d)\n{\n  int i, e;\n  char p[2*d+1];\n\n  for (i = 0; i < 2*d; i++)\n    p[i] = ' ';\n  p[i] = 0;\n  printf(\"%s[%d]\\n\", p, 1<<b);\n  for (i = 0; i < (1<<b); i++)\n  {\n    e = t[i].exop;\n    if (e == 0)                 /* simple code */\n      printf(\"%s%d(%d): literal=%d\\n\", p, i, t[i].bits, t[i].base);\n    else if (e & 16)            /* length */\n      printf(\"%s%d(%d): length/distance=%d+(%d)\\n\",\n                p, i, t[i].bits, t[i].base, e & 15);\n    else if ((e & 64) == 0)     /* next table */\n    {\n      printf(\"%s%d(%d): *sub table*\\n\", p, i, t[i].bits);\n      showtree(e, t + t[i].base, d + 1);\n    }\n    else if (e & 32)            /* end of block */\n      printf(\"%s%d(%d): end of block\\n\", p, i, t[i].bits);\n    else                        /* bad code */\n      printf(\"%s%d: bad code\\n\", p, i);\n  }\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "maketree.c"
   ]
  }
 ],
 "b516436fc8e64f3a9e0530f5cdeeb91307ae972f77dfe9c355e68a1eff473e33": [
  "void maketree(uInt b, inflate_huft *t)\n{\n  int i, e;\n\n  i = 0;\n  while (1)\n  {\n    e = t[i].exop;\n    if (e && (e & (16+64)) == 0)        /* table pointer */\n    {\n      fprintf(stderr, \"maketree: cannot initialize sub-tables!\\n\");\n      exit(1);\n    }\n    if (i % 5 == 0)\n      printf(\"\\n   \");\n    printf(\" {{%u,%u},%u}\", t[i].exop, t[i].bits, t[i].base);\n    if (++i == (1<<b))\n      break;\n    putchar(',');\n  }\n  puts(\"\");\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "maketree.c"
   ]
  }
 ],
 "7f18685fa16983ea66b1199a4686f745a1c24e93a4c4261501c1799f0cf37b42": [
  "void main(void)\n{\n  int r;\n  uInt bl, bd;\n  inflate_huft *tl, *td;\n  z_stream z;\n\n  z.zalloc = zcalloc;\n  z.opaque = (voidpf)0;\n  z.zfree = zcfree;\n  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);\n  if (r)\n  {\n    fprintf(stderr, \"inflate_trees_fixed error %d\\n\", r);\n    return;\n  }\n  /* puts(\"Literal/Length Tree:\");\n     showtree(bl, tl, 1);\n     puts(\"Distance Tree:\");\n     showtree(bd, td, 1); */\n  puts(\"/* inffixed.h -- table for decoding fixed codes\");\n  puts(\" * Generated automatically by the maketree.c program\");\n  puts(\" */\");\n  puts(\"\");\n  puts(\"/* WARNING: this file should *not* be used by applications. It is\");\n  puts(\"   part of the implementation of the compression library and is\");\n  puts(\"   subject to change. Applications should only use zlib.h.\");\n  puts(\" */\");\n  puts(\"\");\n  printf(\"local uInt fixed_bl = %d;\\n\", bl);\n  printf(\"local uInt fixed_bd = %d;\\n\", bd);\n  printf(\"local inflate_huft fixed_tl[] = {\");\n  maketree(bl, tl);\n  puts(\"  };\");\n  printf(\"local inflate_huft fixed_td[] = {\");\n  maketree(bd, td);\n  puts(\"  };\");\n}",
  {
   "v1.1.2": [
    "2011-09-09 23:20:15",
    "maketree.c"
   ],
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "maketree.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "maketree.c"
   ]
  }
 ],
 "d423ef7014ad1f2548e20bd9b972e019760a40fc90516608a21ee76299fe5f54": [
  "int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void*)\n{\n        return 1;\n}",
  {
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/delphi2/zlib32.cpp"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/delphi2/zlib32.cpp"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/delphi2/zlib32.cpp"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/delphi2/zlib32.cpp"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/delphi2/zlib32.cpp"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/delphi2/zlib32.cpp"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/delphi2/zlib32.cpp"
   ]
  }
 ],
 "5c70aaa880e98f27d7c742d2936ce8c588714cc0fa64623aed765311e0aac31f": [
  "int tar (gzFile in,int action,int arg,int argc,char **argv)\n{\n  union  tar_buffer buffer;\n  int    len;\n  int    err;\n  int    getheader = 1;\n  int    remaining = 0;\n  FILE   *outfile = NULL;\n  char   fname[BLOCKSIZE];\n  time_t tartime;\n  \n  if (action == TGZ_LIST)\n    printf(\"     day      time     size                       file\\n\"\n\t   \" ---------- -------- --------- -------------------------------------\\n\");\n  while (1)\n    {\n      len = gzread(in, &buffer, BLOCKSIZE);\n      if (len < 0)\n\terror (gzerror(in, &err));\n      /*\n       * Always expect complete blocks to process\n       * the tar information.\n       */\n      if (len != BLOCKSIZE)\n\terror(\"gzread: incomplete block read\");\n      \n      /*\n       * If we have to get a tar header\n       */\n      if (getheader == 1)\n\t{\n\t  /*\n\t   * if we met the end of the tar\n\t   * or the end-of-tar block,\n\t   * we are done\n\t   */\n\t  if ((len == 0)  || (buffer.header.name[0]== 0)) break;\n\n\t  tartime = (time_t)getoct(buffer.header.mtime,12);\n\t  strcpy(fname,buffer.header.name);\n\t  \n\t  switch (buffer.header.typeflag)\n\t    {\n\t    case DIRTYPE:\n\t      if (action == TGZ_LIST)\n\t\tprintf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n\t      if (action == TGZ_EXTRACT)\n\t\tmakedir(fname);\n\t      break;\n\t    case REGTYPE:\n\t    case AREGTYPE:\n\t      remaining = getoct(buffer.header.size,12);\n\t      if (action == TGZ_LIST)\n\t\tprintf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n\t      if (action == TGZ_EXTRACT)\n\t\t{\n\t\t  if ((remaining) && (matchname(arg,argc,argv,fname)))\n\t\t    {\n\t\t      outfile = fopen(fname,\"wb\");\n\t\t      if (outfile == NULL) {\n\t\t\t/* try creating directory */\n\t\t\tchar *p = strrchr(fname, '/');\n\t\t\tif (p != NULL) {\n\t\t\t  *p = '\\0';\n\t\t\t  makedir(fname);\n\t\t\t  *p = '/';\n\t\t\t  outfile = fopen(fname,\"wb\");\n\t\t\t}\n\t\t      }\n\t\t      fprintf(stderr,\n\t\t\t      \"%s %s\\n\",\n\t\t\t      (outfile) ? \"Extracting\" : \"Couldn't create\",\n\t\t\t      fname);\n\t\t    }\n\t\t  else\n\t\t    outfile = NULL;\n\t\t}\n\t      /*\n\t       * could have no contents\n\t       */\n\t      getheader = (remaining) ? 0 : 1;\n\t      break;\n\t    default:\n\t      if (action == TGZ_LIST)\n\t\tprintf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n\n\t  if ((action == TGZ_EXTRACT) && (outfile != NULL))\n\t    {\n\t      if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n\t\t{\n\t\t  fprintf(stderr,\"%s : error writing %s skipping...\\n\",prog,fname);\n\t\t  fclose(outfile);\n\t\t  unlink(fname);\n\t\t}\n\t    }\n\t  remaining -= bytes;\n\t  if (remaining == 0)\n\t    {\n\t      getheader = 1;\n\t      if ((action == TGZ_EXTRACT) && (outfile != NULL))\n\t\t{\n#ifdef WIN32\n\t\t  HANDLE hFile;\n\t\t  FILETIME ftm,ftLocal;\n\t\t  SYSTEMTIME st;\n\t\t  struct tm localt;\n \n\t\t  fclose(outfile);\n\n\t\t  localt = *localtime(&tartime);\n\n\t\t  hFile = CreateFile(fname, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t     0, NULL, OPEN_EXISTING, 0, NULL);\n\t\t  \n\t\t  st.wYear = (WORD)localt.tm_year+1900;\n\t\t  st.wMonth = (WORD)localt.tm_mon;\n\t\t  st.wDayOfWeek = (WORD)localt.tm_wday;\n\t\t  st.wDay = (WORD)localt.tm_mday;\n\t\t  st.wHour = (WORD)localt.tm_hour;\n\t\t  st.wMinute = (WORD)localt.tm_min;\n\t\t  st.wSecond = (WORD)localt.tm_sec;\n\t\t  st.wMilliseconds = 0;\n\t\t  SystemTimeToFileTime(&st,&ftLocal);\n\t\t  LocalFileTimeToFileTime(&ftLocal,&ftm);\n\t\t  SetFileTime(hFile,&ftm,NULL,&ftm);\n\t\t  CloseHandle(hFile);\n\n\t\t  outfile = NULL;\n#else\n\t\t  struct utimbuf settime;\n\n\t\t  settime.actime = settime.modtime = tartime;\n\n\t\t  fclose(outfile);\n\t\t  outfile = NULL;\n\t\t  utime(fname,&settime);\n#endif\n\t\t}\n\t    }\n\t}\n    }\n  \n  if (gzclose(in) != Z_OK)\n    error(\"failed gzclose\");\n\n  return 0;\n}",
  {
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "2aa57e039e38c31c9722a758fc8b72e2d80b32ffda2e48ab366b140135f8b0bc": [
  "void maketree(uInt b, inflate_huft *t)\n{\n  int i, e;\n\n  i = 0;\n  while (1)\n  {\n    e = t[i].exop;\n    if (e && (e & (16+64)) == 0)        /* table pointer */\n    {\n      fprintf(stderr, \"maketree: cannot initialize sub-tables!\\n\");\n      exit(1);\n    }\n    if (i % 4 == 0)\n      printf(\"\\n   \");\n    printf(\" {{{%u,%u}},%u}\", t[i].exop, t[i].bits, t[i].base);\n    if (++i == (1<<b))\n      break;\n    putchar(',');\n  }\n  puts(\"\");\n}",
  {
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "maketree.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "maketree.c"
   ]
  }
 ],
 "570792e248fdae7db0a2f675e0d77aff747c7f61c13ec58878e5b564172e521d": [
  "local void tr_static_init()\n{\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            _length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            _dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            _dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}",
  {
   "v1.1.3": [
    "2011-09-09 23:20:29",
    "trees.c"
   ],
   "v1.1.4": [
    "2011-09-09 23:20:42",
    "trees.c"
   ],
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "trees.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "trees.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "trees.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "trees.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "trees.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "trees.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "trees.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "trees.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "trees.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "trees.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "trees.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "trees.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "trees.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "trees.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "trees.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "trees.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "trees.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "trees.c"
   ]
  }
 ],
 "5738e2d5f217e90f5cd0d4340afbe71fe048676b2358e865eb108f606febbfb0": [
  "local int bits(struct state *s, int need)\n{\n    int val;\t\t/* bit accumulator */\n\n    /* load at least need bits into val */\n    val = s->bitbuf;\n    while (s->bitcnt < need) {\n        if (s->left == 0) {\n            s->left = s->infun(s->inhow, &(s->in));\n            if (s->left == 0) longjmp(s->env, 1);\t/* out of input */\n        }\n        val |= (int)(*(s->in)++) << s->bitcnt;\t\t/* load eight bits */\n        s->left--;\n        s->bitcnt += 8;\n    }\n\n    /* drop need bits and update buffer, always zero to seven bits left */\n    s->bitbuf = val >> need;\n    s->bitcnt -= need;\n\n    /* return need bits, zeroing the bits above that */\n    return val & ((1 << need) - 1);\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "8240819a10187340717a4bda4aae93b8e68e5f96452138391cdcbd8f55be7b4c": [
  "local int decode(struct state *s, struct huffman *h)\n{\n    int len;\t\t/* current number of bits in code */\n    int code;\t\t/* len bits being decoded */\n    int first;\t\t/* first code of length len */\n    int count;\t\t/* number of codes of length len */\n    int index;\t\t/* index of first code of length len in symbol table */\n    int bitbuf;\t\t/* bits from stream */\n    int left;\t\t/* bits left in next or left to process */\n    short *next;\t/* next number of codes */\n\n    bitbuf = s->bitbuf;\n    left = s->bitcnt;\n    code = first = index = 0;\n    len = 1;\n    next = h->count + 1;\n    while (1) {\n        while (left--) {\n            code |= (bitbuf & 1) ^ 1;\t/* invert code */\n            bitbuf >>= 1;\n            count = *next++;\n            if (code < first + count) {\t/* if length len, return symbol */\n                s->bitbuf = bitbuf;\n                s->bitcnt = (s->bitcnt - len) & 7;\n                return h->symbol[index + (code - first)];\n            }\n            index += count;\t\t/* else update for next length */\n            first += count;\n            first <<= 1;\n            code <<= 1;\n            len++;\n        }\n        left = (MAXBITS+1) - len;\n        if (left == 0) break;\n        if (s->left == 0) {\n            s->left = s->infun(s->inhow, &(s->in));\n            if (s->left == 0) longjmp(s->env, 1);\t/* out of input */\n        }\n        bitbuf = *(s->in)++;\n        s->left--;\n        if (left > 8) left = 8;\n    }\n    return -9;\t\t\t\t/* ran out of codes */\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "0574ab7207a7e51451a8f8a7585f958c10aaddb135d505b6b13059cd555d51aa": [
  "local int construct(struct huffman *h, const unsigned char *rep, int n)\n{\n    int symbol;\t\t/* current symbol when stepping through length[] */\n    int len;\t\t/* current length when stepping through h->count[] */\n    int left;\t\t/* number of possible codes left of current length */\n    short offs[MAXBITS+1];\t/* offsets in symbol table for each length */\n    short length[256];\t/* code lengths */\n\n    /* convert compact repeat counts into symbol bit length list */\n    symbol = 0;\n    do {\n        len = *rep++;\n        left = (len >> 4) + 1;\n        len &= 15;\n        do {\n            length[symbol++] = len;\n        } while (--left);\n    } while (--n);\n    n = symbol;\n\n    /* count number of codes of each length */\n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;\t/* assumes lengths are within bounds */\n    if (h->count[0] == n)\t\t/* no codes! */\n        return 0;\t\t\t/* complete, but decode() will fail */\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\t\t\t\t/* one possible code of zero length */\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\t\t\t/* one more bit, double codes left */\n        left -= h->count[len];\t\t/* deduct count from possible codes */\n        if (left < 0) return left;\t/* over-subscribed--return negative */\n    }\t\t\t\t\t/* left > 0 means incomplete */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n\n    /*\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     */\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n\n    /* return zero for complete set, positive for incomplete set */\n    return left;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "7a0b2ebf61d3d1c115adfbdacf0c82b47ea55433de3788ab53a3f16fa532b6c1": [
  "local int decomp(struct state *s)\n{\n    int lit;\t\t/* true if literals are coded */\n    int dict;\t\t/* log2(dictionary size) - 6 */\n    int symbol;\t\t/* decoded symbol, extra bits for distance */\n    int len;\t\t/* length for copy */\n    int dist;\t\t/* distance for copy */\n    int copy;\t\t/* copy counter */\n    unsigned char *from, *to;\t/* copy pointers */\n    static int virgin = 1;\t\t\t\t/* build tables once */\n    static short litcnt[MAXBITS+1], litsym[256];\t/* litcode memory */\n    static short lencnt[MAXBITS+1], lensym[16];\t\t/* lencode memory */\n    static short distcnt[MAXBITS+1], distsym[64];\t/* distcode memory */\n    static struct huffman litcode = {litcnt, litsym};\t/* length code */\n    static struct huffman lencode = {lencnt, lensym};\t/* length code */\n    static struct huffman distcode = {distcnt, distsym};/* distance code */\n        /* bit lengths of literal codes */\n    static const unsigned char litlen[] = {\n\t11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,\n\t9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,\n\t7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,\n\t8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,\n\t44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,\n\t44, 173};\n        /* bit lengths of length codes 0..15 */\n    static const unsigned char lenlen[] = {2, 35, 36, 53, 38, 23};\n        /* bit lengths of distance codes 0..63 */\n    static const unsigned char distlen[] = {2, 20, 53, 230, 247, 151, 248};\n    static const short base[16] = {\t/* base for length codes */\n        3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264};\n    static const char extra[16] = {\t/* extra bits for length codes */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n\n    /* set up decoding tables (once--might not be thread-safe) */\n    if (virgin) {\n        construct(&litcode, litlen, sizeof(litlen));\n        construct(&lencode, lenlen, sizeof(lenlen));\n        construct(&distcode, distlen, sizeof(distlen));\n        virgin = 0;\n    }\n\n    /* read header */\n    lit = bits(s, 8);\n    if (lit > 1) return -1;\n    dict = bits(s, 8);\n    if (dict < 4 || dict > 6) return -2;\n\n    /* decode literals and length/distance pairs */\n    do {\n        if (bits(s, 1)) {\n            /* get length */\n            symbol = decode(s, &lencode);\n            len = base[symbol] + bits(s, extra[symbol]);\n            if (len == 519) break;\t\t/* end code */\n\n            /* get distance */\n            symbol = len == 2 ? 2 : dict;\n            dist = decode(s, &distcode) << symbol;\n            dist += bits(s, symbol);\n            dist++;\n            if (s->first && dist > s->next)\n                return -3;\t\t/* distance too far back */\n\n            /* copy length bytes from distance bytes back */\n            do {\n                to = s->out + s->next;\n                from = to - dist;\n                copy = MAXWIN;\n                if (s->next < dist) {\n                    from += copy;\n                    copy = dist;\n                }\n                copy -= s->next;\n                if (copy > len) copy = len;\n                len -= copy;\n                s->next += copy;\n                do {\n                    *to++ = *from++;\n                } while (--copy);\n                if (s->next == MAXWIN) {\n                    if (s->outfun(s->outhow, s->out, s->next)) return 1;\n                    s->next = 0;\n                    s->first = 0;\n                }\n            } while (len != 0);\n        }\n        else {\n            /* get literal and write it */\n            symbol = lit ? decode(s, &litcode) : bits(s, 8);\n            s->out[s->next++] = symbol;\n            if (s->next == MAXWIN) {\n                if (s->outfun(s->outhow, s->out, s->next)) return 1;\n                s->next = 0;\n                s->first = 0;\n            }\n        }\n    } while (1);\n    return 0;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "07cfceea27e257fbb4870004a06df9c843d212e12f205fa6eb7a277a4fdc0939": [
  "int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow)\n{\n    struct state s;\t\t/* input/output state */\n    int err;\t\t\t/* return value */\n\n    /* initialize input state */\n    s.infun = infun;\n    s.inhow = inhow;\n    s.left = 0;\n    s.bitbuf = 0;\n    s.bitcnt = 0;\n\n    /* initialize output state */\n    s.outfun = outfun;\n    s.outhow = outhow;\n    s.next = 0;\n    s.first = 1;\n\n    /* return if bits() or decode() tries to read past available input */\n    if (setjmp(s.env) != 0)\t\t/* if came back here via longjmp(), */\n        err = 2;\t\t\t/*  then skip decomp(), return error */\n    else\n        err = decomp(&s);\t\t/* decompress */\n\n    /* write any leftover output and update the error code if needed */\n    if (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)\n        err = 1;\n    return err;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "f827ffe53dd255c7857ecdc53d90d4bf5f51073acb800173957ab9d8d14daf6d": [
  "local unsigned inf(void *how, unsigned char **buf)\n{\n    static unsigned char hold[CHUNK];\n\n    *buf = hold;\n    return fread(hold, 1, CHUNK, (FILE *)how);\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "2ef98d7afcec957b832b1c14b28d4d341a30037aeb5e3ef895dd989bc4868598": [
  "local int outf(void *how, unsigned char *buf, unsigned len)\n{\n    return fwrite(buf, 1, len, (FILE *)how) != len;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "fc1143e81b3173cd0170fd83562ee83a1aea9480b990fef2ffa980df589693c2": [
  "int main(void)\n{\n    int ret, n;\n\n    /* decompress to stdout */\n    ret = blast(inf, stdin, outf, stdout);\n    if (ret != 0) fprintf(stderr, \"blast error: %d\\n\", ret);\n\n    /* see if there are any leftover bytes */\n    n = 0;\n    while (getchar() != EOF) n++;\n    if (n) fprintf(stderr, \"blast warning: %d unused bytes of input\\n\", n);\n\n    /* return blast() error code */\n    return ret;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/blast/blast.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/blast/blast.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/blast/blast.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/blast/blast.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/blast/blast.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/blast/blast.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/blast/blast.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/blast/blast.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/blast/blast.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/blast/blast.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/blast/blast.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/blast/blast.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "87dad9146d72237de84bc038e71b07a0215c9d8c2721194c48d611ab1fdced5c": [
  "local int bits(struct state *s, int need)\n{\n    long val;           /* bit accumulator (can use up to 20 bits) */\n\n    /* load at least need bits into val */\n    val = s->bitbuf;\n    while (s->bitcnt < need) {\n        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */\n        val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */\n        s->bitcnt += 8;\n    }\n\n    /* drop need bits and update buffer, always zero to seven bits left */\n    s->bitbuf = (int)(val >> need);\n    s->bitcnt -= need;\n\n    /* return need bits, zeroing the bits above that */\n    return (int)(val & ((1L << need) - 1));\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "a13451c86e1dc91cfabad5c8fb8f7ec744d632f022e7fc8f1f0a24b18f4dae30": [
  "local int stored(struct state *s)\n{\n    unsigned len;       /* length of stored block */\n\n    /* discard leftover bits from current byte (assumes s->bitcnt < 8) */\n    s->bitbuf = 0;\n    s->bitcnt = 0;\n\n    /* get length and check against its one's complement */\n    if (s->incnt + 4 > s->inlen) return 2;      /* not enough input */\n    len = s->in[s->incnt++];\n    len |= s->in[s->incnt++] << 8;\n    if (s->in[s->incnt++] != (~len & 0xff) ||\n        s->in[s->incnt++] != ((~len >> 8) & 0xff))\n        return -2;                              /* didn't match complement! */\n\n    /* copy len bytes from in to out */\n    if (s->incnt + len > s->inlen) return 2;    /* not enough input */\n    if (s->out != NIL) {\n        if (s->outcnt + len > s->outlen)\n            return 1;                           /* not enough output space */\n        while (len--)\n            s->out[s->outcnt++] = s->in[s->incnt++];\n    }\n    else {                                      /* just scanning */\n        s->outcnt += len;\n        s->incnt += len;\n    }\n\n    /* done with a valid stored block */\n    return 0;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "90c2a3c43a2c4bc8472b4c68de444499ea6908bafc91125fd12bbdb4035b5d41": [
  "local int decode(struct state *s, struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n\n    code = first = index = 0;\n    for (len = 1; len <= MAXBITS; len++) {\n        code |= bits(s, 1);             /* get next bit */\n        count = h->count[len];\n        if (code < first + count)       /* if length len, return symbol */\n            return h->symbol[index + (code - first)];\n        index += count;                 /* else update for next length */\n        first += count;\n        first <<= 1;\n        code <<= 1;\n    }\n    return -9;                          /* ran out of codes */\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "2dcf8af4e5d1f0b68bfc5dc8c7872cc6e0396747d01ea6bcf5269c2ce36623fa": [
  "local int decode(struct state *s, struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n    int bitbuf;         /* bits from stream */\n    int left;           /* bits left in next or left to process */\n    short *next;        /* next number of codes */\n\n    bitbuf = s->bitbuf;\n    left = s->bitcnt;\n    code = first = index = 0;\n    len = 1;\n    next = h->count + 1;\n    while (1) {\n        while (left--) {\n            code |= bitbuf & 1;\n            bitbuf >>= 1;\n            count = *next++;\n            if (code < first + count) { /* if length len, return symbol */\n                s->bitbuf = bitbuf;\n                s->bitcnt = (s->bitcnt - len) & 7;\n                return h->symbol[index + (code - first)];\n            }\n            index += count;             /* else update for next length */\n            first += count;\n            first <<= 1;\n            code <<= 1;\n            len++;\n        }\n        left = (MAXBITS+1) - len;\n        if (left == 0) break;\n        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */\n        bitbuf = s->in[s->incnt++];\n        if (left > 8) left = 8;\n    }\n    return -9;                          /* ran out of codes */\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "387db049786fa88c9faf38ca797413503000d04d338ae785a80ab3f170763b6d": [
  "local int construct(struct huffman *h, short *length, int n)\n{\n    int symbol;         /* current symbol when stepping through length[] */\n    int len;            /* current length when stepping through h->count[] */\n    int left;           /* number of possible codes left of current length */\n    short offs[MAXBITS+1];      /* offsets in symbol table for each length */\n\n    /* count number of codes of each length */\n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n    if (h->count[0] == n)               /* no codes! */\n        return 0;                       /* complete, but decode() will fail */\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;                           /* one possible code of zero length */\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     /* one more bit, double codes left */\n        left -= h->count[len];          /* deduct count from possible codes */\n        if (left < 0) return left;      /* over-subscribed--return negative */\n    }                                   /* left > 0 means incomplete */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n\n    /*\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     */\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n\n    /* return zero for complete set, positive for incomplete set */\n    return left;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "00b73bfd5dfaac3157ad9be6e09964880fcce00fcb61799d2b1ba71d0feed1e3": [
  "local int codes(struct state *s,\n                struct huffman *lencode,\n                struct huffman *distcode)\n{\n    int symbol;         /* decoded symbol */\n    int len;            /* length for copy */\n    unsigned dist;      /* distance for copy */\n    static const short lens[29] = { /* Size base for length codes 257..285 */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n    static const short lext[29] = { /* Extra bits for length codes 257..285 */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n    static const short dists[30] = { /* Offset base for distance codes 0..29 */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\n    static const short dext[30] = { /* Extra bits for distance codes 0..29 */\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n    /* decode literals and length/distance pairs */\n    do {\n        symbol = decode(s, lencode);\n        if (symbol < 0) return symbol;  /* invalid symbol */\n        if (symbol < 256) {             /* literal: symbol is the byte */\n            /* write out the literal */\n            if (s->out != NIL) {\n                if (s->outcnt == s->outlen) return 1;\n                s->out[s->outcnt] = symbol;\n            }\n            s->outcnt++;\n        }\n        else if (symbol > 256) {        /* length */\n            /* get and compute length */\n            symbol -= 257;\n            if (symbol >= 29) return -9;        /* invalid fixed code */\n            len = lens[symbol] + bits(s, lext[symbol]);\n\n            /* get and check distance */\n            symbol = decode(s, distcode);\n            if (symbol < 0) return symbol;      /* invalid symbol */\n            dist = dists[symbol] + bits(s, dext[symbol]);\n            if (dist > s->outcnt)\n                return -10;     /* distance too far back */\n\n            /* copy length bytes from distance bytes back */\n            if (s->out != NIL) {\n                if (s->outcnt + len > s->outlen) return 1;\n                while (len--) {\n                    s->out[s->outcnt] = s->out[s->outcnt - dist];\n                    s->outcnt++;\n                }\n            }\n            else\n                s->outcnt += len;\n        }\n    } while (symbol != 256);            /* end of block symbol */\n\n    /* done with a valid fixed or dynamic block */\n    return 0;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "f3f544b84d9dc53d331ae9f2c3db4bdf24c430cdb849e68e97faee62b28d3a87": [
  "local int fixed(struct state *s)\n{\n    static int virgin = 1;\n    static short lencnt[MAXBITS+1], lensym[FIXLCODES];\n    static short distcnt[MAXBITS+1], distsym[MAXDCODES];\n    static struct huffman lencode = {lencnt, lensym};\n    static struct huffman distcode = {distcnt, distsym};\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        int symbol;\n        short lengths[FIXLCODES];\n\n        /* literal/length table */\n        for (symbol = 0; symbol < 144; symbol++)\n            lengths[symbol] = 8;\n        for (; symbol < 256; symbol++)\n            lengths[symbol] = 9;\n        for (; symbol < 280; symbol++)\n            lengths[symbol] = 7;\n        for (; symbol < FIXLCODES; symbol++)\n            lengths[symbol] = 8;\n        construct(&lencode, lengths, FIXLCODES);\n\n        /* distance table */\n        for (symbol = 0; symbol < MAXDCODES; symbol++)\n            lengths[symbol] = 5;\n        construct(&distcode, lengths, MAXDCODES);\n\n        /* do this just once */\n        virgin = 0;\n    }\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "cccf8cf89ef1a6c53517d7970f1ef9609e6d0dc3031ba03a47ca0ade37e67d18": [
  "local int dynamic(struct state *s)\n{\n    int nlen, ndist, ncode;             /* number of lengths in descriptor */\n    int index;                          /* index of lengths[] */\n    int err;                            /* construct() return value */\n    short lengths[MAXCODES];            /* descriptor code lengths */\n    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */\n    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */\n    struct huffman lencode = {lencnt, lensym};          /* length code */\n    struct huffman distcode = {distcnt, distsym};       /* distance code */\n    static const short order[19] =      /* permutation of code length codes */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* get number of lengths in each table, check lengths */\n    nlen = bits(s, 5) + 257;\n    ndist = bits(s, 5) + 1;\n    ncode = bits(s, 4) + 4;\n    if (nlen > MAXLCODES || ndist > MAXDCODES)\n        return -3;                      /* bad counts */\n\n    /* read code length code lengths (really), missing lengths are zero */\n    for (index = 0; index < ncode; index++)\n        lengths[order[index]] = bits(s, 3);\n    for (; index < 19; index++)\n        lengths[order[index]] = 0;\n\n    /* build huffman table for code lengths codes (use lencode temporarily) */\n    err = construct(&lencode, lengths, 19);\n    if (err != 0) return -4;            /* require complete code set here */\n\n    /* read length/literal and distance code length tables */\n    index = 0;\n    while (index < nlen + ndist) {\n        int symbol;             /* decoded value */\n        int len;                /* last length to repeat */\n\n        symbol = decode(s, &lencode);\n        if (symbol < 16)                /* length in 0..15 */\n            lengths[index++] = symbol;\n        else {                          /* repeat instruction */\n            len = 0;                    /* assume repeating zeros */\n            if (symbol == 16) {         /* repeat last length 3..6 times */\n                if (index == 0) return -5;      /* no last length! */\n                len = lengths[index - 1];       /* last length */\n                symbol = 3 + bits(s, 2);\n            }\n            else if (symbol == 17)      /* repeat zero 3..10 times */\n                symbol = 3 + bits(s, 3);\n            else                        /* == 18, repeat zero 11..138 times */\n                symbol = 11 + bits(s, 7);\n            if (index + symbol > nlen + ndist)\n                return -6;              /* too many lengths! */\n            while (symbol--)            /* repeat last or zero symbol times */\n                lengths[index++] = len;\n        }\n    }\n\n    /* build huffman table for literal/length codes */\n    err = construct(&lencode, lengths, nlen);\n    if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))\n        return -7;      /* only allow incomplete codes if just one code */\n\n    /* build huffman table for distance codes */\n    err = construct(&distcode, lengths + nlen, ndist);\n    if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))\n        return -8;      /* only allow incomplete codes if just one code */\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "be50a6042532f565920ead074d02ebc07cdecd8ea046d00fd15fe3a4c4323602": [
  "int puff(unsigned char *dest,           /* pointer to destination pointer */\n         unsigned long *destlen,        /* amount of output space */\n         unsigned char *source,         /* pointer to source data pointer */\n         unsigned long *sourcelen)      /* amount of input available */\n{\n    struct state s;             /* input/output state */\n    int last, type;             /* block information */\n    int err;                    /* return value */\n\n    /* initialize output state */\n    s.out = dest;\n    s.outlen = *destlen;                /* ignored if dest is NIL */\n    s.outcnt = 0;\n\n    /* initialize input state */\n    s.in = source;\n    s.inlen = *sourcelen;\n    s.incnt = 0;\n    s.bitbuf = 0;\n    s.bitcnt = 0;\n\n    /* return if bits() or decode() tries to read past available input */\n    if (setjmp(s.env) != 0)             /* if came back here via longjmp() */\n        err = 2;                        /* then skip do-loop, return error */\n    else {\n        /* process blocks until last block or error */\n        do {\n            last = bits(&s, 1);         /* one if last block */\n            type = bits(&s, 2);         /* block type 0..3 */\n            err = type == 0 ? stored(&s) :\n                  (type == 1 ? fixed(&s) :\n                   (type == 2 ? dynamic(&s) :\n                    -1));               /* type == 3, invalid */\n            if (err != 0) break;        /* return with error */\n        } while (!last);\n    }\n\n    /* update the lengths and return */\n    if (err <= 0) {\n        *destlen = s.outcnt;\n        *sourcelen = s.incnt;\n    }\n    return err;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "c95412a8d6041e9f8ac7db8b942a962312d417e1369a9d3fdb1482d87175d31c": [
  "char *yank(char *name, unsigned long *len)\n{\n    unsigned long size;\n    unsigned char *buf;\n    FILE *in;\n    struct stat s;\n\n    *len = 0;\n    if (stat(name, &s)) return NULL;\n    if ((s.st_mode & S_IFMT) != S_IFREG) return NULL;\n    size = (unsigned long)(s.st_size);\n    if (size == 0 || (off_t)size != s.st_size) return NULL;\n    in = fopen(name, \"r\");\n    if (in == NULL) return NULL;\n    buf = malloc(size);\n    if (buf != NULL && fread(buf, 1, size, in) != size) {\n        free(buf);\n        buf = NULL;\n    }\n    fclose(in);\n    *len = size;    \n    return buf;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "1a10046a023c6427d419016dbe144984ecf0d599e3246e69e45c7e6302fac1a1": [
  "int main(int argc, char **argv)\n{\n    int ret;\n    unsigned char *source;\n    unsigned long len, sourcelen, destlen;\n\n    if (argc < 2) return 2;\n    source = yank(argv[1], &len);\n    if (source == NULL) return 2;\n    sourcelen = len;\n    ret = puff(NIL, &destlen, source, &sourcelen);\n    if (ret)\n        printf(\"puff() failed with return code %d\\n\", ret);\n    else {\n        printf(\"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n        if (sourcelen < len) printf(\"%lu compressed bytes unused\\n\",\n                                    len - sourcelen);\n    }\n    free(source);\n    return ret;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/puff/puff.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/puff/puff.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/puff/puff.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/puff/puff.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "65154e1bacd935c0fc693e4d8dc63cbfd482b6d648a79e5cd7109858e72b5a5f": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n{\n    char buf[Z_PRINTF_BUFSIZE];\n    va_list va;\n    int len;\n\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(buf, format, va);\n    va_end(va);\n    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */\n    if (len <= 0) return 0;\n#  else\n    len = vsprintf(buf, format, va);\n    va_end(va);\n    if (len <= 0 || len >= sizeof(buf))\n        return 0;\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(buf, sizeof(buf), format, va);\n    va_end(va);\n    len = strlen(buf);\n    if (len <= 0)\n        return 0;\n#  else\n    len = vsnprintf(buf, sizeof(buf), format, va);\n    va_end(va);\n    if (len <= 0 || len >= sizeof(buf))\n        return 0;\n#  endif\n#endif\n\n    return gzwrite(file, buf, (unsigned)len);\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "gzio.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "gzio.c"
   ]
  }
 ],
 "ef8ef7a17647163425520818cdc4caa622de96085589a0f9d286c312e347c8a9": [
  "local void make_crc_table()\n{\n    unsigned long c;\n    int n, k;\n    unsigned long poly;            /* polynomial exclusive-or pattern */\n    /* terms of polynomial defining this crc (except x^32): */\n    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n    /* make exclusive-or pattern from polynomial (0xedb88320L) */\n    poly = 0UL;\n    for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n        poly |= 1UL << (31 - p[n]);\n\n    /* generate a crc for every 8-bit value */\n    for (n = 0; n < 256; n++) {\n        c = (unsigned long)n;\n        for (k = 0; k < 8; k++)\n            c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n        crc_table[0][n] = c;\n    }\n\n#ifdef BYFOUR\n    /* generate crc for each value followed by one, two, and three zeros, and\n       then the byte reversal of those as well as the first table */\n    for (n = 0; n < 256; n++) {\n        c = crc_table[0][n];\n        crc_table[4][n] = REV(c);\n        for (k = 1; k < 4; k++) {\n            c = crc_table[0][c & 0xff] ^ (c >> 8);\n            crc_table[k][n] = c;\n            crc_table[k + 4][n] = REV(c);\n        }\n    }\n#endif /* BYFOUR */\n\n  crc_table_empty = 0;\n\n#ifdef MAKECRCH\n    /* write out CRC tables to crc32.h */\n    {\n        FILE *out;\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n        fprintf(out, \"local const unsigned long FAR \");\n        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n        write_table(out, crc_table[0]);\n#  ifdef BYFOUR\n        fprintf(out, \"#ifdef BYFOUR\\n\");\n        for (k = 1; k < 8; k++) {\n            fprintf(out, \"  },\\n  {\\n\");\n            write_table(out, crc_table[k]);\n        }\n        fprintf(out, \"#endif\\n\");\n#  endif /* BYFOUR */\n        fprintf(out, \"  }\\n};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "crc32.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "crc32.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "crc32.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "crc32.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "crc32.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "crc32.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "crc32.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "crc32.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "crc32.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "crc32.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "crc32.c"
   ]
  }
 ],
 "03c3023e870a543ec3bd67b8466d0f456bd5c28f196231c7a1bb6db45469c9a3": [
  "const unsigned long FAR * ZEXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n  if (crc_table_empty) make_crc_table();\n#endif /* DYNAMIC_CRC_TABLE */\n  return (const unsigned long FAR *)crc_table;\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "crc32.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "crc32.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "crc32.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "crc32.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "crc32.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "crc32.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "crc32.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "crc32.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "crc32.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "crc32.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "crc32.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "crc32.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "crc32.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "crc32.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "crc32.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "crc32.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "crc32.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "crc32.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "crc32.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "crc32.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "crc32.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "crc32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "crc32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "crc32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "crc32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "crc32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "crc32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "crc32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "crc32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "crc32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "crc32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "crc32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "crc32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "crc32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "crc32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "crc32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "crc32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "crc32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "crc32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "crc32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "crc32.c"
   ]
  }
 ],
 "6f7ae0306db2b0e2c6f3864be5915ab75f6fbfdc31d351beac8dccb869516e7f": [
  "void makefixed()\n{\n    unsigned low, size;\n    struct inflate_state state;\n\n    fixedtables(&state);\n    puts(\"    /* inffixed.h -- table for decoding fixed codes\");\n    puts(\"     * Generated automatically by makefixed().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 7) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.lencode[low].op, state.lencode[low].bits,\n               state.lencode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.distcode[low].op, state.distcode[low].bits,\n               state.distcode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}",
  {
   "v1.2.0": [
    "2011-09-09 23:21:47",
    "inflate.c"
   ],
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "inflate.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "inflate.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "inflate.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "inflate.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "inflate.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "inflate.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "inflate.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "inflate.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "inflate.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "inflate.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "inflate.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "inflate.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "inflate.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "inflate.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "inflate.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "inflate.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "inflate.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "inflate.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "inflate.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "inflate.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "inflate.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "inflate.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "inflate.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "inflate.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "inflate.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "inflate.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "inflate.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "inflate.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "inflate.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "inflate.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "inflate.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "inflate.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "inflate.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "inflate.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "inflate.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "inflate.c"
   ]
  }
 ],
 "6552c243113fcf719a992f75b436a47c4d03c221b6e2505d5bcc40bae4943cb3": [
  "void do_banner()\n{\n    printf(\"MiniZip 0.15, demo of zLib + Zip package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
  {
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "467c738b1702ab836dfe091a0562ef7781e2bb954d921fa1cada8fa97946ebcb": [
  "int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)\n{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = fopen(filenameinzip,\"rb\");\n   unsigned long size_read = 0;\n   unsigned long total_read = 0;\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = (int)fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32(calculate_crc,buf,size_read);\n            total_read += size_read;\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %x\\n\",filenameinzip,calculate_crc);\n    return err;\n}",
  {
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "409faa2e24bb44a88db81c9c5c852c17e18e4633af13c0d01901d7816605227d": [
  "void do_banner()\n{\n    printf(\"MiniUnz 0.15, demo of zLib + Unz package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
  {
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "8845d0058f018e57544236a3949bd60a94e68891d1575b86aa16818a4a2eb7ef": [
  "int ReadFileMemory(const char* filename,long* plFileSize,void** pFilePtr)\r\n{\r\n    FILE* stream;\r\n    void* ptr;\r\n    int retVal=1;\r\n    stream=fopen(filename, \"rb\");\r\n    if (stream==NULL)\r\n        return 0;\r\n\r\n    fseek(stream,0,SEEK_END);\r\n\r\n    *plFileSize=ftell(stream);\r\n    fseek(stream,0,SEEK_SET);\r\n    ptr=malloc((*plFileSize)+1);\r\n    if (ptr==NULL)\r\n        retVal=0;\r\n    else\r\n    {\r\n        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))\r\n            retVal=0;\r\n    }\r\n    fclose(stream);\r\n    *pFilePtr=ptr;\r\n    return retVal;\r\n}",
  {
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "a386fc4baf96b6e1c3973f3ae3a363bf3d4556e05641ed39d17a757f4b433da6": [
  "int main(int argc, char *argv[])\r\n{\r\n    int BlockSizeCompress=0x8000;\r\n    int BlockSizeUncompress=0x8000;\r\n    int cprLevel=Z_DEFAULT_COMPRESSION ;\r\n    long lFileSize;\r\n    unsigned char* FilePtr;\r\n    long lBufferSizeCpr;\r\n    long lBufferSizeUncpr;\r\n    long lCompressedSize=0;\r\n    unsigned char* CprPtr;\r\n    unsigned char* UncprPtr;\r\n    long lSizeCpr,lSizeUncpr;\r\n    DWORD dwGetTick;\r\n\r\n    if (argc<=1)\r\n    {\r\n        printf(\"run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\\n\");\r\n        return 0;\r\n    }\r\n\r\n    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)\r\n    {\r\n        printf(\"error reading %s\\n\",argv[1]);\r\n        return 1;\r\n    }\r\n    else printf(\"file %s read, %u bytes\\n\",argv[1],lFileSize);\r\n\r\n    if (argc>=3)\r\n        BlockSizeCompress=atol(argv[2]);\r\n\r\n    if (argc>=4)\r\n        BlockSizeUncompress=atol(argv[3]);\r\n\r\n    if (argc>=5)\r\n        cprLevel=(int)atol(argv[4]);\r\n\r\n    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;\r\n    lBufferSizeUncpr = lBufferSizeCpr;\r\n\r\n    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);\r\n    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);\r\n\r\n    dwGetTick=GetTickCount();\r\n    {\r\n        z_stream zcpr;\r\n        int ret=Z_OK;\r\n        long lOrigToDo = lFileSize;\r\n        long lOrigDone = 0;\r\n        int step=0;\r\n        memset(&zcpr,0,sizeof(z_stream));\r\n        deflateInit(&zcpr,cprLevel);\r\n\r\n        zcpr.next_in = FilePtr;\r\n        zcpr.next_out = CprPtr;\r\n\r\n\r\n        do\r\n        {\r\n            long all_read_before = zcpr.total_in;\r\n            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);\r\n            zcpr.avail_out = BlockSizeCompress;\r\n            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);\r\n            lOrigDone += (zcpr.total_in-all_read_before);\r\n            lOrigToDo -= (zcpr.total_in-all_read_before);\r\n            step++;\r\n        } while (ret==Z_OK);\r\n\r\n        lSizeCpr=zcpr.total_out;\r\n        deflateEnd(&zcpr);\r\n        dwGetTick=GetTickCount()-dwGetTick;\r\n        printf(\"total compress size = %u, in %u step\\n\",lSizeCpr,step);\r\n        printf(\"time = %u msec = %f sec\\n\\n\",dwGetTick,dwGetTick/(double)1000.);\r\n    }\r\n\r\n    dwGetTick=GetTickCount();\r\n    {\r\n        z_stream zcpr;\r\n        int ret=Z_OK;\r\n        long lOrigToDo = lSizeCpr;\r\n        long lOrigDone = 0;\r\n        int step=0;\r\n        memset(&zcpr,0,sizeof(z_stream));\r\n        inflateInit(&zcpr);\r\n\r\n        zcpr.next_in = CprPtr;\r\n        zcpr.next_out = UncprPtr;\r\n\r\n\r\n        do\r\n        {\r\n            long all_read_before = zcpr.total_in;\r\n            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);\r\n            zcpr.avail_out = BlockSizeUncompress;\r\n            ret=inflate(&zcpr,Z_SYNC_FLUSH);\r\n            lOrigDone += (zcpr.total_in-all_read_before);\r\n            lOrigToDo -= (zcpr.total_in-all_read_before);\r\n            step++;\r\n        } while (ret==Z_OK);\r\n\r\n        lSizeUncpr=zcpr.total_out;\r\n        inflateEnd(&zcpr);\r\n        dwGetTick=GetTickCount()-dwGetTick;\r\n        printf(\"total uncompress size = %u, in %u step\\n\",lSizeUncpr,step);\r\n        printf(\"time = %u msec = %f sec\\n\\n\",dwGetTick,dwGetTick/(double)1000.);\r\n    }\r\n\r\n    if (lSizeUncpr==lFileSize)\r\n    {\r\n        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)\r\n            printf(\"compare ok\\n\");\r\n\r\n    }\r\n\r\n    return 0;\r\n\r\n}",
  {
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "cf7f6d7f8c307b88e00d0ff4f1a470baef2630e46d375e75c55d929df41f2520": [
  "uInt longest_match(\r\n    deflate_state *s,\r\n    IPos cur_match)                             /* current match */\r\n{\r\n    static uInt iIsPPro=2;\r\n\r\n    if ((s->w_mask == 0x7fff) && (iIsPPro==0))\r\n        return longest_match_7fff(s,cur_match);\r\n\r\n    if (iIsPPro==1)\r\n        return longest_match_686(s,cur_match);\r\n\r\n    if (iIsPPro==2)\r\n        iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\r\n\r\n    return longest_match_c(s,cur_match);\r\n}",
  {
   "v1.2.0.1": [
    "2011-09-09 23:21:57",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/vstudio/vc70_32/gvmat32c.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/masmx86/gvmat32c.c"
   ]
  }
 ],
 "2957806d009868d6704437f0c69f9108067c4ba1f19475e0b19aa2a3d711cf1e": [
  "void do_banner()\r\n{\r\n    printf(\"MiniZip 0.22, demo of zLib + Zip package written by Gilles Vollant\\n\");\r\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\r\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "b5746cb23abd81eb0fcc3bbd8dedb1d6af4846f895efbfdafff585510c3b5566": [
  "void do_help()\r\n{\r\n    printf(\"Usage : minizip [-o] [-a] [-0 to -9] [-p password] file.zip [files_to_add]\\n\\n\" \\\r\n           \"  -o  Overwrite existing file.zip\\n\" \\\r\n           \"  -a  Append to existing file.zip\\n\" \\\r\n           \"  -0  Store only\\n\" \\\r\n           \"  -1  Compress faster\\n\" \\\r\n           \"  -9  Compress better\\n\\n\");\r\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "750fc7582761fa6e8a4bb4e27aa03b94d8aead305cf3030d60f5e8810265c59d": [
  "void do_banner()\r\n{\r\n    printf(\"MiniUnz 0.22, demo of zLib + Unz package written by Gilles Vollant\\n\");\r\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\r\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "972ca174fd52c9f937d1f8330e4aa4b74d24c2734b7e9d9e08a11e4787246d7d": [
  "void do_help()\r\n{\r\n    printf(\"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.]\\n\\n\" \\\r\n           \"  -e  Extract without pathname (junk paths)\\n\" \\\r\n           \"  -x  Extract with pathname\\n\" \\\r\n           \"  -v  list files\\n\" \\\r\n           \"  -l  list files\\n\" \\\r\n           \"  -o  overwrite files without prompting\\n\" \\\r\n           \"  -p  extract crypted file using password\\n\\n\");\r\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "3b595b2a3eaefa0ea06d18851769ed109c097edeec2fbaec2d1737228d01d7e7": [
  "gzfilebuf::gzfilebuf() \n: file(NULL), io_mode(std::ios_base::openmode(0)), own_fd(false), \n  buffer(NULL), buffer_size(BIGBUFSIZE), own_buffer(true)\n{\n  // No buffers to start with\n  this->disable_buffer();\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "215cda402ca0714577b7b7d526eb6ecb65ff92d3a1855b6f77c85adac3429a7c": [
  "gzfilebuf::~gzfilebuf() \n{\n  // Sync output buffer and close only if responsible for file\n  // (i.e. attached streams should be left open at this stage)\n  this->sync();\n  if (own_fd) \n    this->close();\n  // Make sure internal buffer is deallocated\n  this->disable_buffer();\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "bb0b1e7ae401355576e7a5786c30018f183d2d83d5a217159aa91daea6245607": [
  "int\ngzfilebuf::setcompression(int comp_level,\n\t\t\t  int comp_strategy)\n{\n  return gzsetparams(file, comp_level, comp_strategy);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "657e7e5b5cc27d2890dbd73549c6d76e5eeb2d55e7fd1db12e2b1b80eb91df01": [
  "gzfilebuf* \ngzfilebuf::open(const char *name, \n\t\tstd::ios_base::openmode mode)\n{\n  // Fail if file already open\n  if (this->is_open()) \n    return NULL;\n  // Don't support simultaneous read/write access (yet)\n  if ((mode & std::ios_base::in) && (mode & std::ios_base::out)) \n    return NULL;\n  \n  // Build mode string for gzopen and check it [27.8.1.3.2]\n  char char_mode[6] = \"\\0\\0\\0\\0\\0\";\n  if (!this->open_mode(mode, char_mode))\n    return NULL;\n  \n  // Attempt to open file\n  if ((file = gzopen(name, char_mode)) == NULL) \n    return NULL;\n\n  // On success, allocate internal buffer and set flags\n  this->enable_buffer();\n  io_mode = mode;\n  own_fd = true;\n  return this;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "c6f952d11a1fbbf239d35e0fb97c3f5a05663d61e75b6f249651e87ff51106b9": [
  "gzfilebuf*\ngzfilebuf::attach(int fd,\n\t\t  std::ios_base::openmode mode) \n{\n  // Fail if file already open\n  if (this->is_open()) \n    return NULL;\n  // Don't support simultaneous read/write access (yet)\n  if ((mode & std::ios_base::in) && (mode & std::ios_base::out)) \n    return NULL;\n  \n  // Build mode string for gzdopen and check it [27.8.1.3.2]\n  char char_mode[6] = \"\\0\\0\\0\\0\\0\";\n  if (!this->open_mode(mode, char_mode))\n    return NULL;\n  \n  // Attempt to attach to file\n  if ((file = gzdopen(fd, char_mode)) == NULL)\n    return NULL;\n  \n  // On success, allocate internal buffer and set flags\n  this->enable_buffer();\n  io_mode = mode;\n  own_fd = false;\n  return this;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "b042c5f80187a1f0139a70886630846116b67e2810a664568c89831e1afd2d34": [
  "gzfilebuf*\ngzfilebuf::close() \n{\n  // Fail immediately if no file is open\n  if (!this->is_open())\n    return NULL;\n  // Assume success\n  gzfilebuf* retval = this;\n  // Attempt to sync and close gzipped file\n  if (this->sync() == -1)\n    retval = NULL;\n  if (gzclose(file) < 0)\n    retval = NULL;\n  // File is now gone anyway (postcondition [27.8.1.3.8])\n  file = NULL;\n  own_fd = false;\n  // Destroy internal buffer if it exists\n  this->disable_buffer();\n  return retval;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "6c396723f3c523bf1697eb936af706683f7afb4723e3ebfa5fc7efe312c4ed99": [
  "bool \ngzfilebuf::open_mode(std::ios_base::openmode mode, \n\t\t     char* c_mode) const\n{\n  bool testb = mode & std::ios_base::binary;\n  bool testi = mode & std::ios_base::in;\n  bool testo = mode & std::ios_base::out;\n  bool testt = mode & std::ios_base::trunc;\n  bool testa = mode & std::ios_base::app;\n      \n  // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)\n  // Original zfstream hardcoded the compression level to maximum here...\n  // Double the time for less than 1% size improvement seems\n  // excessive though - keeping it at the default level\n  // To change back, just append \"9\" to the next three mode strings\n  if (!testi && testo && !testt && !testa)\n    strcpy(c_mode, \"w\");\n  if (!testi && testo && !testt && testa)\n    strcpy(c_mode, \"a\");\n  if (!testi && testo && testt && !testa)\n    strcpy(c_mode, \"w\");\n  if (testi && !testo && !testt && !testa)\n    strcpy(c_mode, \"r\");\n  // No read/write mode yet\n//  if (testi && testo && !testt && !testa)\n//    strcpy(c_mode, \"r+\");\n//  if (testi && testo && testt && !testa)\n//    strcpy(c_mode, \"w+\");\n\n  // Mode string should be empty for invalid combination of flags    \n  if (strlen(c_mode) == 0)\n    return false;\n  if (testb)\n    strcat(c_mode, \"b\");\n  return true;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "a57075c9bdc4aed01feaeedffdfbfff4a509262fe42776c206fb26d6d50ec98a": [
  "std::streamsize \ngzfilebuf::showmanyc()\n{\n  // Calls to underflow will fail if file not opened for reading\n  if (!this->is_open() || !(io_mode & std::ios_base::in))\n    return -1;\n  // Make sure get area is in use\n  if (this->gptr() && (this->gptr() < this->egptr()))\n    return std::streamsize(this->egptr() - this->gptr());\n  else\n    return 0;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "07deeef7fb534046d8ddee228d1e909c0264d473036c1946aacebc96355c2300": [
  "gzfilebuf::int_type\ngzfilebuf::underflow() \n{\n  // If something is left in the get area by chance, return it\n  // (this shouldn't normally happen, as underflow is only supposed \n  // to be called when gptr >= egptr, but it serves as error check)\n  if (this->gptr() && (this->gptr() < this->egptr()))\n    return traits_type::to_int_type(*(this->gptr()));\n\n  // If the file hasn't been opened for reading, produce error\n  if (!this->is_open() || !(io_mode & std::ios_base::in))\n    return traits_type::eof();\n\n  // Attempt to fill internal buffer from gzipped file\n  // (buffer must be guaranteed to exist...)\n  int bytes_read = gzread(file, buffer, buffer_size);\n  // Indicates error or EOF\n  if (bytes_read <= 0)\n  {\n    // Reset get area\n    this->setg(buffer, buffer, buffer);\n    return traits_type::eof();\n  }\n  // Make all bytes read from file available as get area\n  this->setg(buffer, buffer, buffer + bytes_read);\n  \n  // Return next character in get area\n  return traits_type::to_int_type(*(this->gptr()));\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "b0d031620d809c03b8380ac00d7e47e3c26bcb531cfc81ca1491711e74df2b4f": [
  "gzfilebuf::int_type\ngzfilebuf::overflow(int_type c) \n{\n  // Determine whether put area is in use\n  if (this->pbase())\n  {\n    // Double-check pointer range\n    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())\n      return traits_type::eof();\n    // Add extra character to buffer if not EOF\n    if (!traits_type::eq_int_type(c, traits_type::eof()))\n    {\n      *(this->pptr()) = traits_type::to_char_type(c);\n      this->pbump(1);\n    }\n    // Number of characters to write to file\n    int bytes_to_write = this->pptr() - this->pbase();\n    // Overflow doesn't fail if nothing is to be written\n    if (bytes_to_write > 0)\n    {\n      // If the file hasn't been opened for writing, produce error\n      if (!this->is_open() || !(io_mode & std::ios_base::out))\n\treturn traits_type::eof();\n      // If gzipped file won't accept all bytes written to it, fail\n      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)\n\treturn traits_type::eof();\n      // Reset next pointer to point to pbase on success\n      this->pbump(-bytes_to_write);\n    }\n  }\n  // Write extra character to file if not EOF\n  else if (!traits_type::eq_int_type(c, traits_type::eof()))\n  {\n    // If the file hasn't been opened for writing, produce error\n    if (!this->is_open() || !(io_mode & std::ios_base::out))\n      return traits_type::eof();\n    // Impromptu char buffer (allows \"unbuffered\" output)\n    char_type last_char = traits_type::to_char_type(c);\n    // If gzipped file won't accept this character, fail\n    if (gzwrite(file, &last_char, 1) != 1)\n      return traits_type::eof();      \n  }\n\n  // If you got here, you have succeeded (even if c was EOF)\n  // The return value should therefore be non-EOF\n  if (traits_type::eq_int_type(c, traits_type::eof()))\n    return traits_type::not_eof(c);\n  else\n    return c;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "a48c6046177e78f75d5e64081e4793a223e59c7ca9b6273f154ed64f49f128df": [
  "std::streambuf* \ngzfilebuf::setbuf(char_type* p,\n\t\t  std::streamsize n)\n{\n  // First make sure stuff is sync'ed, for safety\n  if (this->sync() == -1)\n    return NULL;\n  // If buffering is turned off on purpose via setbuf(0,0), still allocate one...\n  // \"Unbuffered\" only really refers to put [27.8.1.4.10], while get needs at\n  // least a buffer of size 1 (very inefficient though, therefore make it bigger?)\n  // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)\n  if (!p || !n)\n  {\n    // Replace existing buffer (if any) with small internal buffer\n    this->disable_buffer();\n    buffer = NULL;\n    buffer_size = 0;\n    own_buffer = true;\n    this->enable_buffer();\n  }\n  else\n  {\n    // Replace existing buffer (if any) with external buffer\n    this->disable_buffer();\n    buffer = p;\n    buffer_size = n;\n    own_buffer = false;\n    this->enable_buffer();\n  }\n  return this;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "fbda00bdbc28b84498e6bf93ba029af8e9606bbabcf25d79e7d1d21db1a556bd": [
  "int \ngzfilebuf::sync() \n{\n  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "7a22c0885eb007f2712168ce023a585f6bd12cc78b6e7543d7b8628437658552": [
  "void \ngzfilebuf::enable_buffer() \n{\n  // If internal buffer required, allocate one\n  if (own_buffer && !buffer) \n  {\n    // Check for buffered vs. \"unbuffered\"\n    if (buffer_size > 0)\n    {\n      // Allocate internal buffer\n      buffer = new char_type[buffer_size];\n      // Get area starts empty and will be expanded by underflow as need arises\n      this->setg(buffer, buffer, buffer);\n      // Setup entire internal buffer as put area.\n      // The one-past-end pointer actually points to the last element of the buffer,\n      // so that overflow(c) can safely add the extra character c to the sequence.\n      // These pointers remain in place for the duration of the buffer\n      this->setp(buffer, buffer + buffer_size - 1);\n    }\n    else\n    {\n      // Even in \"unbuffered\" case, (small?) get buffer is still required\n      buffer_size = SMALLBUFSIZE;\n      buffer = new char_type[buffer_size];\n      this->setg(buffer, buffer, buffer);\n      // \"Unbuffered\" means no put buffer\n      this->setp(0, 0);\n    }\n  }\n  else\n  {\n    // If buffer already allocated, reset buffer pointers just to make sure no \n    // stale chars are lying around\n    this->setg(buffer, buffer, buffer);\n    this->setp(buffer, buffer + buffer_size - 1);\n  }  \n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "b0e8ebefaec0e9e6c2ccccd3a710e309dcd5e5887d10024077c0c59a16efab5d": [
  "void \ngzfilebuf::disable_buffer() \n{\n  // If internal buffer exists, deallocate it\n  if (own_buffer && buffer)\n  {\n    // Preserve unbuffered status by zeroing size\n    if (!this->pbase())\n      buffer_size = 0;\n    delete[] buffer;\n    buffer = NULL;\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n  }\n  else\n  {\n    // Reset buffer pointers to initial state if external buffer exists\n    this->setg(buffer, buffer, buffer);\n    if (buffer)\n      this->setp(buffer, buffer + buffer_size - 1);\n    else\n      this->setp(0, 0);\n  }\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "4f727406025a212282d62309ad82b0358ffe57d6a5cc66e70e13005740def3c6": [
  "gzifstream::gzifstream() \n: std::istream(NULL), sb()\n{ this->init(&sb); }",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "a100e85c75166a50a8d2eda5219364d2ab86dcc0c89e9208a951e0e20dfd350f": [
  "gzifstream::gzifstream(const char* name,\n\t\t       std::ios_base::openmode mode)\n: std::istream(NULL), sb()\n{\n  this->init(&sb);\n  this->open(name, mode);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "e3327049a6545c3ad8f7cf9eda852e3abf272994f96fe7fa8316b914a72284ce": [
  "gzifstream::gzifstream(int fd,\n\t\t       std::ios_base::openmode mode)\n: std::istream(NULL), sb()\n{\n  this->init(&sb);\n  this->attach(fd, mode);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "011ad93092a272309625eebf0c430742d19e9323a74485a1011fbf522552deaa": [
  "void \ngzifstream::open(const char* name, \n\t\t std::ios_base::openmode mode)\n{\n  if (!sb.open(name, mode | std::ios_base::in))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "3e51c0b6fce4192a2fe9de9cdf179425b92dacc5ba424839401ad53584f9b573": [
  "void \ngzifstream::attach(int fd, \n\t\t   std::ios_base::openmode mode)\n{\n  if (!sb.attach(fd, mode | std::ios_base::in))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "248b9037db47b324c24a186ae09754ec48eaf3d23fe4b956385699aeb2ee3069": [
  "void \ngzifstream::close()\n{\n  if (!sb.close())\n    this->setstate(std::ios_base::failbit);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "e5361ca297abfda3ef49e08300604d79b7a58fc423a1330ddc3cafc7aa3b9dcf": [
  "gzofstream::gzofstream() \n: std::ostream(NULL), sb()\n{ this->init(&sb); }",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "789cf39b3d9dccfd5b2ed8c674a2cc0a30c180439964cc26843e3feb711a14f8": [
  "gzofstream::gzofstream(const char* name,\n\t\t       std::ios_base::openmode mode)\n: std::ostream(NULL), sb()\n{\n  this->init(&sb);\n  this->open(name, mode);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "ddf82fe08d398950b8d434948bdda71135a48f989a970a0602a0757868d0be51": [
  "gzofstream::gzofstream(int fd,\n\t\t       std::ios_base::openmode mode)\n: std::ostream(NULL), sb()\n{\n  this->init(&sb);\n  this->attach(fd, mode);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "60896d36e9e433f0024c9c8200b1f40904db5fd3ad32c98f1d26a276ad1e201a": [
  "void \ngzofstream::open(const char* name, \n\t\t std::ios_base::openmode mode)\n{\n  if (!sb.open(name, mode | std::ios_base::out))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "8eb3a315393efc0d8a7af58983c0cde4e6e0f5f46bf174ba18b9ac2b794477c0": [
  "void \ngzofstream::attach(int fd, \n\t\t   std::ios_base::openmode mode)\n{\n  if (!sb.attach(fd, mode | std::ios_base::out))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "e2253362a48e304556a277e753acf24d36cc026eccf0e956d72a1fb718231ba6": [
  "void \ngzofstream::close()\n{\n  if (!sb.close())\n    this->setstate(std::ios_base::failbit);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/zfstream.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/zfstream.cc"
   ]
  }
 ],
 "571988eb7f49185bb7b707cb2dd53af69488e9106e074d5450428377be9297b7": [
  "int main() {\n\n  gzofstream outf;\n  gzifstream inf;\n  char buf[80];\n  \n  outf.open(\"test1.txt.gz\");\n  outf << \"The quick brown fox sidestepped the lazy canine\\n\" \n       << 1.3 << \"\\nPlan \" << 9 << std::endl;\n  outf.close();\n  std::cout << \"Wrote the following message to 'test1.txt.gz' (check with zcat or zless):\\n\"\n            << \"The quick brown fox sidestepped the lazy canine\\n\"\n            << 1.3 << \"\\nPlan \" << 9 << std::endl;\n  \n  std::cout << \"\\nReading 'test1.txt.gz' (buffered) produces:\\n\";\n  inf.open(\"test1.txt.gz\");\n  while (inf.getline(buf,80,'\\n')) {\n    std::cout << buf << \"\\t(\" << inf.rdbuf()->in_avail() << \" chars left in buffer)\\n\";\n  }\n  inf.close();\n\n  outf.rdbuf()->pubsetbuf(0,0);\n  outf.open(\"test2.txt.gz\");\n  outf << setcompression(Z_NO_COMPRESSION)\n       << \"The quick brown fox sidestepped the lazy canine\\n\"\n       << 1.3 << \"\\nPlan \" << 9 << std::endl;\n  outf.close();\n  std::cout << \"\\nWrote the same message to 'test2.txt.gz' in uncompressed form\";\n\n  std::cout << \"\\nReading 'test2.txt.gz' (unbuffered) produces:\\n\";\n  inf.rdbuf()->pubsetbuf(0,0);\n  inf.open(\"test2.txt.gz\");\n  while (inf.getline(buf,80,'\\n')) {\n    std::cout << buf << \"\\t(\" << inf.rdbuf()->in_avail() << \" chars left in buffer)\\n\";\n  }\n  inf.close();\n\n  return 0;\n\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream3/test.cc"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream3/test.cc"
   ]
  }
 ],
 "38063714179d210474fe3c018042e7d9f8daf87efd22183b6320395b7e74b0da": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch (sizeof(uInt)) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch (sizeof(uLong)) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch (sizeof(voidpf)) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch (sizeof(z_off_t)) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_DEFLATE\n    flags += 1 << 16;\n#endif\n#ifdef NO_GUNZIP\n    flags += 1 << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1 << 20;\n#endif\n#ifdef FASTEST\n    flags += 1 << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1 << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1 << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1 << 26;\n#    endif\n#  endif\n#else\n        flags += 1 << 24;\n#  ifdef NO_snprintf\n        flags += 1 << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1 << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1 << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "zutil.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "zutil.c"
   ]
  }
 ],
 "4cc7e32c97a11a98796a218d69d1382ed7ae7140e747ff5de4ddf82534a1616a": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n{\n    char buf[Z_PRINTF_BUFSIZE];\n    va_list va;\n    int len;\n\n    buf[sizeof(buf) - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(buf, format, va);\n    va_end(va);\n    for (len = 0; len < sizeof(buf); len++)\n        if (buf[len] == 0) break;\n#  else\n    len = vsprintf(buf, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(buf, sizeof(buf), format, va);\n    va_end(va);\n    len = strlen(buf);\n#  else\n    len = vsnprintf(buf, sizeof(buf), format, va);\n    va_end(va);\n#  endif\n#endif\n    if (len <= 0 || len >= sizeof(buf) || buf[sizeof(buf) - 1] != 0)\n        return 0;\n    return gzwrite(file, buf, (unsigned)len);\n}",
  {
   "v1.2.0.2": [
    "2011-09-09 23:22:10",
    "gzio.c"
   ],
   "v1.2.0.3": [
    "2011-09-09 23:22:21",
    "gzio.c"
   ]
  }
 ],
 "d78bb8453ecd0644c4c6ff0d889883017893bbb10151c976909dda2ba95cdd5a": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch (sizeof(uInt)) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch (sizeof(uLong)) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch (sizeof(voidpf)) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch (sizeof(z_off_t)) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_DEFLATE\n    flags += 1 << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1 << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1 << 20;\n#endif\n#ifdef FASTEST\n    flags += 1 << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1 << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1 << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1 << 26;\n#    endif\n#  endif\n#else\n        flags += 1 << 24;\n#  ifdef NO_snprintf\n        flags += 1 << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1 << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1 << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "zutil.c"
   ]
  }
 ],
 "fc905620f7a8dc0211fa7ab6a742db88b72a181b97614318ec6ce36644229ab4": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n{\n    char buf[Z_PRINTF_BUFSIZE];\n    va_list va;\n    int len;\n\n    buf[sizeof(buf) - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(buf, format, va);\n    va_end(va);\n    for (len = 0; len < sizeof(buf); len++)\n        if (buf[len] == 0) break;\n#  else\n    len = vsprintf(buf, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(buf, sizeof(buf), format, va);\n    va_end(va);\n    len = strlen(buf);\n#  else\n    len = vsnprintf(buf, sizeof(buf), format, va);\n    va_end(va);\n#  endif\n#endif\n    if (len <= 0 || len >= (int)sizeof(buf) || buf[sizeof(buf) - 1] != 0)\n        return 0;\n    return gzwrite(file, buf, (unsigned)len);\n}",
  {
   "v1.2.0.4": [
    "2011-09-09 23:22:30",
    "gzio.c"
   ],
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "gzio.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "gzio.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "gzio.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "gzio.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "gzio.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "gzio.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "gzio.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "gzio.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "gzio.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "gzio.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "gzio.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "gzio.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "gzio.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "gzio.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "gzio.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "gzio.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "gzio.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "gzio.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "gzio.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "gzio.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "gzio.c"
   ]
  }
 ],
 "a593107719b5dbf1d7c34b9e4afa48b51b50335685238b06c6f086cd9eb865ad": [
  "static char *TGZfname (const char *fname)\n{\n  static char buffer[1024];\n  int origlen,i;\n\n  strcpy(buffer,fname);\n  origlen = strlen(buffer);\n\n  for (i=0; TGZsuffix[i]; i++)\n    {\n       strcpy(buffer+origlen,TGZsuffix[i]);\n       if (access(buffer,F_OK) == 0)\n         return buffer;\n    }\n  return NULL;\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "f8de3c4a08caddf8a9f06e6683725a9d7cc76bf66c188ed0160778fa8b6c3264": [
  "void TGZnotfound (const char *fname)\n{\n  int i;\n\n  fprintf(stderr,\"%s : couldn't find \",prog);\n  for (i=0;TGZsuffix[i];i++)\n    fprintf(stderr,(TGZsuffix[i+1]) ? \"%s%s, \" : \"or %s%s\\n\",\n            fname,\n            TGZsuffix[i]);\n  exit(1);\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "188e5265d2ea78a1f094024ed4a667f070af9e2c5ab4429c705c3303d4e52681": [
  "int setftime (char *fname,time_t ftime)\n{\n#ifdef WIN32\n  SYSTEMTIME st;\n  FILETIME locft, modft;\n  struct tm *loctm;\n  HANDLE hFile;\n  int result;\n\n  loctm = localtime(&ftime);\n  if (loctm == NULL)\n    return -1;\n\n  st.wYear         = (WORD)loctm->tm_year + 1900;\n  st.wMonth        = (WORD)loctm->tm_mon + 1;\n  st.wDayOfWeek    = (WORD)loctm->tm_wday;\n  st.wDay          = (WORD)loctm->tm_mday;\n  st.wHour         = (WORD)loctm->tm_hour;\n  st.wMinute       = (WORD)loctm->tm_min;\n  st.wSecond       = (WORD)loctm->tm_sec;\n  st.wMilliseconds = 0;\n  if (!SystemTimeToFileTime(&st, &locft) ||\n      !LocalFileTimeToFileTime(&locft, &modft))\n    return -1;\n\n  hFile = CreateFile(fname, GENERIC_READ | GENERIC_WRITE,\n                     0, NULL, OPEN_EXISTING, 0, 0);\n  if (hFile == INVALID_HANDLE_VALUE)\n    return -1;\n  result = SetFileTime(hFile, NULL, NULL, &modft) ? 0 : -1;\n  CloseHandle(hFile);\n  return result;\n#else\n  struct utimbuf settime;\n\n  settime.actime = settime.modtime = ftime;\n  return utime(fname,&settime);\n#endif\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "c5cc10e3085e777a38cc3d153b655fd52e5da9f939535925a0b059e2e57d0b56": [
  "int tar (gzFile in,int action,int arg,int argc,char **argv)\n{\n  union  tar_buffer buffer;\n  int    len;\n  int    err;\n  int    getheader = 1;\n  int    remaining = 0;\n  FILE   *outfile = NULL;\n  char   fname[BLOCKSIZE];\n  time_t tartime;\n\n  if (action == TGZ_LIST)\n    printf(\"     day      time     size                       file\\n\"\n           \" ---------- -------- --------- -------------------------------------\\n\");\n  while (1)\n    {\n      len = gzread(in, &buffer, BLOCKSIZE);\n      if (len < 0)\n        error (gzerror(in, &err));\n      /*\n       * Always expect complete blocks to process\n       * the tar information.\n       */\n      if (len != BLOCKSIZE)\n        error(\"gzread: incomplete block read\");\n\n      /*\n       * If we have to get a tar header\n       */\n      if (getheader == 1)\n        {\n          /*\n           * if we met the end of the tar\n           * or the end-of-tar block,\n           * we are done\n           */\n          if ((len == 0)  || (buffer.header.name[0]== 0)) break;\n\n          tartime = (time_t)getoct(buffer.header.mtime,12);\n          strcpy(fname,buffer.header.name);\n\n          switch (buffer.header.typeflag)\n            {\n            case DIRTYPE:\n              if (action == TGZ_LIST)\n                printf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n              if (action == TGZ_EXTRACT)\n                makedir(fname);\n              break;\n            case REGTYPE:\n            case AREGTYPE:\n              remaining = getoct(buffer.header.size,12);\n              if (action == TGZ_LIST)\n                printf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n              if (action == TGZ_EXTRACT)\n                {\n                  if ((remaining) && (matchname(arg,argc,argv,fname)))\n                    {\n                      outfile = fopen(fname,\"wb\");\n                      if (outfile == NULL) {\n                        /* try creating directory */\n                        char *p = strrchr(fname, '/');\n                        if (p != NULL) {\n                          *p = '\\0';\n                          makedir(fname);\n                          *p = '/';\n                          outfile = fopen(fname,\"wb\");\n                        }\n                      }\n                      fprintf(stderr,\n                              \"%s %s\\n\",\n                              (outfile) ? \"Extracting\" : \"Couldn't create\",\n                              fname);\n                    }\n                  else\n                    outfile = NULL;\n                }\n              /*\n               * could have no contents\n               */\n              getheader = (remaining) ? 0 : 1;\n              break;\n            default:\n              if (action == TGZ_LIST)\n                printf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n              break;\n            }\n        }\n      else\n        {\n          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n\n          if ((action == TGZ_EXTRACT) && (outfile != NULL))\n            {\n              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n                {\n                  fprintf(stderr,\"%s : error writing %s skipping...\\n\",prog,fname);\n                  fclose(outfile);\n                  unlink(fname);\n                }\n            }\n          remaining -= bytes;\n          if (remaining == 0)\n            {\n              getheader = 1;\n              if ((action == TGZ_EXTRACT) && (outfile != NULL))\n                {\n                  fclose(outfile);\n                  outfile = NULL;\n                  setftime(fname,tartime);\n                }\n            }\n        }\n    }\n\n  if (gzclose(in) != Z_OK)\n    error(\"failed gzclose\");\n\n  return 0;\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "5cbadc31c0b20b9456d69f7b6d158d498d7a0c5d03bce348fefd283b066b7beb": [
  "void help(int exitval)\n{\n  fprintf(stderr,\n          \"untgz version 0.1\\n\"\n          \" a sample application of zlib\\n\\n\"\n          \"Usage : untgz file.tgz            to extract all files\\n\"\n          \"        untgz file.tgz fname ...  to extract selected files\\n\"\n          \"        untgz -l file.tgz         to list archive contents\\n\"\n          \"        untgz -h                  to display this help\\n\\n\");\n  exit(exitval);\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "f227dcde7b86fc747e15a250ea4084ee5107b158f2cd19e40c3892cc8ccc8461": [
  "gzfilebuf *gzfilebuf::open( const char *name,\n                            int io_mode ) {\n\n  if ( is_open() )\n    return NULL;\n\n  char char_mode[10];\n  char *p = char_mode;\n\n  if ( io_mode & ios::in ) {\n    mode = ios::in;\n    *p++ = 'r';\n  } else if ( io_mode & ios::app ) {\n    mode = ios::app;\n    *p++ = 'a';\n  } else {\n    mode = ios::out;\n    *p++ = 'w';\n  }\n\n  if ( io_mode & ios::binary ) {\n    mode |= ios::binary;\n    *p++ = 'b';\n  }\n\n  // Hard code the compression level\n  if ( io_mode & (ios::out|ios::app )) {\n    *p++ = '9';\n  }\n\n  // Put the end-of-string indicator\n  *p = '\\0';\n\n  if ( (file = gzopen(name, char_mode)) == NULL )\n    return NULL;\n\n  own_file_descriptor = 1;\n\n  return this;\n\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "21c4be04b6a817f5ca381111f250f8d401f1a41ea745341abadfe54e0568bedc": [
  "gzfilebuf *gzfilebuf::attach( int file_descriptor,\n                              int io_mode ) {\n\n  if ( is_open() )\n    return NULL;\n\n  char char_mode[10];\n  char *p = char_mode;\n\n  if ( io_mode & ios::in ) {\n    mode = ios::in;\n    *p++ = 'r';\n  } else if ( io_mode & ios::app ) {\n    mode = ios::app;\n    *p++ = 'a';\n  } else {\n    mode = ios::out;\n    *p++ = 'w';\n  }\n\n  if ( io_mode & ios::binary ) {\n    mode |= ios::binary;\n    *p++ = 'b';\n  }\n\n  // Hard code the compression level\n  if ( io_mode & (ios::out|ios::app )) {\n    *p++ = '9';\n  }\n\n  // Put the end-of-string indicator\n  *p = '\\0';\n\n  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )\n    return NULL;\n\n  own_file_descriptor = 0;\n\n  return this;\n\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "4225d05ecec4a665b2a662137a9ce960e83db01bb4204994dc814029a70527f0": [
  "int gzfilebuf::setcompressionlevel( int comp_level ) {\n\n  return gzsetparams(file, comp_level, -2);\n\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "bff9202ff0ae7a4d0c4a6093ff3ea2b94bea0fa7cc94a5a0143993c9c04c5fe3": [
  "int gzfilebuf::setcompressionstrategy( int comp_strategy ) {\n\n  return gzsetparams(file, -2, comp_strategy);\n\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/iostream/zfstream.cpp"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/iostream/zfstream.cpp"
   ]
  }
 ],
 "bef0dd632f5344e51b595beea2d8b557ccd3aec69b086d2747854386caee0b53": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch (sizeof(uInt)) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch (sizeof(uLong)) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch (sizeof(voidpf)) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch (sizeof(z_off_t)) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1 << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1 << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1 << 20;\n#endif\n#ifdef FASTEST\n    flags += 1 << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1 << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1 << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1 << 26;\n#    endif\n#  endif\n#else\n        flags += 1 << 24;\n#  ifdef NO_snprintf\n        flags += 1 << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1 << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1 << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.0.5": [
    "2011-09-09 23:22:37",
    "zutil.c"
   ],
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "zutil.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "zutil.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "zutil.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "zutil.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "zutil.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "zutil.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "zutil.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "zutil.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "zutil.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "zutil.c"
   ]
  }
 ],
 "d0223a988984d434831ad8be60fe742c5a8dcc811cb66f130553ae578c2a96ca": [
  "void do_banner()\n{\n    printf(\"MiniZip 1.00, demo of zLib + Zip package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
  {
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "30545a812f4d7e3a80d73336ccde1b6c6f3e2bd98f8a3da806666475d8ba5363": [
  "void do_banner()\n{\n    printf(\"MiniUnz 1.00, demo of zLib + Unz package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
  {
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "2a6abbb531d7eec582b5bc8153769630a0b157fa40195d8d822fea355c5f92d2": [
  "void makefixed9(void)\n{\n    unsigned sym, bits, low, size;\n    code *next, *lenfix, *distfix;\n    struct inflate_state state;\n    code fixed[544];\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) state.lens[sym++] = 8;\n    while (sym < 256) state.lens[sym++] = 9;\n    while (sym < 280) state.lens[sym++] = 7;\n    while (sym < 288) state.lens[sym++] = 8;\n    next = fixed;\n    lenfix = next;\n    bits = 9;\n    inflate_table9(LENS, state.lens, 288, &(next), &(bits), state.work);\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) state.lens[sym++] = 5;\n    distfix = next;\n    bits = 5;\n    inflate_table9(DISTS, state.lens, 32, &(next), &(bits), state.work);\n\n    /* write tables */\n    puts(\"    /* inffix9.h -- table for decoding deflate64 fixed codes\");\n    puts(\"     * Generated automatically by makefixed9().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", lenfix[low].op, lenfix[low].bits,\n               lenfix[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 5) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", distfix[low].op, distfix[low].bits,\n               distfix[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}",
  {
   "v1.2.0.6": [
    "2011-09-09 23:22:48",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/infback9/infback9.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/infback9/infback9.c"
   ]
  }
 ],
 "257ede86cca314c35866449d8cb708acdb19de26c257385ba919481574edfb59": [
  "char *TGZfname (const char *arcname)\n{\n  static char buffer[1024];\n  int origlen,i;\n\n  strcpy(buffer,arcname);\n  origlen = strlen(buffer);\n\n  for (i=0; TGZsuffix[i]; i++)\n    {\n       strcpy(buffer+origlen,TGZsuffix[i]);\n       if (access(buffer,F_OK) == 0)\n         return buffer;\n    }\n  return NULL;\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "c7635f0c337456403e5fe70c72da02948f9bf51a1041ce3e974abe1ff3d0291b": [
  "void TGZnotfound (const char *arcname)\n{\n  int i;\n\n  fprintf(stderr,\"%s: Couldn't find \",prog);\n  for (i=0;TGZsuffix[i];i++)\n    fprintf(stderr,(TGZsuffix[i+1]) ? \"%s%s, \" : \"or %s%s\\n\",\n            arcname,\n            TGZsuffix[i]);\n  exit(1);\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "50b918712e4b248559f04e4b9963957852cd9f10cdfe5530b143b45ecdce46bd": [
  "int getoct (char *p,int width)\n{\n  int result = 0;\n  char c;\n\n  while (width--)\n    {\n      c = *p++;\n      if (c == 0)\n        break;\n      if (c == ' ')\n        continue;\n      if (c < '0' || c > '7')\n        return -1;\n      result = result * 8 + (c - '0');\n    }\n  return result;\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "ee136f03c65778b0be9a156b3eeb5fe886ed1309462ff76ddf2ee65c539ff689": [
  "char *strtime (time_t *t)\n{\n  struct tm   *local;\n  static char result[32];\n\n  local = localtime(t);\n  sprintf(result,\"%4d/%02d/%02d %02d:%02d:%02d\",\n          local->tm_year+1900, local->tm_mon+1, local->tm_mday,\n          local->tm_hour, local->tm_min, local->tm_sec);\n  return result;\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "6b9d4ace6946d60e325550cb793ca0fa7b57af4802b698e1bb6f0411f9fb7d67": [
  "int setfiletime (char *fname,time_t ftime)\n{\n#ifdef WIN32\n  static int isWinNT = -1;\n  SYSTEMTIME st;\n  FILETIME locft, modft;\n  struct tm *loctm;\n  HANDLE hFile;\n  int result;\n\n  loctm = localtime(&ftime);\n  if (loctm == NULL)\n    return -1;\n\n  st.wYear         = (WORD)loctm->tm_year + 1900;\n  st.wMonth        = (WORD)loctm->tm_mon + 1;\n  st.wDayOfWeek    = (WORD)loctm->tm_wday;\n  st.wDay          = (WORD)loctm->tm_mday;\n  st.wHour         = (WORD)loctm->tm_hour;\n  st.wMinute       = (WORD)loctm->tm_min;\n  st.wSecond       = (WORD)loctm->tm_sec;\n  st.wMilliseconds = 0;\n  if (!SystemTimeToFileTime(&st, &locft) ||\n      !LocalFileTimeToFileTime(&locft, &modft))\n    return -1;\n\n  if (isWinNT < 0)\n    isWinNT = (GetVersion() < 0x80000000) ? 1 : 0;\n  hFile = CreateFile(fname, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\n                     (isWinNT ? FILE_FLAG_BACKUP_SEMANTICS : 0),\n                     NULL);\n  if (hFile == INVALID_HANDLE_VALUE)\n    return -1;\n  result = SetFileTime(hFile, NULL, NULL, &modft) ? 0 : -1;\n  CloseHandle(hFile);\n  return result;\n#else\n  struct utimbuf settime;\n\n  settime.actime = settime.modtime = ftime;\n  return utime(fname,&settime);\n#endif\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "71f5014a075a584dce231dcb8f84a7caed689c47a5fcdb0e3b3fdcc53ab8f443": [
  "int makedir (char *newdir)\n{\n  char *buffer = strdup(newdir);\n  char *p;\n  int  len = strlen(buffer);\n\n  if (len <= 0) {\n    free(buffer);\n    return 0;\n  }\n  if (buffer[len-1] == '/') {\n    buffer[len-1] = '\\0';\n  }\n  if (mkdir(buffer, 0755) == 0)\n    {\n      free(buffer);\n      return 1;\n    }\n\n  p = buffer+1;\n  while (1)\n    {\n      char hold;\n\n      while(*p && *p != '\\\\' && *p != '/')\n        p++;\n      hold = *p;\n      *p = 0;\n      if ((mkdir(buffer, 0755) == -1) && (errno == ENOENT))\n        {\n          fprintf(stderr,\"%s: Couldn't create directory %s\\n\",prog,buffer);\n          free(buffer);\n          return 0;\n        }\n      if (hold == 0)\n        break;\n      *p++ = hold;\n    }\n  free(buffer);\n  return 1;\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "350e7c83391bac0d25f07807339312660ffee5da31842710edbc75a251ee3962": [
  "int tar (gzFile in,int action,int arg,int argc,char **argv)\n{\n  union  tar_buffer buffer;\n  int    len;\n  int    err;\n  int    getheader = 1;\n  int    remaining = 0;\n  FILE   *outfile = NULL;\n  char   fname[BLOCKSIZE];\n  int    tarmode;\n  time_t tartime;\n\n  if (action == TGZ_LIST)\n    printf(\"    date      time     size                       file\\n\"\n           \" ---------- -------- --------- -------------------------------------\\n\");\n  while (1)\n    {\n      len = gzread(in, &buffer, BLOCKSIZE);\n      if (len < 0)\n        error(gzerror(in, &err));\n      /*\n       * Always expect complete blocks to process\n       * the tar information.\n       */\n      if (len != BLOCKSIZE)\n        {\n          action = TGZ_INVALID; /* force error exit */\n          remaining = 0;        /* force I/O cleanup */\n        }\n\n      /*\n       * If we have to get a tar header\n       */\n      if (getheader == 1)\n        {\n          /*\n           * if we met the end of the tar\n           * or the end-of-tar block,\n           * we are done\n           */\n          if ((len == 0) || (buffer.header.name[0] == 0)) break;\n\n          tarmode = getoct(buffer.header.mode,8);\n          tartime = (time_t)getoct(buffer.header.mtime,12);\n          if (tarmode == -1 || tartime == (time_t)-1)\n            {\n              buffer.header.name[0] = 0;\n              action = TGZ_INVALID;\n            }\n\n          strcpy(fname,buffer.header.name);\n\n          switch (buffer.header.typeflag)\n            {\n            case DIRTYPE:\n              if (action == TGZ_LIST)\n                printf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n              if (action == TGZ_EXTRACT)\n                {\n                  makedir(fname);\n                  setfiletime(fname,tartime);\n                }\n              break;\n            case REGTYPE:\n            case AREGTYPE:\n              remaining = getoct(buffer.header.size,12);\n              if (remaining == -1)\n                {\n                  action = TGZ_INVALID;\n                  break;\n                }\n              if (action == TGZ_LIST)\n                printf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n              else if (action == TGZ_EXTRACT)\n                {\n                  if (matchname(arg,argc,argv,fname))\n                    {\n                      outfile = fopen(fname,\"wb\");\n                      if (outfile == NULL) {\n                        /* try creating directory */\n                        char *p = strrchr(fname, '/');\n                        if (p != NULL) {\n                          *p = '\\0';\n                          makedir(fname);\n                          *p = '/';\n                          outfile = fopen(fname,\"wb\");\n                        }\n                      }\n                      if (outfile != NULL)\n                        printf(\"Extracting %s\\n\",fname);\n                      else\n                        fprintf(stderr, \"%s: Couldn't create %s\",prog,fname);\n                    }\n                  else\n                    outfile = NULL;\n                }\n              getheader = 0;\n              break;\n            default:\n              if (action == TGZ_LIST)\n                printf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n              break;\n            }\n        }\n      else\n        {\n          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n\n          if (outfile != NULL)\n            {\n              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n                {\n                  fprintf(stderr,\"%s: Error writing %s -- skipping\\n\",prog,fname);\n                  fclose(outfile);\n                  outfile = NULL;\n                  remove(fname);\n                }\n            }\n          remaining -= bytes;\n        }\n\n      if (remaining == 0)\n        {\n          getheader = 1;\n          if (outfile != NULL)\n            {\n              fclose(outfile);\n              outfile = NULL;\n              if (action != TGZ_INVALID)\n                setfiletime(fname,tartime);\n            }\n        }\n\n      /*\n       * Abandon if errors are found\n       */\n      if (action == TGZ_INVALID)\n        {\n          error(\"broken archive\");\n          break;\n        }\n    }\n\n  if (gzclose(in) != Z_OK)\n    error(\"failed gzclose\");\n\n  return 0;\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "6cfb57c4344869e0caac598311ee40c1dcc1df38960e5665fcb0700ec43263ae": [
  "void help(int exitval)\n{\n  printf(\"untgz version 0.2\\n\"\n         \"  using zlib version %s\\n\\n\",\n         zlibVersion());\n  printf(\"Usage: untgz file.tgz            extract all files\\n\"\n         \"       untgz file.tgz fname ...  extract selected files\\n\"\n         \"       untgz -l file.tgz         list archive contents\\n\"\n         \"       untgz -h                  display this help\\n\");\n  exit(exitval);\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "905a953a9377e1c2bf43b87f3a7a4cd3c34b1fe6daf9ade8e0eba17a3b19dbd7": [
  "int main(int argc,char **argv)\n{\n    int         action = TGZ_EXTRACT;\n    int         arg = 1;\n    char        *TGZfile;\n    gzFile      *f;\n\n    prog = strrchr(argv[0],'\\\\');\n    if (prog == NULL)\n      {\n        prog = strrchr(argv[0],'/');\n        if (prog == NULL)\n          {\n            prog = strrchr(argv[0],':');\n            if (prog == NULL)\n              prog = argv[0];\n            else\n              prog++;\n          }\n        else\n          prog++;\n      }\n    else\n      prog++;\n\n    if (argc == 1)\n      help(0);\n\n    if (strcmp(argv[arg],\"-l\") == 0)\n      {\n        action = TGZ_LIST;\n        if (argc == ++arg)\n          help(0);\n      }\n    else if (strcmp(argv[arg],\"-h\") == 0)\n      {\n        help(0);\n      }\n\n    if ((TGZfile = TGZfname(argv[arg])) == NULL)\n      TGZnotfound(argv[arg]);\n\n    ++arg;\n    if ((action == TGZ_LIST) && (arg != argc))\n      help(1);\n\n/*\n *  Process the TGZ file\n */\n    switch(action)\n      {\n      case TGZ_LIST:\n      case TGZ_EXTRACT:\n        f = gzopen(TGZfile,\"rb\");\n        if (f == NULL)\n          {\n            fprintf(stderr,\"%s: Couldn't gzopen %s\\n\",prog,TGZfile);\n            return 1;\n          }\n        exit(tar(f, action, arg, argc, argv));\n      break;\n\n      default:\n        error(\"Unknown option\");\n        exit(1);\n      }\n\n    return 0;\n}",
  {
   "v1.2.0.7": [
    "2011-09-09 23:23:01",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "8c766bade3d3c51102c42370b756cc8368b8bdad231c282d6c881c5bc698a4f0": [
  "local void bye(char *msg1, char *msg2)\n{\n    fprintf(stderr, \"gzappend error: %s%s\\n\", msg1, msg2);\n    exit(1);\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "d91d85fbfe06eeb18ea64f057224bdad7a77f4afddd12574cbdad8adbad8762f": [
  "local unsigned gcd(unsigned a, unsigned b)\n{\n    unsigned c;\n\n    while (a && b)\n        if (a > b) {\n            c = b;\n            while (a - c >= c)\n                c <<= 1;\n            a -= c;\n        }\n        else {\n            c = a;\n            while (b - c >= c)\n                c <<= 1;\n            b -= c;\n        }\n    return a + b;\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "8ac6e29c956aae0c96822a2dd32e3757019b554ac7485bdf0af17e13af993ab4": [
  "local void rotate(unsigned char *list, unsigned len, unsigned rot)\n{\n    unsigned char tmp;\n    unsigned cycles;\n    unsigned char *start, *last, *to, *from;\n\n    /* normalize rot and handle degenerate cases */\n    if (len < 2) return;\n    if (rot >= len) rot %= len;\n    if (rot == 0) return;\n\n    /* pointer to last entry in list */\n    last = list + (len - 1);\n\n    /* do simple left shift by one */\n    if (rot == 1) {\n        tmp = *list;\n        memcpy(list, list + 1, len - 1);\n        *last = tmp;\n        return;\n    }\n\n    /* do simple right shift by one */\n    if (rot == len - 1) {\n        tmp = *last;\n        memmove(list + 1, list, len - 1);\n        *list = tmp;\n        return;\n    }\n\n    /* otherwise do rotate as a set of cycles in place */\n    cycles = gcd(len, rot);             /* number of cycles */\n    do {\n        start = from = list + cycles;   /* start index is arbitrary */\n        tmp = *from;                    /* save entry to be overwritten */\n        for (;;) {\n            to = from;                  /* next step in cycle */\n            from += rot;                /* go right rot positions */\n            if (from > last) from -= len;   /* (pointer better not wrap) */\n            if (from == start) break;   /* all but one shifted */\n            *to = *from;                /* shift left */\n        }\n        *to = tmp;                      /* complete the circle */\n    } while (--cycles);\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "772ff354cbc453a4cb2c1300c55523b41c02cd94af1b5724ca38effab66185f8": [
  "local int readin(file *in)\n{\n    int len;\n\n    len = read(in->fd, in->buf, 1 << in->size);\n    if (len == -1) bye(\"error reading \", in->name);\n    in->left = (unsigned)len;\n    in->next = in->buf;\n    return len;\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "e3f2670c1c46c5ab3f22b509c517f699449adbfa5dd1f65236cfadbbf057875c": [
  "local int readmore(file *in)\n{\n    if (readin(in) == 0) bye(\"unexpected end of \", in->name);\n    return 0;\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "e952b78a9dcd3c36895c35b56f0b0f80c214ea797090066c09596f1a5e35558b": [
  "local void skip(file *in, unsigned n)\n{\n    unsigned bypass;\n\n    if (n > in->left) {\n        n -= in->left;\n        bypass = n & ~((1U << in->size) - 1);\n        if (bypass) {\n            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)\n                bye(\"seeking \", in->name);\n            n -= bypass;\n        }\n        readmore(in);\n        if (n > in->left)\n            bye(\"unexpected end of \", in->name);\n    }\n    in->left -= n;\n    in->next += n;\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "16ed980a7ebb07cd902938c2c19ea490fd825ccaeee167e49715e1aef8d548a0": [
  "unsigned long read4(file *in)\n{\n    unsigned long val;\n\n    val = read1(in);\n    val += (unsigned)read1(in) << 8;\n    val += (unsigned long)read1(in) << 16;\n    val += (unsigned long)read1(in) << 24;\n    return val;\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "2ad359eea703f048b345342412410122b4a05924d5f91546db2ea9655bbd5e4b": [
  "local void gzheader(file *in)\n{\n    int flags;\n    unsigned n;\n\n    if (read1(in) != 31 || read1(in) != 139) bye(in->name, \" not a gzip file\");\n    if (read1(in) != 8) bye(\"unknown compression method in\", in->name);\n    flags = read1(in);\n    if (flags & 0xe0) bye(\"unknown header flags set in\", in->name);\n    skip(in, 6);\n    if (flags & 4) {\n        n = read1(in);\n        n += (unsigned)(read1(in)) << 8;\n        skip(in, n);\n    }\n    if (flags & 8) while (read1(in) != 0) ;\n    if (flags & 16) while (read1(in) != 0) ;\n    if (flags & 2) skip(in, 2);\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "3d292b8cd9631343ecf8987fa3e6ac2b40a47742cf208a7f5b47abb6e4a63013": [
  "local int gzscan(char *name, z_stream *strm, int level)\n{\n    int ret, lastbit, left, full;\n    unsigned have;\n    unsigned long crc, tot;\n    unsigned char *window;\n    off_t lastoff, end;\n    file gz;\n\n    /* open gzip file */\n    gz.name = name;\n    gz.fd = open(name, O_RDWR, 0);\n    if (gz.fd == -1) bye(\"cannot open \", name);\n    gz.buf = malloc(CHUNK);\n    if (gz.buf == NULL) bye(\"out of memory\", \"\");\n    gz.size = LGCHUNK;\n    gz.left = 0;\n\n    /* skip gzip header */\n    gzheader(&gz);\n\n    /* prepare to decompress */\n    window = malloc(DSIZE);\n    if (window == NULL) bye(\"out of memory\", \"\");\n    strm->zalloc = Z_NULL;\n    strm->zfree = Z_NULL;\n    strm->opaque = Z_NULL;\n    ret = inflateInit2(strm, -15);\n    if (ret != Z_OK) bye(\"out of memory\", \" or library mismatch\");\n\n    /* decompress the deflate stream, saving append information */\n    lastbit = 0;\n    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n    left = 0;\n    strm->avail_in = gz.left;\n    strm->next_in = gz.next;\n    crc = crc32(0L, Z_NULL, 0);\n    have = full = 0;\n    do {\n        /* if needed, get more input */\n        if (strm->avail_in == 0) {\n            readmore(&gz);\n            strm->avail_in = gz.left;\n            strm->next_in = gz.next;\n        }\n\n        /* set up output to next available section of sliding window */\n        strm->avail_out = DSIZE - have;\n        strm->next_out = window + have;\n\n        /* inflate and check for errors */\n        ret = inflate(strm, Z_BLOCK);\n        if (ret == Z_STREAM_ERROR) bye(\"internal stream error!\", \"\");\n        if (ret == Z_MEM_ERROR) bye(\"out of memory\", \"\");\n        if (ret == Z_DATA_ERROR)\n            bye(\"invalid compressed data--format violated in\", name);\n\n        /* update crc and sliding window pointer */\n        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);\n        if (strm->avail_out)\n            have = DSIZE - strm->avail_out;\n        else {\n            have = 0;\n            full = 1;\n        }\n\n        /* process end of block */\n        if (strm->data_type & 128) {\n            if (strm->data_type & 64)\n                left = strm->data_type & 0x1f;\n            else {\n                lastbit = strm->data_type & 0x1f;\n                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;\n            }\n        }\n    } while (ret != Z_STREAM_END);\n    inflateEnd(strm);\n    gz.left = strm->avail_in;\n    gz.next = strm->next_in;\n\n    /* save the location of the end of the compressed data */\n    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n\n    /* check gzip trailer and save total for deflate */\n    if (crc != read4(&gz))\n        bye(\"invalid compressed data--crc mismatch in \", name);\n    tot = strm->total_out;\n    if ((tot & 0xffffffffUL) != read4(&gz))\n        bye(\"invalid compressed data--length mismatch in\", name);\n\n    /* if not at end of file, warn */\n    if (gz.left || readin(&gz))\n        fprintf(stderr,\n            \"gzappend warning: junk at end of gzip file overwritten\\n\");\n\n    /* clear last block bit */\n    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);\n    if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));\n    lseek(gz.fd, -1L, SEEK_CUR);\n    if (write(gz.fd, gz.buf, 1) != 1) bye(\"writing after seek to \", name);\n\n    /* if window wrapped, build dictionary from window by rotating */\n    if (full) {\n        rotate(window, DSIZE, have);\n        have = DSIZE;\n    }\n\n    /* set up deflate stream with window, crc, total_in, and leftover bits */\n    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);\n    if (ret != Z_OK) bye(\"out of memory\", \"\");\n    deflateSetDictionary(strm, window, have);\n    strm->adler = crc;\n    strm->total_in = tot;\n    if (left) {\n        lseek(gz.fd, --end, SEEK_SET);\n        if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n        deflatePrime(strm, 8 - left, *gz.buf);\n    }\n    lseek(gz.fd, end, SEEK_SET);\n\n    /* clean up and return */\n    free(window);\n    free(gz.buf);\n    return gz.fd;\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "fbdd1264f1485d558431ca3bdfd8d79c0d8a05522a1376db0d26feb60761bde3": [
  "local void gztack(char *name, int gd, z_stream *strm, int last)\n{\n    int fd, len, ret;\n    unsigned left;\n    unsigned char *in, *out;\n\n    /* open file to compress and append */\n    fd = 0;\n    if (name != NULL) {\n        fd = open(name, O_RDONLY, 0);\n        if (fd == -1)\n            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n                    name);\n    }\n\n    /* allocate buffers */\n    in = fd == -1 ? NULL : malloc(CHUNK);\n    out = malloc(CHUNK);\n    if (out == NULL) bye(\"out of memory\", \"\");\n\n    /* compress input file and append to gzip file */\n    do {\n        /* get more input */\n        len = fd == -1 ? 0 : read(fd, in, CHUNK);\n        if (len == -1) {\n            fprintf(stderr,\n                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n                    name);\n            len = 0;\n        }\n        strm->avail_in = (unsigned)len;\n        strm->next_in = in;\n        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n\n        /* compress and write all available output */\n        do {\n            strm->avail_out = CHUNK;\n            strm->next_out = out;\n            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n            left = CHUNK - strm->avail_out;\n            while (left) {\n                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n                if (len == -1) bye(\"writing gzip file\", \"\");\n                left -= (unsigned)len;\n            }\n        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n    } while (len != 0);\n\n    /* write trailer after last entry */\n    if (last) {\n        deflateEnd(strm);\n        out[0] = (unsigned char)(strm->adler);\n        out[1] = (unsigned char)(strm->adler >> 8);\n        out[2] = (unsigned char)(strm->adler >> 16);\n        out[3] = (unsigned char)(strm->adler >> 24);\n        out[4] = (unsigned char)(strm->total_in);\n        out[5] = (unsigned char)(strm->total_in >> 8);\n        out[6] = (unsigned char)(strm->total_in >> 16);\n        out[7] = (unsigned char)(strm->total_in >> 24);\n        len = 8;\n        do {\n            ret = write(gd, out + 8 - len, len);\n            if (ret == -1) bye(\"writing gzip file\", \"\");\n            len -= ret;\n        } while (len);\n        close(gd);\n    }\n\n    /* clean up and return */\n    free(out);\n    if (in != NULL) free(in);\n    if (fd > 0) close(fd);\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ]
  }
 ],
 "95de4a6f62ccdd26036aa7855b904314adc7e460eb5ea4e32a194f58a8a2d734": [
  "int main(int argc, char **argv)\n{\n    int gd, level;\n    z_stream strm;\n\n    /* ignore command name */\n    argv++;\n\n    /* provide usage if no arguments */\n    if (*argv == NULL) {\n        printf(\"gzappend 1.1 (4 Nov 2003) Copyright (C) 2003 Mark Adler\\n\");\n        printf(\n            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n        return 0;\n    }\n\n    /* set compression level */\n    level = Z_DEFAULT_COMPRESSION;\n    if (argv[0][0] == '-') {\n        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n            bye(\"invalid compression level\", \"\");\n        level = argv[0][1] - '0';\n        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n    }\n\n    /* prepare to append to gzip file */\n    gd = gzscan(*argv++, &strm, level);\n\n    /* append files on command line, or from stdin if none */\n    if (*argv == NULL)\n        gztack(NULL, gd, &strm, 1);\n    else\n        do {\n            gztack(*argv, gd, &strm, argv[1] == NULL);\n        } while (*++argv != NULL);\n    return 0;\n}",
  {
   "v1.2.0.8": [
    "2011-09-09 23:23:14",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1": [
    "2011-09-09 23:23:27",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.1": [
    "2011-09-09 23:23:38",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/gzappend/gzappend.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzappend.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzappend.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzappend.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzappend.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzappend.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzappend.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzappend.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzappend.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzappend.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzappend.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzappend.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzappend.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzappend.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzappend.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzappend.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzappend.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzappend.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzappend.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzappend.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzappend.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzappend.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzappend.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzappend.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzappend.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzappend.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzappend.c"
   ]
  }
 ],
 "77cac559b993416e6dfe9e4b2d661a1bb0574df8dbadd5b95ff2427f7bed2bd3": [
  "void do_banner()\n{\n    printf(\"MiniZip 1.01b, demo of zLib + Zip package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "ec7339a3615880b8608ca76f9403454e49a109fa032de23a98fc54e637c68efe": [
  "void do_banner()\n{\n    printf(\"MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/miniunz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "567130e41eefba51cc76ea31aa6cf95508d9d8e1a5c50e6f6726de09a286d480": [
  "void do_help()\n{\n    printf(\"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\\n\\n\" \\\n           \"  -e  Extract without pathname (junk paths)\\n\" \\\n           \"  -x  Extract with pathname\\n\" \\\n           \"  -v  list files\\n\" \\\n           \"  -l  list files\\n\" \\\n           \"  -d  directory to extract into\\n\" \\\n           \"  -o  overwrite files without prompting\\n\" \\\n           \"  -p  extract crypted file using password\\n\\n\");\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/miniunz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "2648d0d4b88685cb330214f459bee288bb01172c5a36d7f5ee494792a1780a1f": [
  "void push_attr(struct attr_item **list,char *fname,int mode,time_t time)\n{\n  struct attr_item *item;\n\n  item = (struct attr_item *)malloc(sizeof(struct attr_item));\n  if (item == NULL)\n    error(\"Out of memory\");\n  item->fname = strdup(fname);\n  item->mode  = mode;\n  item->time  = time;\n  item->next  = *list;\n  *list       = item;\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "16bb2784763eeadb71ada382684beedcbcdd729a8c770cbca41b2c870d982793": [
  "void restore_attr(struct attr_item **list)\n{\n  struct attr_item *item, *prev;\n\n  for (item = *list; item != NULL; )\n    {\n      setfiletime(item->fname,item->time);\n      chmod(item->fname,item->mode);\n      prev = item;\n      item = item->next;\n      free(prev);\n    }\n  *list = NULL;\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "61a0dc2dc8f5eaee0feecef046bb48d97d174b5eee1ce5b5d25ebd9ac7c40ca5": [
  "int tar (gzFile in,int action,int arg,int argc,char **argv)\n{\n  union  tar_buffer buffer;\n  int    len;\n  int    err;\n  int    getheader = 1;\n  int    remaining = 0;\n  FILE   *outfile = NULL;\n  char   fname[BLOCKSIZE];\n  int    tarmode;\n  time_t tartime;\n  struct attr_item *attributes = NULL;\n\n  if (action == TGZ_LIST)\n    printf(\"    date      time     size                       file\\n\"\n           \" ---------- -------- --------- -------------------------------------\\n\");\n  while (1)\n    {\n      len = gzread(in, &buffer, BLOCKSIZE);\n      if (len < 0)\n        error(gzerror(in, &err));\n      /*\n       * Always expect complete blocks to process\n       * the tar information.\n       */\n      if (len != BLOCKSIZE)\n        {\n          action = TGZ_INVALID; /* force error exit */\n          remaining = 0;        /* force I/O cleanup */\n        }\n\n      /*\n       * If we have to get a tar header\n       */\n      if (getheader >= 1)\n        {\n          /*\n           * if we met the end of the tar\n           * or the end-of-tar block,\n           * we are done\n           */\n          if (len == 0 || buffer.header.name[0] == 0)\n            break;\n\n          tarmode = getoct(buffer.header.mode,8);\n          tartime = (time_t)getoct(buffer.header.mtime,12);\n          if (tarmode == -1 || tartime == (time_t)-1)\n            {\n              buffer.header.name[0] = 0;\n              action = TGZ_INVALID;\n            }\n\n          if (getheader == 1)\n            {\n              strncpy(fname,buffer.header.name,SHORTNAMESIZE);\n              if (fname[SHORTNAMESIZE-1] != 0)\n                  fname[SHORTNAMESIZE] = 0;\n            }\n          else\n            {\n              /*\n               * The file name is longer than SHORTNAMESIZE\n               */\n              if (strncmp(fname,buffer.header.name,SHORTNAMESIZE-1) != 0)\n                  error(\"bad long name\");\n              getheader = 1;\n            }\n\n          /*\n           * Act according to the type flag\n           */\n          switch (buffer.header.typeflag)\n            {\n            case DIRTYPE:\n              if (action == TGZ_LIST)\n                printf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n              if (action == TGZ_EXTRACT)\n                {\n                  makedir(fname);\n                  push_attr(&attributes,fname,tarmode,tartime);\n                }\n              break;\n            case REGTYPE:\n            case AREGTYPE:\n              remaining = getoct(buffer.header.size,12);\n              if (remaining == -1)\n                {\n                  action = TGZ_INVALID;\n                  break;\n                }\n              if (action == TGZ_LIST)\n                printf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n              else if (action == TGZ_EXTRACT)\n                {\n                  if (matchname(arg,argc,argv,fname))\n                    {\n                      outfile = fopen(fname,\"wb\");\n                      if (outfile == NULL) {\n                        /* try creating directory */\n                        char *p = strrchr(fname, '/');\n                        if (p != NULL) {\n                          *p = '\\0';\n                          makedir(fname);\n                          *p = '/';\n                          outfile = fopen(fname,\"wb\");\n                        }\n                      }\n                      if (outfile != NULL)\n                        printf(\"Extracting %s\\n\",fname);\n                      else\n                        fprintf(stderr, \"%s: Couldn't create %s\",prog,fname);\n                    }\n                  else\n                    outfile = NULL;\n                }\n              getheader = 0;\n              break;\n            case GNUTYPE_LONGLINK:\n            case GNUTYPE_LONGNAME:\n              remaining = getoct(buffer.header.size,12);\n              if (remaining < 0 || remaining >= BLOCKSIZE)\n                {\n                  action = TGZ_INVALID;\n                  break;\n                }\n              len = gzread(in, fname, BLOCKSIZE);\n              if (len < 0)\n                error(gzerror(in, &err));\n              if (fname[BLOCKSIZE-1] != 0 || (int)strlen(fname) > remaining)\n                {\n                  action = TGZ_INVALID;\n                  break;\n                }\n              getheader = 2;\n              break;\n            default:\n              if (action == TGZ_LIST)\n                printf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n              break;\n            }\n        }\n      else\n        {\n          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n\n          if (outfile != NULL)\n            {\n              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n                {\n                  fprintf(stderr,\n                    \"%s: Error writing %s -- skipping\\n\",prog,fname);\n                  fclose(outfile);\n                  outfile = NULL;\n                  remove(fname);\n                }\n            }\n          remaining -= bytes;\n        }\n\n      if (remaining == 0)\n        {\n          getheader = 1;\n          if (outfile != NULL)\n            {\n              fclose(outfile);\n              outfile = NULL;\n              if (action != TGZ_INVALID)\n                push_attr(&attributes,fname,tarmode,tartime);\n            }\n        }\n\n      /*\n       * Abandon if errors are found\n       */\n      if (action == TGZ_INVALID)\n        {\n          error(\"broken archive\");\n          break;\n        }\n    }\n\n  /*\n   * Restore file modes and time stamps\n   */\n  restore_attr(&attributes);\n\n  if (gzclose(in) != Z_OK)\n    error(\"failed gzclose\");\n\n  return 0;\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "87555c9ed0bd3fa5e8101d9bbdcc219c0e6c14047c89f009f9d8a44ed41fc0b7": [
  "void help(int exitval)\n{\n  printf(\"untgz version 0.2.1\\n\"\n         \"  using zlib version %s\\n\\n\",\n         zlibVersion());\n  printf(\"Usage: untgz file.tgz            extract all files\\n\"\n         \"       untgz file.tgz fname ...  extract selected files\\n\"\n         \"       untgz -l file.tgz         list archive contents\\n\"\n         \"       untgz -h                  display this help\\n\");\n  exit(exitval);\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/untgz/untgz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/untgz/untgz.c"
   ]
  }
 ],
 "a7356a39578b5bb4c513c75a668735b70a72fcabed00f60f5fc1820a3f580ab7": [
  "local void make_crc_table()\n{\n    unsigned long c;\n    int n, k;\n    unsigned long poly;\t\t\t\t/* polynomial exclusive-or pattern */\n    /* terms of polynomial defining this crc (except x^32): */\n\tstatic volatile int first = 1;\t\t/* flag to limit concurrent making */\n    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n\t/* See if another task is already doing this (not thread-safe, but better\n\t   than nothing -- significantly reduces duration of vulnerability in\n\t   case the advice about DYNAMIC_CRC_TABLE is ignored) */\n\tif (first) {\n\t\tfirst = 0;\n\n\t\t/* make exclusive-or pattern from polynomial (0xedb88320UL) */\n\t\tpoly = 0UL;\n\t\tfor (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n\t\t\tpoly |= 1UL << (31 - p[n]);\n\n\t\t/* generate a crc for every 8-bit value */\n\t\tfor (n = 0; n < 256; n++) {\n\t\t\tc = (unsigned long)n;\n\t\t\tfor (k = 0; k < 8; k++)\n\t\t\t\tc = c & 1 ? poly ^ (c >> 1) : c >> 1;\n\t\t\tcrc_table[0][n] = c;\n\t\t}\n\n#ifdef BYFOUR\n\t\t/* generate crc for each value followed by one, two, and three zeros, and\n\t\t   then the byte reversal of those as well as the first table */\n\t\tfor (n = 0; n < 256; n++) {\n\t\t\tc = crc_table[0][n];\n\t\t\tcrc_table[4][n] = REV(c);\n\t\t\tfor (k = 1; k < 4; k++) {\n\t\t\t\tc = crc_table[0][c & 0xff] ^ (c >> 8);\n\t\t\t\tcrc_table[k][n] = c;\n\t\t\t\tcrc_table[k + 4][n] = REV(c);\n\t\t\t}\n\t\t}\n#endif /* BYFOUR */\n\n\t\tcrc_table_empty = 0;\n\t}\n\telse {\t\t/* not first */\n\t\t/* wait for the other guy to finish (not exactly efficient, but rare) */\n\t\twhile (crc_table_empty)\n\t\t\t;\n\t}\n\n#ifdef MAKECRCH\n    /* write out CRC tables to crc32.h */\n    {\n        FILE *out;\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n        fprintf(out, \"local const unsigned long FAR \");\n        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n        write_table(out, crc_table[0]);\n#  ifdef BYFOUR\n        fprintf(out, \"#ifdef BYFOUR\\n\");\n        for (k = 1; k < 8; k++) {\n            fprintf(out, \"  },\\n  {\\n\");\n            write_table(out, crc_table[k]);\n        }\n        fprintf(out, \"#endif\\n\");\n#  endif /* BYFOUR */\n        fprintf(out, \"  }\\n};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
  {
   "v1.2.1.2": [
    "2011-09-09 23:23:45",
    "crc32.c"
   ],
   "v1.2.2": [
    "2011-09-09 23:24:02",
    "crc32.c"
   ],
   "v1.2.2.1": [
    "2011-09-09 23:24:24",
    "crc32.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "crc32.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "crc32.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "crc32.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "crc32.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "crc32.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "crc32.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "crc32.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "crc32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "crc32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "crc32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "crc32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "crc32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "crc32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "crc32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "crc32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "crc32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "crc32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "crc32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "crc32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "crc32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "crc32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "crc32.c"
   ]
  }
 ],
 "a0b38ffe47d43273f0f5caaa461ea2dcec24ded9d0edede032d53d48bd7cb77d": [
  "local void cleanup(void)\n{\n    size_t n;\n\n    if (done != NULL) {\n        for (n = 0; n < size; n++)\n            if (done[n].len)\n                free(done[n].vec);\n        free(done);\n    }\n    if (num != NULL)\n        free(num);\n    if (code != NULL)\n        free(code);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/enough.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/enough.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/enough.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/enough.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/enough.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/enough.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/enough.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/enough.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/enough.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/enough.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/enough.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/enough.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/enough.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/enough.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/enough.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/enough.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/enough.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/enough.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/enough.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/enough.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/enough.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/enough.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/enough.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/enough.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/enough.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/enough.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/enough.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/enough.c"
   ]
  }
 ],
 "5e001a66cdd621ca441cf6c5716a4fdc32645fa912c039342a940661a50b0625": [
  "local big_t count(int syms, int len, int left)\n{\n    big_t sum;          /* number of possible codes from this juncture */\n    big_t got;          /* value returned from count() */\n    int least;          /* least number of syms to use at this juncture */\n    int most;           /* most number of syms to use at this juncture */\n    int use;            /* number of bit patterns to use in next call */\n    size_t index;       /* index of this case in *num */\n\n    /* see if only one possible code */\n    if (syms == left)\n        return 1;\n\n    /* note and verify the expected state */\n    assert(syms > left && left > 0 && len < max);\n\n    /* see if we've done this one already */\n    index = INDEX(syms, left, len);\n    got = num[index];\n    if (got)\n        return got;         /* we have -- return the saved result */\n\n    /* we need to use at least this many bit patterns so that the code won't be\n       incomplete at the next length (more bit patterns than symbols) */\n    least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    /* we can use at most this many bit patterns, lest there not be enough\n       available for the remaining symbols at the maximum length (if there were\n       no limit to the code length, this would become: most = left - 1) */\n    most = (((code_t)left << (max - len)) - syms) /\n            (((code_t)1 << (max - len)) - 1);\n\n    /* count all possible codes from this juncture and add them up */\n    sum = 0;\n    for (use = least; use <= most; use++) {\n        got = count(syms - use, len + 1, (left - use) << 1);\n        sum += got;\n        if (got == (big_t)0 - 1 || sum < got)   /* overflow */\n            return (big_t)0 - 1;\n    }\n\n    /* verify that all recursive calls are productive */\n    assert(sum != 0);\n\n    /* save the result and return it */\n    num[index] = sum;\n    return sum;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/enough.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/enough.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/enough.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/enough.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/enough.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/enough.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/enough.c"
   ]
  }
 ],
 "b672a738f2184ea4047fe93976ec229f8d2a16f12bf4bca0ba7e1787d9df5a70": [
  "local int beenhere(int syms, int len, int left, int mem, int rem)\n{\n    size_t index;       /* index for this state's bit vector */\n    size_t offset;      /* offset in this state's bit vector */\n    int bit;            /* mask for this state's bit */\n    size_t length;      /* length of the bit vector in bytes */\n    char *vector;       /* new or enlarged bit vector */\n\n    /* point to vector for (syms,left,len), bit in vector for (mem,rem) */\n    index = INDEX(syms, left, len);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n\n    /* see if we've been here */\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;       /* done this! */\n\n    /* we haven't been here before -- set the bit to show we have now */\n\n    /* see if we need to lengthen the vector in order to set the bit */\n    if (length <= offset) {\n        /* if we have one already, enlarge it, zero out the appended space */\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != NULL)\n                memset(vector + done[index].len, 0, length - done[index].len);\n        }\n\n        /* otherwise we need to make a new vector and zero it out */\n        else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n\n        /* in either case, bail if we can't get the memory */\n        if (vector == NULL) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n\n        /* install the new vector */\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n\n    /* set the bit */\n    done[index].vec[offset] |= bit;\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/enough.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/enough.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/enough.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/enough.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/enough.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/enough.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/enough.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/enough.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/enough.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/enough.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/enough.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/enough.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/enough.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/enough.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/enough.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/enough.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/enough.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/enough.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/enough.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/enough.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/enough.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/enough.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/enough.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/enough.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/enough.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/enough.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/enough.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/enough.c"
   ]
  }
 ],
 "8f09bbd962b8fb7d8f954634ccdd189da591e2d087a03bef950778ed01c86a35": [
  "local void examine(int syms, int len, int left, int mem, int rem)\n{\n    int least;          /* least number of syms to use at this juncture */\n    int most;           /* most number of syms to use at this juncture */\n    int use;            /* number of bit patterns to use in next call */\n\n    /* see if we have a complete code */\n    if (syms == left) {\n        /* set the last code entry */\n        code[len] = left;\n\n        /* complete computation of memory used by this code */\n        while (rem < left) {\n            left -= rem;\n            rem = 1 << (len - root);\n            mem += rem;\n        }\n        assert(rem == left);\n\n        /* if this is a new maximum, show the entries used and the sub-code */\n        if (mem > large) {\n            large = mem;\n            printf(\"max %d: \", mem);\n            for (use = root + 1; use <= max; use++)\n                if (code[use])\n                    printf(\"%d[%d] \", code[use], use);\n            putchar('\\n');\n            fflush(stdout);\n        }\n\n        /* remove entries as we drop back down in the recursion */\n        code[len] = 0;\n        return;\n    }\n\n    /* prune the tree if we can */\n    if (beenhere(syms, len, left, mem, rem))\n        return;\n\n    /* we need to use at least this many bit patterns so that the code won't be\n       incomplete at the next length (more bit patterns than symbols) */\n    least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    /* we can use at most this many bit patterns, lest there not be enough\n       available for the remaining symbols at the maximum length (if there were\n       no limit to the code length, this would become: most = left - 1) */\n    most = (((code_t)left << (max - len)) - syms) /\n            (((code_t)1 << (max - len)) - 1);\n\n    /* occupy least table spaces, creating new sub-tables as needed */\n    use = least;\n    while (rem < use) {\n        use -= rem;\n        rem = 1 << (len - root);\n        mem += rem;\n    }\n    rem -= use;\n\n    /* examine codes from here, updating table space as we go */\n    for (use = least; use <= most; use++) {\n        code[len] = use;\n        examine(syms - use, len + 1, (left - use) << 1,\n                mem + (rem ? 1 << (len - root) : 0), rem << 1);\n        if (rem == 0) {\n            rem = 1 << (len - root);\n            mem += rem;\n        }\n        rem--;\n    }\n\n    /* remove entries as we drop back down in the recursion */\n    code[len] = 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/enough.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/enough.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/enough.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/enough.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/enough.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/enough.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/enough.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/enough.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/enough.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/enough.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/enough.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/enough.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/enough.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/enough.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/enough.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/enough.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/enough.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/enough.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/enough.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/enough.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/enough.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/enough.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/enough.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/enough.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/enough.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/enough.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/enough.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/enough.c"
   ]
  }
 ],
 "ebabedc07bca7dd68ecb9a32ac184afa1e8306f3b2d3381776e8027c327a6404": [
  "local void enough(int syms)\n{\n    int n;              /* number of remaing symbols for this node */\n    int left;           /* number of unused bit patterns at this length */\n    size_t index;       /* index of this case in *num */\n\n    /* clear code */\n    for (n = 0; n <= max; n++)\n        code[n] = 0;\n\n    /* look at all (root + 1) bit and longer codes */\n    large = 1 << root;              /* base table */\n    if (root < max)                 /* otherwise, there's only a base table */\n        for (n = 3; n <= syms; n++)\n            for (left = 2; left < n; left += 2)\n            {\n                /* look at all reachable (root + 1) bit nodes, and the\n                   resulting codes (complete at root + 2 or more) */\n                index = INDEX(n, left, root + 1);\n                if (root + 1 < max && num[index])       /* reachable node */\n                    examine(n, root + 1, left, 1 << root, 0);\n\n                /* also look at root bit codes with completions at root + 1\n                   bits (not saved in num, since complete), just in case */\n                if (num[index - 1] && n <= left << 1)\n                    examine((n - left) << 1, root + 1, (n - left) << 1,\n                            1 << root, 0);\n            }\n\n    /* done */\n    printf(\"done: maximum of %d table entries\\n\", large);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/enough.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/enough.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/enough.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/enough.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/enough.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/enough.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/enough.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/enough.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/enough.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/enough.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/enough.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/enough.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/enough.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/enough.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/enough.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/enough.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/enough.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/enough.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/enough.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/enough.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/enough.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/enough.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/enough.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/enough.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/enough.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/enough.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/enough.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/enough.c"
   ]
  }
 ],
 "b0a8f6eb2f1d434195db6de50901cc36b464c11c0ba2703b6d3b41b786aaeeb6": [
  "int main(int argc, char **argv)\n{\n    int syms;           /* total number of symbols to code */\n    int n;              /* number of symbols to code for this run */\n    big_t got;          /* return value of count() */\n    big_t sum;          /* accumulated number of codes over n */\n    code_t word;        /* for counting bits in code_t */\n\n    /* set up globals for cleanup() */\n    code = NULL;\n    num = NULL;\n    done = NULL;\n\n    /* get arguments -- default to the deflate literal/length code */\n    syms = 286;\n    root = 9;\n    max = 15;\n    if (argc > 1) {\n        syms = atoi(argv[1]);\n        if (argc > 2) {\n            root = atoi(argv[2]);\n            if (argc > 3)\n                max = atoi(argv[3]);\n        }\n    }\n    if (argc > 4 || syms < 2 || root < 1 || max < 1) {\n        fputs(\"invalid arguments, need: [sym >= 2 [root >= 1 [max >= 1]]]\\n\",\n              stderr);\n        return 1;\n    }\n\n    /* if not restricting the code length, the longest is syms - 1 */\n    if (max > syms - 1)\n        max = syms - 1;\n\n    /* determine the number of bits in a code_t */\n    for (n = 0, word = 1; word; n++, word <<= 1)\n        ;\n\n    /* make sure that the calculation of most will not overflow */\n    if (max > n || (code_t)(syms - 2) >= (((code_t)0 - 1) >> (max - 1))) {\n        fputs(\"abort: code length too long for internal types\\n\", stderr);\n        return 1;\n    }\n\n    /* reject impossible code requests */\n    if ((code_t)(syms - 1) > ((code_t)1 << max) - 1) {\n        fprintf(stderr, \"%d symbols cannot be coded in %d bits\\n\",\n                syms, max);\n        return 1;\n    }\n\n    /* allocate code vector */\n    code = calloc(max + 1, sizeof(int));\n    if (code == NULL) {\n        fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n        return 1;\n    }\n\n    /* determine size of saved results array, checking for overflows,\n       allocate and clear the array (set all to zero with calloc()) */\n    if (syms == 2)              /* iff max == 1 */\n        num = NULL;             /* won't be saving any results */\n    else {\n        size = syms >> 1;\n        if (size > ((size_t)0 - 1) / (n = (syms - 1) >> 1) ||\n                (size *= n, size > ((size_t)0 - 1) / (n = max - 1)) ||\n                (size *= n, size > ((size_t)0 - 1) / sizeof(big_t)) ||\n                (num = calloc(size, sizeof(big_t))) == NULL) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            return 1;\n        }\n    }\n\n    /* count possible codes for all numbers of symbols, add up counts */\n    sum = 0;\n    for (n = 2; n <= syms; n++) {\n        got = count(n, 1, 2);\n        sum += got;\n        if (got == (big_t)0 - 1 || sum < got) {     /* overflow */\n            fputs(\"abort: can't count that high!\\n\", stderr);\n            cleanup();\n            return 1;\n        }\n        printf(\"%llu %d-codes\\n\", got, n);\n    }\n    printf(\"%llu total codes for 2 to %d symbols\", sum, syms);\n    if (max < syms - 1)\n        printf(\" (%d-bit length limit)\\n\", max);\n    else\n        puts(\" (no length limit)\");\n\n    /* allocate and clear done array for beenhere() */\n    if (syms == 2)\n        done = NULL;\n    else if (size > ((size_t)0 - 1) / sizeof(struct tab) ||\n             (done = calloc(size, sizeof(struct tab))) == NULL) {\n        fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n        cleanup();\n        return 1;\n    }\n\n    /* find and show maximum inflate table usage */\n    if (root > max)                 /* reduce root to max length */\n        root = max;\n    if ((code_t)syms < ((code_t)1 << (root + 1)))\n        enough(syms);\n    else\n        puts(\"cannot handle minimum code lengths > root\");\n\n    /* done */\n    cleanup();\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/enough.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/enough.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/enough.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/enough.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/enough.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/enough.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/enough.c"
   ]
  }
 ],
 "326bfdfff549bf0c4e50045f1f3a794dd03e204fd3065d0776ffd0b6c92093a4": [
  "int def(FILE *source, FILE *dest, int level)\n{\n    int ret, flush;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    /* allocate deflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = deflateInit(&strm, level);\n    if (ret != Z_OK)\n        return ret;\n\n    /* compress until end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)deflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n        strm.next_in = in;\n\n        /* run deflate() on input until output buffer not full, finish\n           compression if all of source has been read in */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = deflate(&strm, flush);    /* no bad return value */\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)deflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);     /* all input will be used */\n\n        /* done when last data in file processed */\n    } while (flush != Z_FINISH);\n    assert(ret == Z_STREAM_END);        /* stream will be complete */\n\n    /* clean up and return */\n    (void)deflateEnd(&strm);\n    return Z_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zpipe.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zpipe.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zpipe.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zpipe.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zpipe.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zpipe.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zpipe.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zpipe.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zpipe.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zpipe.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zpipe.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zpipe.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zpipe.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zpipe.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zpipe.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zpipe.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zpipe.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zpipe.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zpipe.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zpipe.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zpipe.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zpipe.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zpipe.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zpipe.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zpipe.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zpipe.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zpipe.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zpipe.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zpipe.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zpipe.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zpipe.c"
   ]
  }
 ],
 "97f434b4de0d13b5f4299ab3d0e8b9472bf6aaad69e14059ad12bedf1bbc3f76": [
  "int inf(FILE *source, FILE *dest)\n{\n    int ret;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    /* allocate inflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);\n    if (ret != Z_OK)\n        return ret;\n\n    /* decompress until deflate stream ends or end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)inflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        if (strm.avail_in == 0)\n            break;\n        strm.next_in = in;\n\n        /* run inflate() on input until output buffer not full */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = inflate(&strm, Z_NO_FLUSH);\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            switch (ret) {\n            case Z_NEED_DICT:\n                ret = Z_DATA_ERROR;     /* and fall through */\n            case Z_DATA_ERROR:\n            case Z_MEM_ERROR:\n                (void)inflateEnd(&strm);\n                return ret;\n            }\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)inflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n\n        /* done when inflate() says it's done */\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return */\n    (void)inflateEnd(&strm);\n    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zpipe.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zpipe.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zpipe.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zpipe.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zpipe.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zpipe.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zpipe.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zpipe.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zpipe.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zpipe.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zpipe.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zpipe.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zpipe.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zpipe.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zpipe.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zpipe.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zpipe.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zpipe.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zpipe.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zpipe.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zpipe.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zpipe.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zpipe.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zpipe.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zpipe.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zpipe.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zpipe.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zpipe.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zpipe.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zpipe.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zpipe.c"
   ]
  }
 ],
 "8c6c4cf21a75f4ddc2acfd9ecaac0144546112a0fa383274f835ef8486f28b79": [
  "void zerr(int ret)\n{\n    fputs(\"zpipe: \", stderr);\n    switch (ret) {\n    case Z_ERRNO:\n        if (ferror(stdin))\n            fputs(\"error reading stdin\\n\", stderr);\n        if (ferror(stdout))\n            fputs(\"error writing stdout\\n\", stderr);\n        break;\n    case Z_STREAM_ERROR:\n        fputs(\"invalid compression level\\n\", stderr);\n        break;\n    case Z_DATA_ERROR:\n        fputs(\"invalid or incomplete deflate data\\n\", stderr);\n        break;\n    case Z_MEM_ERROR:\n        fputs(\"out of memory\\n\", stderr);\n        break;\n    case Z_VERSION_ERROR:\n        fputs(\"zlib version mismatch!\\n\", stderr);\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zpipe.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zpipe.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zpipe.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zpipe.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/zpipe.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/zpipe.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zpipe.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zpipe.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zpipe.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zpipe.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zpipe.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zpipe.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zpipe.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zpipe.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zpipe.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zpipe.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zpipe.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zpipe.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zpipe.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zpipe.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zpipe.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zpipe.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zpipe.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zpipe.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zpipe.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zpipe.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zpipe.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zpipe.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zpipe.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zpipe.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zpipe.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zpipe.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zpipe.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zpipe.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zpipe.c"
   ]
  }
 ],
 "878333e3dae900e3ae954740942330c63d911c618d665205324a5759a4f1e4ef": [
  "int main(int argc, char **argv)\n{\n    int ret;\n\n    /* avoid end-of-line conversions */\n    SET_BINARY_MODE(stdin);\n    SET_BINARY_MODE(stdout);\n\n    /* do compression if no arguments */\n    if (argc == 1) {\n        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* do decompression if -d specified */\n    else if (argc == 2 && strcmp(argv[1], \"-d\") == 0) {\n        ret = inf(stdin, stdout);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* otherwise, report usage */\n    else {\n        fputs(\"zpipe usage: zpipe [-d] < source > dest\\n\", stderr);\n        return 1;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zpipe.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zpipe.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zpipe.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zpipe.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zpipe.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zpipe.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zpipe.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zpipe.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zpipe.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zpipe.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zpipe.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zpipe.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zpipe.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zpipe.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zpipe.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zpipe.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zpipe.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zpipe.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zpipe.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zpipe.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zpipe.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zpipe.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zpipe.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zpipe.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zpipe.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zpipe.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zpipe.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zpipe.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zpipe.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zpipe.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zpipe.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zpipe.c"
   ]
  }
 ],
 "48e63af000386053668df4497958f18200b69531345da2e0b5e0eac7e0cb1cde": [
  "local void quit(char *why)\n{\n    fprintf(stderr, \"fitblk abort: %s\\n\", why);\n    exit(1);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/fitblk.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/fitblk.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/fitblk.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/fitblk.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/fitblk.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/fitblk.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/fitblk.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/fitblk.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/fitblk.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/fitblk.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/fitblk.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/fitblk.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/fitblk.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/fitblk.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/fitblk.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/fitblk.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/fitblk.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/fitblk.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/fitblk.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/fitblk.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/fitblk.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/fitblk.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/fitblk.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/fitblk.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/fitblk.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/fitblk.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/fitblk.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/fitblk.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/fitblk.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/fitblk.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/fitblk.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/fitblk.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/fitblk.c"
   ]
  }
 ],
 "7c619a7da713203cd8d1546218b92bfcca70b96e79d1ea03aa019b9c470e15f4": [
  "local int partcompress(FILE *in, z_streamp def)\n{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        def->avail_in = fread(raw, 1, RAWLEN, in);\n        if (ferror(in))\n            return Z_ERRNO;\n        def->next_in = raw;\n        if (feof(in))\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (def->avail_out != 0 && flush == Z_NO_FLUSH);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/fitblk.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/fitblk.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/fitblk.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/fitblk.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/fitblk.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/fitblk.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/fitblk.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/fitblk.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/fitblk.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/fitblk.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/fitblk.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/fitblk.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/fitblk.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/fitblk.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/fitblk.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/fitblk.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/fitblk.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/fitblk.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/fitblk.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/fitblk.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/fitblk.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/fitblk.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/fitblk.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/fitblk.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/fitblk.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/fitblk.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/fitblk.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/fitblk.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/fitblk.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/fitblk.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/fitblk.c"
   ]
  }
 ],
 "3c996b7825896e60b0d612600b1f2bbed42a2b9a9262f7d66aec99bd2de08011": [
  "local int recompress(z_streamp inf, z_streamp def)\n{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        /* decompress */\n        inf->avail_out = RAWLEN;\n        inf->next_out = raw;\n        ret = inflate(inf, Z_NO_FLUSH);\n        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&\n               ret != Z_NEED_DICT);\n        if (ret == Z_MEM_ERROR)\n            return ret;\n\n        /* compress what was decompresed until done or no room */\n        def->avail_in = RAWLEN - inf->avail_out;\n        def->next_in = raw;\n        if (inf->avail_out != 0)\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (ret != Z_STREAM_END && def->avail_out != 0);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/fitblk.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/fitblk.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/fitblk.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/fitblk.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/fitblk.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/fitblk.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/fitblk.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/fitblk.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/fitblk.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/fitblk.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/fitblk.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/fitblk.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/fitblk.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/fitblk.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/fitblk.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/fitblk.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/fitblk.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/fitblk.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/fitblk.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/fitblk.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/fitblk.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/fitblk.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/fitblk.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/fitblk.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/fitblk.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/fitblk.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/fitblk.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/fitblk.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/fitblk.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/fitblk.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/fitblk.c"
   ]
  }
 ],
 "2cbf93162c423f7931f2e1d8265d373c75dca8043efafa458de9b25d60e9a7d8": [
  "int main(int argc, char **argv)\n{\n    int ret;                /* return code */\n    unsigned size;          /* requested fixed output block size */\n    unsigned have;          /* bytes written by deflate() call */\n    unsigned char *blk;     /* intermediate and final stream */\n    unsigned char *tmp;     /* close to desired size stream */\n    z_stream def, inf;      /* zlib deflate and inflate states */\n\n    /* get requested output size */\n    if (argc != 2)\n        quit(\"need one argument: size of output block\");\n    ret = strtol(argv[1], argv + 1, 10);\n    if (argv[1][0] != 0)\n        quit(\"argument must be a number\");\n    if (ret < 8)            /* 8 is minimum zlib stream size */\n        quit(\"need positive size of 8 or greater\");\n    size = (unsigned)ret;\n\n    /* allocate memory for buffers and compression engine */\n    blk = malloc(size + EXCESS);\n    def.zalloc = Z_NULL;\n    def.zfree = Z_NULL;\n    def.opaque = Z_NULL;\n    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);\n    if (ret != Z_OK || blk == NULL)\n        quit(\"out of memory\");\n\n    /* compress from stdin until output full, or no more input */\n    def.avail_out = size + EXCESS;\n    def.next_out = blk;\n    ret = partcompress(stdin, &def);\n    if (ret == Z_ERRNO)\n        quit(\"error reading input\");\n\n    /* if it all fit, then size was undersubscribed -- done! */\n    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {\n        /* write block to stdout */\n        have = size + EXCESS - def.avail_out;\n        if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n            quit(\"error writing output\");\n\n        /* clean up and print results to stderr */\n        ret = deflateEnd(&def);\n        assert(ret != Z_STREAM_ERROR);\n        free(blk);\n        fprintf(stderr,\n                \"%u bytes unused out of %u requested (all input)\\n\",\n                size - have, size);\n        return 0;\n    }\n\n    /* it didn't all fit -- set up for recompression */\n    inf.zalloc = Z_NULL;\n    inf.zfree = Z_NULL;\n    inf.opaque = Z_NULL;\n    inf.avail_in = 0;\n    inf.next_in = Z_NULL;\n    ret = inflateInit(&inf);\n    tmp = malloc(size + EXCESS);\n    if (ret != Z_OK || tmp == NULL)\n        quit(\"out of memory\");\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do first recompression close to the right amount */\n    inf.avail_in = size + EXCESS;\n    inf.next_in = blk;\n    def.avail_out = size + EXCESS;\n    def.next_out = tmp;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n\n    /* set up for next reocmpression */\n    ret = inflateReset(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do second and final recompression (third compression) */\n    inf.avail_in = size - MARGIN;   /* assure stream will complete */\n    inf.next_in = tmp;\n    def.avail_out = size;\n    def.next_out = blk;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */\n\n    /* done -- write block to stdout */\n    have = size - def.avail_out;\n    if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n        quit(\"error writing output\");\n\n    /* clean up and print results to stderr */\n    free(tmp);\n    ret = inflateEnd(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateEnd(&def);\n    assert(ret != Z_STREAM_ERROR);\n    free(blk);\n    fprintf(stderr,\n            \"%u bytes unused out of %u requested (%lu input)\\n\",\n            size - have, size, def.total_in);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/fitblk.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/fitblk.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/fitblk.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/fitblk.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/fitblk.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/fitblk.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/fitblk.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/fitblk.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/fitblk.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/fitblk.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/fitblk.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/fitblk.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/fitblk.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/fitblk.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/fitblk.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/fitblk.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/fitblk.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/fitblk.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/fitblk.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/fitblk.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/fitblk.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/fitblk.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/fitblk.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/fitblk.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/fitblk.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/fitblk.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/fitblk.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/fitblk.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/fitblk.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/fitblk.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/fitblk.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/fitblk.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/fitblk.c"
   ]
  }
 ],
 "de64d0449fd5dda17a92ae14187c497194b3f0245bdd851fabb9ee859c4a846d": [
  "local unsigned in(void *in_desc, z_const unsigned char **buf)\n{\n    int ret;\n    unsigned len;\n    unsigned char *next;\n    struct ind *me = (struct ind *)in_desc;\n\n    next = me->inbuf;\n    *buf = next;\n    len = 0;\n    do {\n        ret = PIECE;\n        if ((unsigned)ret > SIZE - len)\n            ret = (int)(SIZE - len);\n        ret = (int)read(me->infile, next, ret);\n        if (ret == -1) {\n            len = 0;\n            break;\n        }\n        next += ret;\n        len += ret;\n    } while (ret != 0 && len < SIZE);\n    return len;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gun.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gun.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gun.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gun.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gun.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gun.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gun.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gun.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gun.c"
   ]
  }
 ],
 "ca504057460315237e24a547ad50609046c62f24adda2422155f081ec9c77eb5": [
  "local int out(void *out_desc, unsigned char *buf, unsigned len)\n{\n    int ret;\n    struct outd *me = (struct outd *)out_desc;\n\n    if (me->check) {\n        me->crc = crc32(me->crc, buf, len);\n        me->total += len;\n    }\n    if (me->outfile != -1)\n        do {\n            ret = PIECE;\n            if ((unsigned)ret > len)\n                ret = (int)len;\n            ret = (int)write(me->outfile, buf, ret);\n            if (ret == -1)\n                return 1;\n            buf += ret;\n            len -= ret;\n        } while (len != 0);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gun.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gun.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gun.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gun.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gun.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gun.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gun.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gun.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gun.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gun.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gun.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gun.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gun.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gun.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gun.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gun.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gun.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gun.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gun.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gun.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gun.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gun.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gun.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gun.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gun.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gun.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gun.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gun.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gun.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gun.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gun.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gun.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gun.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gun.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gun.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gun.c"
   ]
  }
 ],
 "2930b305855b05149dd21514d4bab5a2b05a63755e1b6e54a67ee3fe1adf6616": [
  "local int lunpipe(unsigned have, z_const unsigned char *next, struct ind *indp,\n                  int outfile, z_stream *strm)\n{\n    int last;                   /* last byte read by NEXT(), or -1 if EOF */\n    unsigned chunk;             /* bytes left in current chunk */\n    int left;                   /* bits left in rem */\n    unsigned rem;               /* unused bits from input */\n    int bits;                   /* current bits per code */\n    unsigned code;              /* code, table traversal index */\n    unsigned mask;              /* mask for current bits codes */\n    int max;                    /* maximum bits per code for this stream */\n    unsigned flags;             /* compress flags, then block compress flag */\n    unsigned end;               /* last valid entry in prefix/suffix tables */\n    unsigned temp;              /* current code */\n    unsigned prev;              /* previous code */\n    unsigned final;             /* last character written for previous code */\n    unsigned stack;             /* next position for reversed string */\n    unsigned outcnt;            /* bytes in output buffer */\n    struct outd outd;           /* output structure */\n    unsigned char *p;\n\n    /* set up output */\n    outd.outfile = outfile;\n    outd.check = 0;\n\n    /* process remainder of compress header -- a flags byte */\n    flags = NEXT();\n    if (last == -1)\n        return Z_BUF_ERROR;\n    if (flags & 0x60) {\n        strm->msg = (char *)\"unknown lzw flags set\";\n        return Z_DATA_ERROR;\n    }\n    max = flags & 0x1f;\n    if (max < 9 || max > 16) {\n        strm->msg = (char *)\"lzw bits out of range\";\n        return Z_DATA_ERROR;\n    }\n    if (max == 9)                           /* 9 doesn't really mean 9 */\n        max = 10;\n    flags &= 0x80;                          /* true if block compress */\n\n    /* clear table */\n    bits = 9;\n    mask = 0x1ff;\n    end = flags ? 256 : 255;\n\n    /* set up: get first 9-bit code, which is the first decompressed byte, but\n       don't create a table entry until the next code */\n    if (NEXT() == -1)                       /* no compressed data is ok */\n        return Z_OK;\n    final = prev = (unsigned)last;          /* low 8 bits of code */\n    if (NEXT() == -1)                       /* missing a bit */\n        return Z_BUF_ERROR;\n    if (last & 1) {                         /* code must be < 256 */\n        strm->msg = (char *)\"invalid lzw code\";\n        return Z_DATA_ERROR;\n    }\n    rem = (unsigned)last >> 1;              /* remaining 7 bits */\n    left = 7;\n    chunk = bits - 2;                       /* 7 bytes left in this chunk */\n    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */\n    outcnt = 1;\n\n    /* decode codes */\n    stack = 0;\n    for (;;) {\n        /* if the table will be full after this, increment the code size */\n        if (end >= mask && bits < max) {\n            FLUSHCODE();\n            bits++;\n            mask <<= 1;\n            mask++;\n        }\n\n        /* get a code of length bits */\n        if (chunk == 0)                     /* decrement chunk modulo bits */\n            chunk = bits;\n        code = rem;                         /* low bits of code */\n        if (NEXT() == -1) {                 /* EOF is end of compressed data */\n            /* write remaining buffered output */\n            if (outcnt && out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf;     /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            return Z_OK;\n        }\n        code += (unsigned)last << left;     /* middle (or high) bits of code */\n        left += 8;\n        chunk--;\n        if (bits > left) {                  /* need more bits */\n            if (NEXT() == -1)               /* can't end in middle of code */\n                return Z_BUF_ERROR;\n            code += (unsigned)last << left; /* high bits of code */\n            left += 8;\n            chunk--;\n        }\n        code &= mask;                       /* mask to current code length */\n        left -= bits;                       /* number of unused bits */\n        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */\n\n        /* process clear code (256) */\n        if (code == 256 && flags) {\n            FLUSHCODE();\n            bits = 9;                       /* initialize bits and mask */\n            mask = 0x1ff;\n            end = 255;                      /* empty table */\n            continue;                       /* get next code */\n        }\n\n        /* special code to reuse last match */\n        temp = code;                        /* save the current code */\n        if (code > end) {\n            /* Be picky on the allowed code here, and make sure that the code\n               we drop through (prev) will be a valid index so that random\n               input does not cause an exception.  The code != end + 1 check is\n               empirically derived, and not checked in the original uncompress\n               code.  If this ever causes a problem, that check could be safely\n               removed.  Leaving this check in greatly improves gun's ability\n               to detect random or corrupted input after a compress header.\n               In any case, the prev > end check must be retained. */\n            if (code != end + 1 || prev > end) {\n                strm->msg = (char *)\"invalid lzw code\";\n                return Z_DATA_ERROR;\n            }\n            match[stack++] = (unsigned char)final;\n            code = prev;\n        }\n\n        /* walk through linked list to generate output in reverse order */\n        p = match + stack;\n        while (code >= 256) {\n            *p++ = suffix[code];\n            code = prefix[code];\n        }\n        stack = p - match;\n        match[stack++] = (unsigned char)code;\n        final = code;\n\n        /* link new table entry */\n        if (end < mask) {\n            end++;\n            prefix[end] = (unsigned short)prev;\n            suffix[end] = (unsigned char)final;\n        }\n\n        /* set previous code for next iteration */\n        prev = temp;\n\n        /* write output in forward order */\n        while (stack > SIZE - outcnt) {\n            while (outcnt < SIZE)\n                outbuf[outcnt++] = match[--stack];\n            if (out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf; /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            outcnt = 0;\n        }\n        p = match + stack;\n        do {\n            outbuf[outcnt++] = *--p;\n        } while (p > match);\n        stack = 0;\n\n        /* loop for next code with final and prev as the last match, rem and\n           left provide the first 0..7 bits of the next code, end is the last\n           valid table entry */\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gun.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gun.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gun.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gun.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gun.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gun.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gun.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gun.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gun.c"
   ]
  }
 ],
 "807725361f5d2d5ce7361310d36bed9c1998a36f9a31910f203e3a3dfde3270a": [
  "local int gunpipe(z_stream *strm, int infile, int outfile)\n{\n    int ret, first, last;\n    unsigned have, flags, len;\n    z_const unsigned char *next = NULL;\n    struct ind ind, *indp;\n    struct outd outd;\n\n    /* setup input buffer */\n    ind.infile = infile;\n    ind.inbuf = inbuf;\n    indp = &ind;\n\n    /* decompress concatenated gzip streams */\n    have = 0;                               /* no input data read in yet */\n    first = 1;                              /* looking for first gzip header */\n    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */\n    for (;;) {\n        /* look for the two magic header bytes for a gzip stream */\n        if (NEXT() == -1) {\n            ret = Z_OK;\n            break;                          /* empty gzip stream is ok */\n        }\n        if (last != 31 || (NEXT() != 139 && last != 157)) {\n            strm->msg = (char *)\"incorrect header check\";\n            ret = first ? Z_DATA_ERROR : Z_ERRNO;\n            break;                          /* not a gzip or compress header */\n        }\n        first = 0;                          /* next non-header is junk */\n\n        /* process a compress (LZW) file -- can't be concatenated after this */\n        if (last == 157) {\n            ret = lunpipe(have, next, indp, outfile, strm);\n            break;\n        }\n\n        /* process remainder of gzip header */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != 8) {                  /* only deflate method allowed */\n            if (last == -1) break;\n            strm->msg = (char *)\"unknown compression method\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        flags = NEXT();                     /* header flags */\n        NEXT();                             /* discard mod time, xflgs, os */\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        if (last == -1) break;\n        if (flags & 0xe0) {\n            strm->msg = (char *)\"unknown header flags set\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        if (flags & 4) {                    /* extra field */\n            len = NEXT();\n            len += (unsigned)(NEXT()) << 8;\n            if (last == -1) break;\n            while (len > have) {\n                len -= have;\n                have = 0;\n                if (NEXT() == -1) break;\n                len--;\n            }\n            if (last == -1) break;\n            have -= len;\n            next += len;\n        }\n        if (flags & 8)                      /* file name */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 16)                     /* comment */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 2) {                    /* header crc */\n            NEXT();\n            NEXT();\n        }\n        if (last == -1) break;\n\n        /* set up output */\n        outd.outfile = outfile;\n        outd.check = 1;\n        outd.crc = crc32(0L, Z_NULL, 0);\n        outd.total = 0;\n\n        /* decompress data to output */\n        strm->next_in = next;\n        strm->avail_in = have;\n        ret = inflateBack(strm, in, indp, out, &outd);\n        if (ret != Z_STREAM_END) break;\n        next = strm->next_in;\n        have = strm->avail_in;\n        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */\n\n        /* check trailer */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != (int)(outd.crc & 0xff) ||\n            NEXT() != (int)((outd.crc >> 8) & 0xff) ||\n            NEXT() != (int)((outd.crc >> 16) & 0xff) ||\n            NEXT() != (int)((outd.crc >> 24) & 0xff)) {\n            /* crc error */\n            if (last != -1) {\n                strm->msg = (char *)\"incorrect data check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n        if (NEXT() != (int)(outd.total & 0xff) ||\n            NEXT() != (int)((outd.total >> 8) & 0xff) ||\n            NEXT() != (int)((outd.total >> 16) & 0xff) ||\n            NEXT() != (int)((outd.total >> 24) & 0xff)) {\n            /* length error */\n            if (last != -1) {\n                strm->msg = (char *)\"incorrect length check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n\n        /* go back and look for another gzip stream */\n    }\n\n    /* clean up and return */\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gun.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gun.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gun.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gun.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gun.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gun.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gun.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gun.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gun.c"
   ]
  }
 ],
 "cf7941d0a16cfcf7585507889b7279e8414d0c408845f5e48399e98cb08613e6": [
  "local void copymeta(char *from, char *to)\n{\n    struct stat was;\n    struct utimbuf when;\n\n    /* get all of from's Unix meta data, return if not a regular file */\n    if (stat(from, &was) != 0 || (was.st_mode & S_IFMT) != S_IFREG)\n        return;\n\n    /* set to's mode bits, ignore errors */\n    (void)chmod(to, was.st_mode & 07777);\n\n    /* copy owner's user and group, ignore errors */\n    (void)chown(to, was.st_uid, was.st_gid);\n\n    /* copy access and modify times, ignore errors */\n    when.actime = was.st_atime;\n    when.modtime = was.st_mtime;\n    (void)utime(to, &when);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gun.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gun.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gun.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gun.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gun.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gun.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gun.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gun.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gun.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gun.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gun.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gun.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gun.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gun.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gun.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gun.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gun.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gun.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gun.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gun.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gun.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gun.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gun.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gun.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gun.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gun.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gun.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gun.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gun.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gun.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gun.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gun.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gun.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gun.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gun.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gun.c"
   ]
  }
 ],
 "8d5965c73f1ccab4213d131a70a21f1f15ff2d9dd9bc4d0fbc4ff0fa54b20ed7": [
  "local int gunzip(z_stream *strm, char *inname, char *outname, int test)\n{\n    int ret;\n    int infile, outfile;\n\n    /* open files */\n    if (inname == NULL || *inname == 0) {\n        inname = \"-\";\n        infile = 0;     /* stdin */\n    }\n    else {\n        infile = open(inname, O_RDONLY, 0);\n        if (infile == -1) {\n            fprintf(stderr, \"gun cannot open %s\\n\", inname);\n            return 0;\n        }\n    }\n    if (test)\n        outfile = -1;\n    else if (outname == NULL || *outname == 0) {\n        outname = \"-\";\n        outfile = 1;    /* stdout */\n    }\n    else {\n        outfile = open(outname, O_CREAT | O_TRUNC | O_WRONLY, 0666);\n        if (outfile == -1) {\n            close(infile);\n            fprintf(stderr, \"gun cannot create %s\\n\", outname);\n            return 0;\n        }\n    }\n    errno = 0;\n\n    /* decompress */\n    ret = gunpipe(strm, infile, outfile);\n    if (outfile > 2) close(outfile);\n    if (infile > 2) close(infile);\n\n    /* interpret result */\n    switch (ret) {\n    case Z_OK:\n    case Z_ERRNO:\n        if (infile > 2 && outfile > 2) {\n            copymeta(inname, outname);          /* copy attributes */\n            unlink(inname);\n        }\n        if (ret == Z_ERRNO)\n            fprintf(stderr, \"gun warning: trailing garbage ignored in %s\\n\",\n                    inname);\n        break;\n    case Z_DATA_ERROR:\n        if (outfile > 2) unlink(outname);\n        fprintf(stderr, \"gun data error on %s: %s\\n\", inname, strm->msg);\n        break;\n    case Z_MEM_ERROR:\n        if (outfile > 2) unlink(outname);\n        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n        return 1;\n    case Z_BUF_ERROR:\n        if (outfile > 2) unlink(outname);\n        if (strm->next_in != Z_NULL) {\n            fprintf(stderr, \"gun write error on %s: %s\\n\",\n                    outname, strerror(errno));\n        }\n        else if (errno) {\n            fprintf(stderr, \"gun read error on %s: %s\\n\",\n                    inname, strerror(errno));\n        }\n        else {\n            fprintf(stderr, \"gun unexpected end of file on %s\\n\",\n                    inname);\n        }\n        break;\n    default:\n        if (outfile > 2) unlink(outname);\n        fprintf(stderr, \"gun internal error--aborting\\n\");\n        return 1;\n    }\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gun.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gun.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gun.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gun.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gun.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gun.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gun.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gun.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gun.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gun.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gun.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gun.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gun.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gun.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gun.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gun.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gun.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gun.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gun.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gun.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gun.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gun.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gun.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gun.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gun.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gun.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gun.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gun.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gun.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gun.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gun.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gun.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gun.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gun.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gun.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gun.c"
   ]
  }
 ],
 "b1a0f1631289411698b1630c29c485c3de53c6a16a69a29ffb3a6bf4ac665499": [
  "int main(int argc, char **argv)\n{\n    int ret, len, test;\n    char *outname;\n    unsigned char *window;\n    z_stream strm;\n\n    /* initialize inflateBack state for repeated use */\n    window = match;                         /* reuse LZW match buffer */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = inflateBackInit(&strm, 15, window);\n    if (ret != Z_OK) {\n        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n        return 1;\n    }\n\n    /* decompress each file to the same name with the suffix removed */\n    argc--;\n    argv++;\n    test = 0;\n    if (argc && strcmp(*argv, \"-h\") == 0) {\n        fprintf(stderr, \"gun 1.6 (17 Jan 2010)\\n\");\n        fprintf(stderr, \"Copyright (C) 2003-2010 Mark Adler\\n\");\n        fprintf(stderr, \"usage: gun [-t] [file1.gz [file2.Z ...]]\\n\");\n        return 0;\n    }\n    if (argc && strcmp(*argv, \"-t\") == 0) {\n        test = 1;\n        argc--;\n        argv++;\n    }\n    if (argc)\n        do {\n            if (test)\n                outname = NULL;\n            else {\n                len = (int)strlen(*argv);\n                if (strcmp(*argv + len - 3, \".gz\") == 0 ||\n                    strcmp(*argv + len - 3, \"-gz\") == 0)\n                    len -= 3;\n                else if (strcmp(*argv + len - 2, \".z\") == 0 ||\n                    strcmp(*argv + len - 2, \"-z\") == 0 ||\n                    strcmp(*argv + len - 2, \"_z\") == 0 ||\n                    strcmp(*argv + len - 2, \".Z\") == 0)\n                    len -= 2;\n                else {\n                    fprintf(stderr, \"gun error: no gz type on %s--skipping\\n\",\n                            *argv);\n                    continue;\n                }\n                outname = malloc(len + 1);\n                if (outname == NULL) {\n                    fprintf(stderr, \"gun out of memory error--aborting\\n\");\n                    ret = 1;\n                    break;\n                }\n                memcpy(outname, *argv, len);\n                outname[len] = 0;\n            }\n            ret = gunzip(&strm, *argv, outname, test);\n            if (outname != NULL) free(outname);\n            if (ret) break;\n        } while (argv++, --argc);\n    else\n        ret = gunzip(&strm, NULL, NULL, test);\n\n    /* clean up */\n    inflateBackEnd(&strm);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gun.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gun.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gun.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gun.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gun.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gun.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gun.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gun.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gun.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gun.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gun.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gun.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gun.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gun.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gun.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gun.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gun.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gun.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gun.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gun.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gun.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gun.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gun.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gun.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gun.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gun.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gun.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gun.c"
   ]
  }
 ],
 "3927f0b1fd8ea4c3f675c3ee634c16e01e4f1f69541c710e6a24458cbd8b16bb": [
  "local void free_index(struct access *index)\n{\n    if (index != NULL) {\n        free(index->list);\n        free(index);\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zran.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zran.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zran.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zran.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zran.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zran.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zran.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zran.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zran.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zran.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zran.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zran.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zran.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zran.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zran.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zran.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zran.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zran.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zran.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zran.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zran.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zran.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zran.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zran.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zran.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zran.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zran.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zran.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zran.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zran.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zran.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zran.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zran.c"
   ]
  }
 ],
 "3403c438f8baf6f16a156f48a323a0c482a507e9a076e8dcb7c7b462b48b65f1": [
  "access *addpoint(struct access *index, int bits,\n    off_t in, off_t out, unsigned left, unsigned char *window)\n{\n    struct point *next;\n\n    /* if list is empty, create it (start with eight points) */\n    if (index == NULL) {\n        index = malloc(sizeof(struct access));\n        if (index == NULL) return NULL;\n        index->list = malloc(sizeof(struct point) << 3);\n        if (index->list == NULL) {\n            free(index);\n            return NULL;\n        }\n        index->size = 8;\n        index->have = 0;\n    }\n\n    /* if list is full, make it bigger */\n    else if (index->have == index->size) {\n        index->size <<= 1;\n        next = realloc(index->list, sizeof(struct point) * index->size);\n        if (next == NULL) {\n            free_index(index);\n            return NULL;\n        }\n        index->list = next;\n    }\n\n    /* fill in entry and increment how many we have */\n    next = index->list + index->have;\n    next->bits = bits;\n    next->in = in;\n    next->out = out;\n    if (left)\n        memcpy(next->window, window + WINSIZE - left, left);\n    if (left < WINSIZE)\n        memcpy(next->window + left, window, WINSIZE - left);\n    index->have++;\n\n    /* return list, possibly reallocated */\n    return index;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zran.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zran.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zran.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zran.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zran.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zran.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zran.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zran.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zran.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zran.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zran.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zran.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zran.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zran.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zran.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zran.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zran.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zran.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zran.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zran.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zran.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zran.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zran.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zran.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zran.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zran.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zran.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zran.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zran.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zran.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zran.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zran.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zran.c"
   ]
  }
 ],
 "1cff973002844b676250b3b0d10b3cb4578c0cf9d39d81409ad276bdb736ed8d": [
  "local int build_index(FILE *in, off_t span, struct access **built)\n{\n    int ret;\n    off_t totin, totout;        /* our own total counters to avoid 4GB limit */\n    off_t last;                 /* totout value of last access point */\n    struct access *index;       /* access points being generated */\n    z_stream strm;\n    unsigned char input[CHUNK];\n    unsigned char window[WINSIZE];\n\n    /* initialize inflate */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, 47);      /* automatic zlib or gzip decoding */\n    if (ret != Z_OK)\n        return ret;\n\n    /* inflate the input, maintain a sliding window, and build an index -- this\n       also validates the integrity of the compressed data using the check\n       information at the end of the gzip or zlib stream */\n    totin = totout = last = 0;\n    index = NULL;               /* will be allocated by first addpoint() */\n    strm.avail_out = 0;\n    do {\n        /* get some compressed data from input file */\n        strm.avail_in = fread(input, 1, CHUNK, in);\n        if (ferror(in)) {\n            ret = Z_ERRNO;\n            goto build_index_error;\n        }\n        if (strm.avail_in == 0) {\n            ret = Z_DATA_ERROR;\n            goto build_index_error;\n        }\n        strm.next_in = input;\n\n        /* process all of that, or until end of stream */\n        do {\n            /* reset sliding window if necessary */\n            if (strm.avail_out == 0) {\n                strm.avail_out = WINSIZE;\n                strm.next_out = window;\n            }\n\n            /* inflate until out of input, output, or at end of block --\n               update the total input and output counters */\n            totin += strm.avail_in;\n            totout += strm.avail_out;\n            ret = inflate(&strm, Z_BLOCK);      /* return at end of block */\n            totin -= strm.avail_in;\n            totout -= strm.avail_out;\n            if (ret == Z_NEED_DICT)\n                ret = Z_DATA_ERROR;\n            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n                goto build_index_error;\n            if (ret == Z_STREAM_END)\n                break;\n\n            /* if at end of block, consider adding an index entry (note that if\n               data_type indicates an end-of-block, then all of the\n               uncompressed data from that block has been delivered, and none\n               of the compressed data after that block has been consumed,\n               except for up to seven bits) -- the totout == 0 provides an\n               entry point after the zlib or gzip header, and assures that the\n               index always has at least one access point; we avoid creating an\n               access point after the last block by checking bit 6 of data_type\n             */\n            if ((strm.data_type & 128) && !(strm.data_type & 64) &&\n                (totout == 0 || totout - last > span)) {\n                index = addpoint(index, strm.data_type & 7, totin,\n                                 totout, strm.avail_out, window);\n                if (index == NULL) {\n                    ret = Z_MEM_ERROR;\n                    goto build_index_error;\n                }\n                last = totout;\n            }\n        } while (strm.avail_in != 0);\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return index (release unused entries in list) */\n    (void)inflateEnd(&strm);\n    index->list = realloc(index->list, sizeof(struct point) * index->have);\n    index->size = index->have;\n    *built = index;\n    return index->size;\n\n    /* return error */\n  build_index_error:\n    (void)inflateEnd(&strm);\n    if (index != NULL)\n        free_index(index);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zran.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zran.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zran.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zran.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zran.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zran.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zran.c"
   ]
  }
 ],
 "bb92dfa730c689b525a314df49504e92fdbf8c2f65d61f1a268139a8cc1297cf": [
  "local int extract(FILE *in, struct access *index, off_t offset,\n                  unsigned char *buf, int len)\n{\n    int ret, skip;\n    z_stream strm;\n    struct point *here;\n    unsigned char input[CHUNK];\n    unsigned char discard[WINSIZE];\n\n    /* proceed only if something reasonable to do */\n    if (len < 0)\n        return 0;\n\n    /* find where in stream to start */\n    here = index->list;\n    ret = index->have;\n    while (--ret && here[1].out <= offset)\n        here++;\n\n    /* initialize file and inflate state to start there */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, -15);         /* raw inflate */\n    if (ret != Z_OK)\n        return ret;\n    ret = fseeko(in, here->in - (here->bits ? 1 : 0), SEEK_SET);\n    if (ret == -1)\n        goto extract_ret;\n    if (here->bits) {\n        ret = getc(in);\n        if (ret == -1) {\n            ret = ferror(in) ? Z_ERRNO : Z_DATA_ERROR;\n            goto extract_ret;\n        }\n        (void)inflatePrime(&strm, here->bits, ret >> (8 - here->bits));\n    }\n    (void)inflateSetDictionary(&strm, here->window, WINSIZE);\n\n    /* skip uncompressed bytes until offset reached, then satisfy request */\n    offset -= here->out;\n    strm.avail_in = 0;\n    skip = 1;                               /* while skipping to offset */\n    do {\n        /* define where to put uncompressed data, and how much */\n        if (offset == 0 && skip) {          /* at offset now */\n            strm.avail_out = len;\n            strm.next_out = buf;\n            skip = 0;                       /* only do this once */\n        }\n        if (offset > WINSIZE) {             /* skip WINSIZE bytes */\n            strm.avail_out = WINSIZE;\n            strm.next_out = discard;\n            offset -= WINSIZE;\n        }\n        else if (offset != 0) {             /* last skip */\n            strm.avail_out = (unsigned)offset;\n            strm.next_out = discard;\n            offset = 0;\n        }\n\n        /* uncompress until avail_out filled, or end of stream */\n        do {\n            if (strm.avail_in == 0) {\n                strm.avail_in = fread(input, 1, CHUNK, in);\n                if (ferror(in)) {\n                    ret = Z_ERRNO;\n                    goto extract_ret;\n                }\n                if (strm.avail_in == 0) {\n                    ret = Z_DATA_ERROR;\n                    goto extract_ret;\n                }\n                strm.next_in = input;\n            }\n            ret = inflate(&strm, Z_NO_FLUSH);       /* normal inflate */\n            if (ret == Z_NEED_DICT)\n                ret = Z_DATA_ERROR;\n            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n                goto extract_ret;\n            if (ret == Z_STREAM_END)\n                break;\n        } while (strm.avail_out != 0);\n\n        /* if reach end of stream, then don't keep trying to get more */\n        if (ret == Z_STREAM_END)\n            break;\n\n        /* do until offset reached and requested data read, or stream ends */\n    } while (skip);\n\n    /* compute number of uncompressed bytes read after offset */\n    ret = skip ? 0 : len - strm.avail_out;\n\n    /* clean up and return bytes read or error */\n  extract_ret:\n    (void)inflateEnd(&strm);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zran.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zran.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zran.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zran.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zran.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zran.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zran.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zran.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zran.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zran.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zran.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zran.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zran.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zran.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zran.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zran.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zran.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zran.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zran.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zran.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zran.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zran.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zran.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zran.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zran.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zran.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zran.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zran.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zran.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zran.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zran.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zran.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zran.c"
   ]
  }
 ],
 "28ac78173be4c647dc2200f65f76f0e78354348492ee950b4d63f453567be046": [
  "int main(int argc, char **argv)\n{\n    int len;\n    off_t offset;\n    FILE *in;\n    struct access *index = NULL;\n    unsigned char buf[CHUNK];\n\n    /* open input file */\n    if (argc != 2) {\n        fprintf(stderr, \"usage: zran file.gz\\n\");\n        return 1;\n    }\n    in = fopen(argv[1], \"rb\");\n    if (in == NULL) {\n        fprintf(stderr, \"zran: could not open %s for reading\\n\", argv[1]);\n        return 1;\n    }\n\n    /* build index */\n    len = build_index(in, SPAN, &index);\n    if (len < 0) {\n        fclose(in);\n        switch (len) {\n        case Z_MEM_ERROR:\n            fprintf(stderr, \"zran: out of memory\\n\");\n            break;\n        case Z_DATA_ERROR:\n            fprintf(stderr, \"zran: compressed data error in %s\\n\", argv[1]);\n            break;\n        case Z_ERRNO:\n            fprintf(stderr, \"zran: read error on %s\\n\", argv[1]);\n            break;\n        default:\n            fprintf(stderr, \"zran: error %d while building index\\n\", len);\n        }\n        return 1;\n    }\n    fprintf(stderr, \"zran: built index with %d access points\\n\", len);\n\n    /* use index by reading some bytes from an arbitrary offset */\n    offset = (index->list[index->have - 1].out << 1) / 3;\n    len = extract(in, index, offset, buf, CHUNK);\n    if (len < 0)\n        fprintf(stderr, \"zran: extraction failed: %s error\\n\",\n                len == Z_MEM_ERROR ? \"out of memory\" : \"input corrupted\");\n    else {\n        fwrite(buf, 1, len, stdout);\n        fprintf(stderr, \"zran: extracted %d bytes at %llu\\n\", len, offset);\n    }\n\n    /* clean up and exit */\n    free_index(index);\n    fclose(in);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/zran.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/zran.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zran.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zran.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zran.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zran.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zran.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zran.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zran.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zran.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zran.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zran.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zran.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zran.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zran.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zran.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zran.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zran.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zran.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zran.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zran.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zran.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zran.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zran.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zran.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zran.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/zran.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/zran.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/zran.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/zran.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/zran.c"
   ]
  }
 ],
 "250ec7daf6947249253fa15a8273645b8b967c531dd57be3a5bc592597842771": [
  "local int bail(char *why1, char *why2)\n{\n    fprintf(stderr, \"gzjoin error: %s%s, output incomplete\\n\", why1, why2);\n    exit(1);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "50d655b603b658e60798372b4f52b3cfdbcb0710bda3433e7e95addd55ae1c94": [
  "local void bclose(bin *in)\n{\n    if (in != NULL) {\n        if (in->fd != -1)\n            close(in->fd);\n        if (in->buf != NULL)\n            free(in->buf);\n        free(in);\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "bd05571dc7d14502b0f57b1e3ab771b48145432fcf335952fd70bfccf43700fb": [
  "local bin *bopen(char *name)\n{\n    bin *in;\n\n    in = malloc(sizeof(bin));\n    if (in == NULL)\n        return NULL;\n    in->buf = malloc(CHUNK);\n    in->fd = open(name, O_RDONLY, 0);\n    if (in->buf == NULL || in->fd == -1) {\n        bclose(in);\n        return NULL;\n    }\n    in->left = 0;\n    in->next = in->buf;\n    in->name = name;\n    return in;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "374f2a81f005f5ebdde872de985edc98ef190b1c6efaba414d3169f60d3faa2f": [
  "local int bload(bin *in)\n{\n    long len;\n\n    if (in == NULL)\n        return -1;\n    if (in->left != 0)\n        return 0;\n    in->next = in->buf;\n    do {\n        len = (long)read(in->fd, in->buf + in->left, CHUNK - in->left);\n        if (len < 0)\n            return -1;\n        in->left += (unsigned)len;\n    } while (len != 0 && in->left < CHUNK);\n    return len == 0 ? 1 : 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "fca85cbb9864516e07428eab7e0a5ccaa1ca4910b77f28d0326289fd002485c7": [
  "long bget4(bin *in)\n{\n    unsigned long val;\n\n    val = bget(in);\n    val += (unsigned long)(bget(in)) << 8;\n    val += (unsigned long)(bget(in)) << 16;\n    val += (unsigned long)(bget(in)) << 24;\n    return val;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "704dc4838421a2be822a63c2128b02036b3a6648951a44c0d91416ff0c390f2f": [
  "local void bskip(bin *in, unsigned skip)\n{\n    /* check pointer */\n    if (in == NULL)\n        return;\n\n    /* easy case -- skip bytes in buffer */\n    if (skip <= in->left) {\n        in->left -= skip;\n        in->next += skip;\n        return;\n    }\n\n    /* skip what's in buffer, discard buffer contents */\n    skip -= in->left;\n    in->left = 0;\n\n    /* seek past multiples of CHUNK bytes */\n    if (skip > CHUNK) {\n        unsigned left;\n\n        left = skip & (CHUNK - 1);\n        if (left == 0) {\n            /* exact number of chunks: seek all the way minus one byte to check\n               for end-of-file with a read */\n            lseek(in->fd, skip - 1, SEEK_CUR);\n            if (read(in->fd, in->buf, 1) != 1)\n                bail(\"unexpected end of file on \", in->name);\n            return;\n        }\n\n        /* skip the integral chunks, update skip with remainder */\n        lseek(in->fd, skip - left, SEEK_CUR);\n        skip = left;\n    }\n\n    /* read more input and skip remainder */\n    bload(in);\n    if (skip > in->left)\n        bail(\"unexpected end of file on \", in->name);\n    in->left -= skip;\n    in->next += skip;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "9906debc57aac491881dc27945935810fde3a67da4585794c526660b60bd1426": [
  "local void gzhead(bin *in)\n{\n    int flags;\n\n    /* verify gzip magic header and compression method */\n    if (bget(in) != 0x1f || bget(in) != 0x8b || bget(in) != 8)\n        bail(in->name, \" is not a valid gzip file\");\n\n    /* get and verify flags */\n    flags = bget(in);\n    if ((flags & 0xe0) != 0)\n        bail(\"unknown reserved bits set in \", in->name);\n\n    /* skip modification time, extra flags, and os */\n    bskip(in, 6);\n\n    /* skip extra field if present */\n    if (flags & 4) {\n        unsigned len;\n\n        len = bget(in);\n        len += (unsigned)(bget(in)) << 8;\n        bskip(in, len);\n    }\n\n    /* skip file name if present */\n    if (flags & 8)\n        while (bget(in) != 0)\n            ;\n\n    /* skip comment if present */\n    if (flags & 16)\n        while (bget(in) != 0)\n            ;\n\n    /* skip header crc if present */\n    if (flags & 2)\n        bskip(in, 2);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "0d1a58c9ea918908d50460c20c036107160e2352fad3ebc95285f60d23e7f10a": [
  "local void put4(unsigned long val, FILE *out)\n{\n    putc(val & 0xff, out);\n    putc((val >> 8) & 0xff, out);\n    putc((val >> 16) & 0xff, out);\n    putc((val >> 24) & 0xff, out);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "1c49db9f825ab07e87f4f83f27badcefb9f296d4ba35faf81282a56747fb04dd": [
  "local void zpull(z_streamp strm, bin *in)\n{\n    if (in->left == 0)\n        bload(in);\n    if (in->left == 0)\n        bail(\"unexpected end of file on \", in->name);\n    strm->avail_in = in->left;\n    strm->next_in = in->next;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "6e535ab09e13608f46f35f0598411e16004b3252e9ca2f32e2375c90eb2e8d99": [
  "local void gzinit(unsigned long *crc, unsigned long *tot, FILE *out)\n{\n    fwrite(\"\\x1f\\x8b\\x08\\0\\0\\0\\0\\0\\0\\xff\", 1, 10, out);\n    *crc = crc32(0L, Z_NULL, 0);\n    *tot = 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "b4f5f38dbe9ed9607e917d1571ef5e861d6754c96875dc4df18e676ad4893b5a": [
  "local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,\n                  FILE *out)\n{\n    int ret;                /* return value from zlib functions */\n    int pos;                /* where the \"last block\" bit is in byte */\n    int last;               /* true if processing the last block */\n    bin *in;                /* buffered input file */\n    unsigned char *start;   /* start of compressed data in buffer */\n    unsigned char *junk;    /* buffer for uncompressed data -- discarded */\n    z_off_t len;            /* length of uncompressed data (support > 4 GB) */\n    z_stream strm;          /* zlib inflate stream */\n\n    /* open gzip file and skip header */\n    in = bopen(name);\n    if (in == NULL)\n        bail(\"could not open \", name);\n    gzhead(in);\n\n    /* allocate buffer for uncompressed data and initialize raw inflate\n       stream */\n    junk = malloc(CHUNK);\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, -15);\n    if (junk == NULL || ret != Z_OK)\n        bail(\"out of memory\", \"\");\n\n    /* inflate and copy compressed data, clear last-block bit if requested */\n    len = 0;\n    zpull(&strm, in);\n    start = in->next;\n    last = start[0] & 1;\n    if (last && clr)\n        start[0] &= ~1;\n    strm.avail_out = 0;\n    for (;;) {\n        /* if input used and output done, write used input and get more */\n        if (strm.avail_in == 0 && strm.avail_out != 0) {\n            fwrite(start, 1, strm.next_in - start, out);\n            start = in->buf;\n            in->left = 0;\n            zpull(&strm, in);\n        }\n\n        /* decompress -- return early when end-of-block reached */\n        strm.avail_out = CHUNK;\n        strm.next_out = junk;\n        ret = inflate(&strm, Z_BLOCK);\n        switch (ret) {\n        case Z_MEM_ERROR:\n            bail(\"out of memory\", \"\");\n        case Z_DATA_ERROR:\n            bail(\"invalid compressed data in \", in->name);\n        }\n\n        /* update length of uncompressed data */\n        len += CHUNK - strm.avail_out;\n\n        /* check for block boundary (only get this when block copied out) */\n        if (strm.data_type & 128) {\n            /* if that was the last block, then done */\n            if (last)\n                break;\n\n            /* number of unused bits in last byte */\n            pos = strm.data_type & 7;\n\n            /* find the next last-block bit */\n            if (pos != 0) {\n                /* next last-block bit is in last used byte */\n                pos = 0x100 >> pos;\n                last = strm.next_in[-1] & pos;\n                if (last && clr)\n                    in->buf[strm.next_in - in->buf - 1] &= ~pos;\n            }\n            else {\n                /* next last-block bit is in next unused byte */\n                if (strm.avail_in == 0) {\n                    /* don't have that byte yet -- get it */\n                    fwrite(start, 1, strm.next_in - start, out);\n                    start = in->buf;\n                    in->left = 0;\n                    zpull(&strm, in);\n                }\n                last = strm.next_in[0] & 1;\n                if (last && clr)\n                    in->buf[strm.next_in - in->buf] &= ~1;\n            }\n        }\n    }\n\n    /* update buffer with unused input */\n    in->left = strm.avail_in;\n    in->next = in->buf + (strm.next_in - in->buf);\n\n    /* copy used input, write empty blocks to get to byte boundary */\n    pos = strm.data_type & 7;\n    fwrite(start, 1, in->next - start - 1, out);\n    last = in->next[-1];\n    if (pos == 0 || !clr)\n        /* already at byte boundary, or last file: write last byte */\n        putc(last, out);\n    else {\n        /* append empty blocks to last byte */\n        last &= ((0x100 >> pos) - 1);       /* assure unused bits are zero */\n        if (pos & 1) {\n            /* odd -- append an empty stored block */\n            putc(last, out);\n            if (pos == 1)\n                putc(0, out);               /* two more bits in block header */\n            fwrite(\"\\0\\0\\xff\\xff\", 1, 4, out);\n        }\n        else {\n            /* even -- append 1, 2, or 3 empty fixed blocks */\n            switch (pos) {\n            case 6:\n                putc(last | 8, out);\n                last = 0;\n            case 4:\n                putc(last | 0x20, out);\n                last = 0;\n            case 2:\n                putc(last | 0x80, out);\n                putc(0, out);\n            }\n        }\n    }\n\n    /* update crc and tot */\n    *crc = crc32_combine(*crc, bget4(in), len);\n    *tot += (unsigned long)len;\n\n    /* clean up */\n    inflateEnd(&strm);\n    free(junk);\n    bclose(in);\n\n    /* write trailer if this is the last gzip file */\n    if (!clr) {\n        put4(*crc, out);\n        put4(*tot, out);\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "297115fbc7586794dfac7af967821b65ca60358478b3e223b888422a42500b22": [
  "int main(int argc, char **argv)\n{\n    unsigned long crc, tot;     /* running crc and total uncompressed length */\n\n    /* skip command name */\n    argc--;\n    argv++;\n\n    /* show usage if no arguments */\n    if (argc == 0) {\n        fputs(\"gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]] > fjoin.gz\\n\",\n              stderr);\n        return 0;\n    }\n\n    /* join gzip files on command line and write to stdout */\n    gzinit(&crc, &tot, stdout);\n    while (argc--)\n        gzcopy(*argv++, argc, &crc, &tot, stdout);\n\n    /* done */\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzjoin.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzjoin.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzjoin.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzjoin.c"
   ],
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzjoin.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzjoin.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzjoin.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzjoin.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzjoin.c"
   ]
  }
 ],
 "d9f7e0670d7bd105d7968c42ff62eae5b280cadaed90c55c15e1427b0e0c3a54": [
  "local int log_lock(struct log *log)\n{\n    int fd;\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    while ((fd = open(log->path, O_CREAT | O_EXCL, 0644)) < 0) {\n        if (errno != EEXIST)\n            return -1;\n        if (stat(log->path, &st) == 0 && time(NULL) - st.st_mtime > PATIENCE) {\n            unlink(log->path);\n            continue;\n        }\n        sleep(2);       /* relinquish the CPU for two seconds while waiting */\n    }\n    close(fd);\n    if (stat(log->path, &st) == 0)\n        log->lock = st.st_mtime;\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "238b995a5ab4c989df543f791ff78518b31a748665461bba98052960a5a2c9a7": [
  "local void log_touch(struct log *log)\n{\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    utimes(log->path, NULL);\n    if (stat(log->path, &st) == 0)\n        log->lock = st.st_mtime;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "65f0c364d93cba3ac2b68dd64b3e617053a2af1b206363aec944d697f1fd6211": [
  "local int log_check(struct log *log)\n{\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    if (stat(log->path, &st) || st.st_mtime != log->lock)\n        return 1;\n    log_touch(log);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "840fec1e6d23149637ad55b91b1b455443a2df8a7cbc6ef7ef08d8673fe76747": [
  "local void log_unlock(struct log *log)\n{\n    if (log_check(log))\n        return;\n    strcpy(log->end, \".lock\");\n    unlink(log->path);\n    log->lock = 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "164c3d47a95e81edc88dcdb2071d33346dcf43f859e03cbd2da7d09eccacaaa4": [
  "local int log_head(struct log *log)\n{\n    int op;\n    unsigned char buf[HEAD + EXTRA];\n\n    if (lseek(log->fd, 0, SEEK_SET) < 0 ||\n        read(log->fd, buf, HEAD + EXTRA) != HEAD + EXTRA ||\n        memcmp(buf, log_gzhead, HEAD)) {\n        return -1;\n    }\n    log->first = PULL8(buf + HEAD);\n    log->last = PULL8(buf + HEAD + 8);\n    log->ccrc = PULL4(buf + HEAD + 16);\n    log->clen = PULL4(buf + HEAD + 20);\n    log->tcrc = PULL4(buf + HEAD + 24);\n    log->tlen = PULL4(buf + HEAD + 28);\n    log->stored = PULL2(buf + HEAD + 32);\n    log->back = 3 + (buf[HEAD + 34] & 7);\n    op = (buf[HEAD + 34] >> 3) & 3;\n    return op;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "d655063d692504f1cff630f78bf11a31c7a76fc4e65d4165878af3f546d5197d": [
  "local int log_mark(struct log *log, int op)\n{\n    int ret;\n    unsigned char ext[EXTRA];\n\n    PUT8(ext, log->first);\n    PUT8(ext + 8, log->last);\n    PUT4(ext + 16, log->ccrc);\n    PUT4(ext + 20, log->clen);\n    PUT4(ext + 24, log->tcrc);\n    PUT4(ext + 28, log->tlen);\n    PUT2(ext + 32, log->stored);\n    ext[34] = log->back - 3 + (op << 3);\n    fsync(log->fd);\n    ret = lseek(log->fd, HEAD, SEEK_SET) < 0 ||\n          write(log->fd, ext, EXTRA) != EXTRA ? -1 : 0;\n    fsync(log->fd);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "a9f603615ebfeefc50d6b329da59b524e83ed7a4b7a2a77a09b2a0099159f7f2": [
  "local int log_last(struct log *log, int last)\n{\n    int back, len, mask;\n    unsigned char buf[6];\n\n    /* determine the locations of the bytes and bits to modify */\n    back = log->last == log->first ? log->back : 8;\n    len = back > 8 ? 2 : 1;                 /* bytes back from log->last */\n    mask = 0x80 >> ((back - 1) & 7);        /* mask for block last-bit */\n\n    /* get the byte to modify (one or two back) into buf[0] -- don't need to\n       read the byte if the last-bit is eight bits back, since in that case\n       the entire byte will be modified */\n    buf[0] = 0;\n    if (back != 8 && (lseek(log->fd, log->last - len, SEEK_SET) < 0 ||\n                      read(log->fd, buf, 1) != 1))\n        return -1;\n\n    /* change the last-bit of the last stored block as requested -- note\n       that all bits above the last-bit are set to zero, per the type bits\n       of a stored block being 00 and per the convention that the bits to\n       bring the stream to a byte boundary are also zeros */\n    buf[1] = 0;\n    buf[2 - len] = (*buf & (mask - 1)) + (last ? mask : 0);\n\n    /* write the modified stored block header and lengths, move the file\n       pointer to after the last stored block data */\n    PUT2(buf + 2, log->stored);\n    PUT2(buf + 4, log->stored ^ 0xffff);\n    return lseek(log->fd, log->last - len, SEEK_SET) < 0 ||\n           write(log->fd, buf + 2 - len, len + 4) != len + 4 ||\n           lseek(log->fd, log->stored, SEEK_CUR) < 0 ? -1 : 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "f7cfde873deeb4f09b08a9375282f90b7d60dcc7507177e34dd6736fe67eb784": [
  "local int log_append(struct log *log, unsigned char *data, size_t len)\n{\n    uint put;\n    off_t end;\n    unsigned char buf[8];\n\n    /* set the last block last-bit and length, in case recovering an\n       interrupted append, then position the file pointer to append to the\n       block */\n    if (log_last(log, 1))\n        return -1;\n\n    /* append, adding stored blocks and updating the offset of the last stored\n       block as needed, and update the total crc and length */\n    while (len) {\n        /* append as much as we can to the last block */\n        put = (MAX_STORE << 10) - log->stored;\n        if (put > len)\n            put = (uint)len;\n        if (put) {\n            if (write(log->fd, data, put) != put)\n                return -1;\n            BAIL(1);\n            log->tcrc = crc32(log->tcrc, data, put);\n            log->tlen += put;\n            log->stored += put;\n            data += put;\n            len -= put;\n        }\n\n        /* if we need to, add a new empty stored block */\n        if (len) {\n            /* mark current block as not last */\n            if (log_last(log, 0))\n                return -1;\n\n            /* point to new, empty stored block */\n            log->last += 4 + log->stored + 1;\n            log->stored = 0;\n        }\n\n        /* mark last block as last, update its length */\n        if (log_last(log, 1))\n            return -1;\n        BAIL(2);\n    }\n\n    /* write the new crc and length trailer, and truncate just in case (could\n       be recovering from partial append with a missing foo.add file) */\n    PUT4(buf, log->tcrc);\n    PUT4(buf + 4, log->tlen);\n    if (write(log->fd, buf, 8) != 8 ||\n        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))\n        return -1;\n\n    /* write the extra field, marking the log file as done, delete .add file */\n    if (log_mark(log, NO_OP))\n        return -1;\n    strcpy(log->end, \".add\");\n    unlink(log->path);          /* ignore error, since may not exist */\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "e4d73dc72afa863eb967d8d4d2b7037e2066d0093caae9fba9644b5e91d91864": [
  "local int log_replace(struct log *log)\n{\n    int ret;\n    char *dest;\n\n    /* delete foo.add file */\n    strcpy(log->end, \".add\");\n    unlink(log->path);         /* ignore error, since may not exist */\n    BAIL(3);\n\n    /* rename foo.name to foo.dict, replacing foo.dict if it exists */\n    strcpy(log->end, \".dict\");\n    dest = malloc(strlen(log->path) + 1);\n    if (dest == NULL)\n        return -2;\n    strcpy(dest, log->path);\n    strcpy(log->end, \".temp\");\n    ret = rename(log->path, dest);\n    free(dest);\n    if (ret && errno != ENOENT)\n        return -1;\n    BAIL(4);\n\n    /* mark the foo.gz file as done */\n    return log_mark(log, NO_OP);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "5deba929a6f6b1e00f1570f1ea1c6e4090cf15be2eaf46ff00f1a38accddf957": [
  "local int log_compress(struct log *log, unsigned char *data, size_t len)\n{\n    int fd;\n    uint got, max;\n    ssize_t dict;\n    off_t end;\n    z_stream strm;\n    unsigned char buf[DICT];\n\n    /* compress and append compressed data */\n    if (len) {\n        /* set up for deflate, allocating memory */\n        strm.zalloc = Z_NULL;\n        strm.zfree = Z_NULL;\n        strm.opaque = Z_NULL;\n        if (deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -15, 8,\n                         Z_DEFAULT_STRATEGY) != Z_OK)\n            return -2;\n\n        /* read in dictionary (last 32K of data that was compressed) */\n        strcpy(log->end, \".dict\");\n        fd = open(log->path, O_RDONLY, 0);\n        if (fd >= 0) {\n            dict = read(fd, buf, DICT);\n            close(fd);\n            if (dict < 0) {\n                deflateEnd(&strm);\n                return -1;\n            }\n            if (dict)\n                deflateSetDictionary(&strm, buf, (uint)dict);\n        }\n        log_touch(log);\n\n        /* prime deflate with last bits of previous block, position write\n           pointer to write those bits and overwrite what follows */\n        if (lseek(log->fd, log->first - (log->back > 8 ? 2 : 1),\n                SEEK_SET) < 0 ||\n            read(log->fd, buf, 1) != 1 || lseek(log->fd, -1, SEEK_CUR) < 0) {\n            deflateEnd(&strm);\n            return -1;\n        }\n        deflatePrime(&strm, (8 - log->back) & 7, *buf);\n\n        /* compress, finishing with a partial non-last empty static block */\n        strm.next_in = data;\n        max = (((uint)0 - 1) >> 1) + 1; /* in case int smaller than size_t */\n        do {\n            strm.avail_in = len > max ? max : (uint)len;\n            len -= strm.avail_in;\n            do {\n                strm.avail_out = DICT;\n                strm.next_out = buf;\n                deflate(&strm, len ? Z_NO_FLUSH : Z_PARTIAL_FLUSH);\n                got = DICT - strm.avail_out;\n                if (got && write(log->fd, buf, got) != got) {\n                    deflateEnd(&strm);\n                    return -1;\n                }\n                log_touch(log);\n            } while (strm.avail_out == 0);\n        } while (len);\n        deflateEnd(&strm);\n        BAIL(5);\n\n        /* find start of empty static block -- scanning backwards the first one\n           bit is the second bit of the block, if the last byte is zero, then\n           we know the byte before that has a one in the top bit, since an\n           empty static block is ten bits long */\n        if ((log->first = lseek(log->fd, -1, SEEK_CUR)) < 0 ||\n            read(log->fd, buf, 1) != 1)\n            return -1;\n        log->first++;\n        if (*buf) {\n            log->back = 1;\n            while ((*buf & ((uint)1 << (8 - log->back++))) == 0)\n                ;       /* guaranteed to terminate, since *buf != 0 */\n        }\n        else\n            log->back = 10;\n\n        /* update compressed crc and length */\n        log->ccrc = log->tcrc;\n        log->clen = log->tlen;\n    }\n    else {\n        /* no data to compress -- fix up existing gzip stream */\n        log->tcrc = log->ccrc;\n        log->tlen = log->clen;\n    }\n\n    /* complete and truncate gzip stream */\n    log->last = log->first;\n    log->stored = 0;\n    PUT4(buf, log->tcrc);\n    PUT4(buf + 4, log->tlen);\n    if (log_last(log, 1) || write(log->fd, buf, 8) != 8 ||\n        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))\n        return -1;\n    BAIL(6);\n\n    /* mark as being in the replace operation */\n    if (log_mark(log, REPLACE_OP))\n        return -1;\n\n    /* execute the replace operation and mark the file as done */\n    return log_replace(log);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "af282237c2cb2d492c78db035492a6276c54cd34bde7f7e35f0134e901aea80b": [
  "local void log_log(struct log *log, int op, char *record)\n{\n    time_t now;\n    FILE *rec;\n\n    now = time(NULL);\n    strcpy(log->end, \".repairs\");\n    rec = fopen(log->path, \"a\");\n    if (rec == NULL)\n        return;\n    fprintf(rec, \"%.24s %s recovery: %s\\n\", ctime(&now), op == APPEND_OP ?\n            \"append\" : (op == COMPRESS_OP ? \"compress\" : \"replace\"), record);\n    fclose(rec);\n    return;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "e3d223d09b7d40be9bbb099bef124b8b3a008a5af4a3d583529f666a0d3e1150": [
  "local int log_recover(struct log *log, int op)\n{\n    int fd, ret = 0;\n    unsigned char *data = NULL;\n    size_t len = 0;\n    struct stat st;\n\n    /* log recovery */\n    log_log(log, op, \"start\");\n\n    /* load foo.add file if expected and present */\n    if (op == APPEND_OP || op == COMPRESS_OP) {\n        strcpy(log->end, \".add\");\n        if (stat(log->path, &st) == 0 && st.st_size) {\n            len = (size_t)(st.st_size);\n            if ((off_t)len != st.st_size ||\n                    (data = malloc(st.st_size)) == NULL) {\n                log_log(log, op, \"allocation failure\");\n                return -2;\n            }\n            if ((fd = open(log->path, O_RDONLY, 0)) < 0) {\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            ret = (size_t)read(fd, data, len) != len;\n            close(fd);\n            if (ret) {\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            log_log(log, op, \"loaded .add file\");\n        }\n        else\n            log_log(log, op, \"missing .add file!\");\n    }\n\n    /* recover the interrupted operation */\n    switch (op) {\n    case APPEND_OP:\n        ret = log_append(log, data, len);\n        break;\n    case COMPRESS_OP:\n        ret = log_compress(log, data, len);\n        break;\n    case REPLACE_OP:\n        ret = log_replace(log);\n    }\n\n    /* log status */\n    log_log(log, op, ret ? \"failure\" : \"complete\");\n\n    /* clean up */\n    if (data != NULL)\n        free(data);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "f66c71b1ca624f0eae2aa6a4530eca4d8c206855eeaa13e41b63fb78ec5e4a8e": [
  "local void log_close(struct log *log)\n{\n    if (log->fd >= 0)\n        close(log->fd);\n    log->fd = -1;\n    log_unlock(log);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "920489cf188fcf3f8029a4a0fec5eab912a426e3433afdc80bff2a0d73ba74e3": [
  "local int log_open(struct log *log)\n{\n    int op;\n\n    /* release open file resource if left over -- can occur if lock lost\n       between gzlog_open() and gzlog_write() */\n    if (log->fd >= 0)\n        close(log->fd);\n    log->fd = -1;\n\n    /* negotiate exclusive access */\n    if (log_lock(log) < 0)\n        return -1;\n\n    /* open the log file, foo.gz */\n    strcpy(log->end, \".gz\");\n    log->fd = open(log->path, O_RDWR | O_CREAT, 0644);\n    if (log->fd < 0) {\n        log_close(log);\n        return -1;\n    }\n\n    /* if new, initialize foo.gz with an empty log, delete old dictionary */\n    if (lseek(log->fd, 0, SEEK_END) == 0) {\n        if (write(log->fd, log_gzhead, HEAD) != HEAD ||\n            write(log->fd, log_gzext, EXTRA) != EXTRA ||\n            write(log->fd, log_gzbody, BODY) != BODY) {\n            log_close(log);\n            return -1;\n        }\n        strcpy(log->end, \".dict\");\n        unlink(log->path);\n    }\n\n    /* verify log file and load extra field information */\n    if ((op = log_head(log)) < 0) {\n        log_close(log);\n        return -1;\n    }\n\n    /* check for interrupted process and if so, recover */\n    if (op != NO_OP && log_recover(log, op)) {\n        log_close(log);\n        return -1;\n    }\n\n    /* touch the lock file to prevent another process from grabbing it */\n    log_touch(log);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "cb80735464df0c5ac685cf46755e38f42f44552f3e46cf9811e9bd8bb566b319": [
  "gzlog *gzlog_open(char *path)\n{\n    size_t n;\n    struct log *log;\n\n    /* check arguments */\n    if (path == NULL || *path == 0)\n        return NULL;\n\n    /* allocate and initialize log structure */\n    log = malloc(sizeof(struct log));\n    if (log == NULL)\n        return NULL;\n    strcpy(log->id, LOGID);\n    log->fd = -1;\n\n    /* save path and end of path for name construction */\n    n = strlen(path);\n    log->path = malloc(n + 9);              /* allow for \".repairs\" */\n    if (log->path == NULL) {\n        free(log);\n        return NULL;\n    }\n    strcpy(log->path, path);\n    log->end = log->path + n;\n\n    /* gain exclusive access and verify log file -- may perform a\n       recovery operation if needed */\n    if (log_open(log)) {\n        free(log->path);\n        free(log);\n        return NULL;\n    }\n\n    /* return pointer to log structure */\n    return log;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "e165f5900e295c8fcf9738fa8a76790712dac117c8fa5f1656270c05d912b571": [
  "int gzlog_compress(gzlog *logd)\n{\n    int fd, ret;\n    uint block;\n    size_t len, next;\n    unsigned char *data, buf[5];\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID))\n        return -3;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create space for uncompressed data */\n    len = ((size_t)(log->last - log->first) & ~(((size_t)1 << 10) - 1)) +\n          log->stored;\n    if ((data = malloc(len)) == NULL)\n        return -2;\n\n    /* do statement here is just a cheap trick for error handling */\n    do {\n        /* read in the uncompressed data */\n        if (lseek(log->fd, log->first - 1, SEEK_SET) < 0)\n            break;\n        next = 0;\n        while (next < len) {\n            if (read(log->fd, buf, 5) != 5)\n                break;\n            block = PULL2(buf + 1);\n            if (next + block > len ||\n                read(log->fd, (char *)data + next, block) != block)\n                break;\n            next += block;\n        }\n        if (lseek(log->fd, 0, SEEK_CUR) != log->last + 4 + log->stored)\n            break;\n        log_touch(log);\n\n        /* write the uncompressed data to the .add file */\n        strcpy(log->end, \".add\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        ret = (size_t)write(fd, data, len) != len;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* write the dictionary for the next compress to the .temp file */\n        strcpy(log->end, \".temp\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        next = DICT > len ? len : DICT;\n        ret = (size_t)write(fd, (char *)data + len - next, next) != next;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* roll back to compressed data, mark the compress in progress */\n        log->last = log->first;\n        log->stored = 0;\n        if (log_mark(log, COMPRESS_OP))\n            break;\n        BAIL(7);\n\n        /* compress and append the data (clears mark) */\n        ret = log_compress(log, data, len);\n        free(data);\n        return ret;\n    } while (0);\n\n    /* broke out of do above on i/o error */\n    free(data);\n    return -1;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "d7a345a2facf28e2d7a80d2bb40a226c0742a91731841a5efde8843126d04b00": [
  "int gzlog_write(gzlog *logd, void *data, size_t len)\n{\n    int fd, ret;\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID))\n        return -3;\n    if (data == NULL || len <= 0)\n        return 0;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create and write .add file */\n    strcpy(log->end, \".add\");\n    fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (fd < 0)\n        return -1;\n    ret = (size_t)write(fd, data, len) != len;\n    if (ret | close(fd))\n        return -1;\n    log_touch(log);\n\n    /* mark log file with append in progress */\n    if (log_mark(log, APPEND_OP))\n        return -1;\n    BAIL(8);\n\n    /* append data (clears mark) */\n    if (log_append(log, data, len))\n        return -1;\n\n    /* check to see if it's time to compress -- if not, then done */\n    if (((log->last - log->first) >> 10) + (log->stored >> 10) < TRIGGER)\n        return 0;\n\n    /* time to compress */\n    return gzlog_compress(log);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "799f4f546ca6ed3a7e5f141830c21d01e235a89326127abcfe0dc80e6d1dbf10": [
  "int gzlog_close(gzlog *logd)\n{\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID))\n        return -3;\n\n    /* close the log file and release the lock */\n    log_close(log);\n\n    /* free structure and return */\n    if (log->path != NULL)\n        free(log->path);\n    strcpy(log->id, \"bad\");\n    free(log);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzlog.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzlog.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzlog.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzlog.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzlog.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzlog.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzlog.c"
   ]
  }
 ],
 "363c1d9c092ca7e56ef264bb833f3c43b4a39c2f4b463978590a364c99d6184d": [
  "local void gztack(char *name, int gd, z_stream *strm, int last)\n{\n    int fd, len, ret;\n    unsigned left;\n    unsigned char *in, *out;\n\n    /* open file to compress and append */\n    fd = 0;\n    if (name != NULL) {\n        fd = open(name, O_RDONLY, 0);\n        if (fd == -1)\n            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n                    name);\n    }\n\n    /* allocate buffers */\n    in = malloc(CHUNK);\n    out = malloc(CHUNK);\n    if (in == NULL || out == NULL) bye(\"out of memory\", \"\");\n\n    /* compress input file and append to gzip file */\n    do {\n        /* get more input */\n        len = read(fd, in, CHUNK);\n        if (len == -1) {\n            fprintf(stderr,\n                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n                    name);\n            len = 0;\n        }\n        strm->avail_in = (unsigned)len;\n        strm->next_in = in;\n        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n\n        /* compress and write all available output */\n        do {\n            strm->avail_out = CHUNK;\n            strm->next_out = out;\n            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n            left = CHUNK - strm->avail_out;\n            while (left) {\n                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n                if (len == -1) bye(\"writing gzip file\", \"\");\n                left -= (unsigned)len;\n            }\n        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n    } while (len != 0);\n\n    /* write trailer after last entry */\n    if (last) {\n        deflateEnd(strm);\n        out[0] = (unsigned char)(strm->adler);\n        out[1] = (unsigned char)(strm->adler >> 8);\n        out[2] = (unsigned char)(strm->adler >> 16);\n        out[3] = (unsigned char)(strm->adler >> 24);\n        out[4] = (unsigned char)(strm->total_in);\n        out[5] = (unsigned char)(strm->total_in >> 8);\n        out[6] = (unsigned char)(strm->total_in >> 16);\n        out[7] = (unsigned char)(strm->total_in >> 24);\n        len = 8;\n        do {\n            ret = write(gd, out + 8 - len, len);\n            if (ret == -1) bye(\"writing gzip file\", \"\");\n            len -= ret;\n        } while (len);\n        close(gd);\n    }\n\n    /* clean up and return */\n    free(out);\n    free(in);\n    if (fd > 0) close(fd);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "12d134213fc6650c91db3e0e239bcf7664b68b857929466a50328ffe45c66cfd": [
  "int main(int argc, char **argv)\n{\n    int gd, level;\n    z_stream strm;\n\n    /* ignore command name */\n    argc--; argv++;\n\n    /* provide usage if no arguments */\n    if (*argv == NULL) {\n        printf(\n            \"gzappend 1.2 (11 Oct 2012) Copyright (C) 2003, 2012 Mark Adler\\n\"\n               );\n        printf(\n            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n        return 0;\n    }\n\n    /* set compression level */\n    level = Z_DEFAULT_COMPRESSION;\n    if (argv[0][0] == '-') {\n        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n            bye(\"invalid compression level\", \"\");\n        level = argv[0][1] - '0';\n        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n    }\n\n    /* prepare to append to gzip file */\n    gd = gzscan(*argv++, &strm, level);\n\n    /* append files on command line, or from stdin if none */\n    if (*argv == NULL)\n        gztack(NULL, gd, &strm, 1);\n    else\n        do {\n            gztack(*argv, gd, &strm, argv[1] == NULL);\n        } while (*++argv != NULL);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "examples/gzappend.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "examples/gzappend.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "examples/gzappend.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "examples/gzappend.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "examples/gzappend.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "examples/gzappend.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "examples/gzappend.c"
   ]
  }
 ],
 "96eea0d1df4c66eb46a036594e206411310968e54bab2122f4fdde2a8ec00c13": [
  "local void *mem_alloc(void *mem, unsigned count, unsigned size)\n{\n    void *ptr;\n    struct mem_item *item;\n    struct mem_zone *zone = mem;\n    size_t len = count * (size_t)size;\n\n    /* induced allocation failure */\n    if (zone == NULL || (zone->limit && zone->total + len > zone->limit))\n        return NULL;\n\n    /* perform allocation using the standard library, fill memory with a\n       non-zero value to make sure that the code isn't depending on zeros */\n    ptr = malloc(len);\n    if (ptr == NULL)\n        return NULL;\n    memset(ptr, 0xa5, len);\n\n    /* create a new item for the list */\n    item = malloc(sizeof(struct mem_item));\n    if (item == NULL) {\n        free(ptr);\n        return NULL;\n    }\n    item->ptr = ptr;\n    item->size = len;\n\n    /* insert item at the beginning of the list */\n    item->next = zone->first;\n    zone->first = item;\n\n    /* update the statistics */\n    zone->total += item->size;\n    if (zone->total > zone->highwater)\n        zone->highwater = zone->total;\n\n    /* return the allocated memory */\n    return ptr;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "1864c7007fc93307fc54eac7529d0cdf728d058c00e0a36269959457f1de6742": [
  "local void mem_free(void *mem, void *ptr)\n{\n    struct mem_item *item, *next;\n    struct mem_zone *zone = mem;\n\n    /* if no zone, just do a free */\n    if (zone == NULL) {\n        free(ptr);\n        return;\n    }\n\n    /* point next to the item that matches ptr, or NULL if not found -- remove\n       the item from the linked list if found */\n    next = zone->first;\n    if (next) {\n        if (next->ptr == ptr)\n            zone->first = next->next;   /* first one is it, remove from list */\n        else {\n            do {                        /* search the linked list */\n                item = next;\n                next = item->next;\n            } while (next != NULL && next->ptr != ptr);\n            if (next) {                 /* if found, remove from linked list */\n                item->next = next->next;\n                zone->notlifo++;        /* not a LIFO free */\n            }\n\n        }\n    }\n\n    /* if found, update the statistics and free the item */\n    if (next) {\n        zone->total -= next->size;\n        free(next);\n    }\n\n    /* if not found, update the rogue count */\n    else\n        zone->rogue++;\n\n    /* in any case, do the requested free with the standard library function */\n    free(ptr);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "127ab5229e780ce024d4fbe38921a1c2af815a10aaaac4bf7981be34e034274e": [
  "local void mem_setup(z_stream *strm)\n{\n    struct mem_zone *zone;\n\n    zone = malloc(sizeof(struct mem_zone));\n    assert(zone != NULL);\n    zone->first = NULL;\n    zone->total = 0;\n    zone->highwater = 0;\n    zone->limit = 0;\n    zone->notlifo = 0;\n    zone->rogue = 0;\n    strm->opaque = zone;\n    strm->zalloc = mem_alloc;\n    strm->zfree = mem_free;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "2578d6aec36a363ee287dc8988e9f8ee5be71c7e2426dfb991306928948ed9e4": [
  "local void mem_limit(z_stream *strm, size_t limit)\n{\n    struct mem_zone *zone = strm->opaque;\n\n    zone->limit = limit;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "4a00b19da92129e6ec58d1d2f27b476579601e1d4a0aaccf8075ee50638e7b1c": [
  "local void mem_used(z_stream *strm, char *prefix)\n{\n    struct mem_zone *zone = strm->opaque;\n\n    fprintf(stderr, \"%s: %lu allocated\\n\", prefix, zone->total);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "13bae87c6641d33d4765d539017d293bbe29a06db83087a78665530199a6e3e1": [
  "local void mem_high(z_stream *strm, char *prefix)\n{\n    struct mem_zone *zone = strm->opaque;\n\n    fprintf(stderr, \"%s: %lu high water mark\\n\", prefix, zone->highwater);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "dbbd596ce2e5137fdcabc1a81626794977461381929d86a01fb4597fa4695d16": [
  "local void mem_done(z_stream *strm, char *prefix)\n{\n    int count = 0;\n    struct mem_item *item, *next;\n    struct mem_zone *zone = strm->opaque;\n\n    /* show high water mark */\n    mem_high(strm, prefix);\n\n    /* free leftover allocations and item structures, if any */\n    item = zone->first;\n    while (item != NULL) {\n        free(item->ptr);\n        next = item->next;\n        free(item);\n        item = next;\n        count++;\n    }\n\n    /* issue alerts about anything unexpected */\n    if (count || zone->total)\n        fprintf(stderr, \"** %s: %lu bytes in %d blocks not freed\\n\",\n                prefix, zone->total, count);\n    if (zone->notlifo)\n        fprintf(stderr, \"** %s: %d frees not LIFO\\n\", prefix, zone->notlifo);\n    if (zone->rogue)\n        fprintf(stderr, \"** %s: %d frees not recognized\\n\",\n                prefix, zone->rogue);\n\n    /* free the zone and delete from the stream */\n    free(zone);\n    strm->opaque = Z_NULL;\n    strm->zalloc = Z_NULL;\n    strm->zfree = Z_NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "77fdc7155906c48a7d763558e4ac91173146973171cf2c5d71ddd9982b8195ec": [
  "char *h2b(const char *hex, unsigned *len)\n{\n    unsigned char *in, *re;\n    unsigned next, val;\n\n    in = malloc((strlen(hex) + 1) >> 1);\n    if (in == NULL)\n        return NULL;\n    next = 0;\n    val = 1;\n    do {\n        if (*hex >= '0' && *hex <= '9')\n            val = (val << 4) + *hex - '0';\n        else if (*hex >= 'A' && *hex <= 'F')\n            val = (val << 4) + *hex - 'A' + 10;\n        else if (*hex >= 'a' && *hex <= 'f')\n            val = (val << 4) + *hex - 'a' + 10;\n        else if (val != 1 && val < 32)  /* one digit followed by delimiter */\n            val += 240;                 /* make it look like two digits */\n        if (val > 255) {                /* have two digits */\n            in[next++] = val & 0xff;    /* save the decoded byte */\n            val = 1;                    /* start over */\n        }\n    } while (*hex++);       /* go through the loop with the terminating null */\n    if (len != NULL)\n        *len = next;\n    re = realloc(in, next);\n    return re == NULL ? in : re;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "5f07550c5feeeb6df535a16fbfe96c3a66362e9aa8cd89261d8a5bd26f408883": [
  "local void inf(char *hex, char *what, unsigned step, int win, unsigned len,\n               int err)\n{\n    int ret;\n    unsigned have;\n    unsigned char *in, *out;\n    z_stream strm, copy;\n    gz_header head;\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, win);\n    if (ret != Z_OK) {\n        mem_done(&strm, what);\n        return;\n    }\n    out = malloc(len);                          assert(out != NULL);\n    if (win == 47) {\n        head.extra = out;\n        head.extra_max = len;\n        head.name = out;\n        head.name_max = len;\n        head.comment = out;\n        head.comm_max = len;\n        ret = inflateGetHeader(&strm, &head);   assert(ret == Z_OK);\n    }\n    in = h2b(hex, &have);                       assert(in != NULL);\n    if (step == 0 || step > have)\n        step = have;\n    strm.avail_in = step;\n    have -= step;\n    strm.next_in = in;\n    do {\n        strm.avail_out = len;\n        strm.next_out = out;\n        ret = inflate(&strm, Z_NO_FLUSH);       assert(err == 9 || ret == err);\n        if (ret != Z_OK && ret != Z_BUF_ERROR && ret != Z_NEED_DICT)\n            break;\n        if (ret == Z_NEED_DICT) {\n            ret = inflateSetDictionary(&strm, in, 1);\n                                                assert(ret == Z_DATA_ERROR);\n            mem_limit(&strm, 1);\n            ret = inflateSetDictionary(&strm, out, 0);\n                                                assert(ret == Z_MEM_ERROR);\n            mem_limit(&strm, 0);\n            ((struct inflate_state *)strm.state)->mode = DICT;\n            ret = inflateSetDictionary(&strm, out, 0);\n                                                assert(ret == Z_OK);\n            ret = inflate(&strm, Z_NO_FLUSH);   assert(ret == Z_BUF_ERROR);\n        }\n        ret = inflateCopy(&copy, &strm);        assert(ret == Z_OK);\n        ret = inflateEnd(&copy);                assert(ret == Z_OK);\n        err = 9;                        /* don't care next time around */\n        have += strm.avail_in;\n        strm.avail_in = step > have ? have : step;\n        have -= strm.avail_in;\n    } while (strm.avail_in);\n    free(in);\n    free(out);\n    ret = inflateReset2(&strm, -8);             assert(ret == Z_OK);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    mem_done(&strm, what);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "a0135a6901d4578755e8e4c493688ca0889ecd182f9a0712717d4a01865d03da": [
  "local void cover_support(void)\n{\n    int ret;\n    z_stream strm;\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);                   assert(ret == Z_OK);\n    mem_used(&strm, \"inflate init\");\n    ret = inflatePrime(&strm, 5, 31);           assert(ret == Z_OK);\n    ret = inflatePrime(&strm, -1, 0);           assert(ret == Z_OK);\n    ret = inflateSetDictionary(&strm, Z_NULL, 0);\n                                                assert(ret == Z_STREAM_ERROR);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    mem_done(&strm, \"prime\");\n\n    inf(\"63 0\", \"force window allocation\", 0, -15, 1, Z_OK);\n    inf(\"63 18 5\", \"force window replacement\", 0, -8, 259, Z_OK);\n    inf(\"63 18 68 30 d0 0 0\", \"force split window update\", 4, -8, 259, Z_OK);\n    inf(\"3 0\", \"use fixed blocks\", 0, -15, 1, Z_STREAM_END);\n    inf(\"\", \"bad window size\", 0, 1, 0, Z_STREAM_ERROR);\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit_(&strm, ZLIB_VERSION - 1, (int)sizeof(z_stream));\n                                                assert(ret == Z_VERSION_ERROR);\n    mem_done(&strm, \"wrong version\");\n\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);                   assert(ret == Z_OK);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    fputs(\"inflate built-in memory routines\\n\", stderr);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "e0ec0c9653bebc121d536f4d7a31efb6f2394e60d932f31ab803b875a8e478e9": [
  "local void cover_wrap(void)\n{\n    int ret;\n    z_stream strm, copy;\n    unsigned char dict[257];\n\n    ret = inflate(Z_NULL, 0);                   assert(ret == Z_STREAM_ERROR);\n    ret = inflateEnd(Z_NULL);                   assert(ret == Z_STREAM_ERROR);\n    ret = inflateCopy(Z_NULL, Z_NULL);          assert(ret == Z_STREAM_ERROR);\n    fputs(\"inflate bad parameters\\n\", stderr);\n\n    inf(\"1f 8b 0 0\", \"bad gzip method\", 0, 31, 0, Z_DATA_ERROR);\n    inf(\"1f 8b 8 80\", \"bad gzip flags\", 0, 31, 0, Z_DATA_ERROR);\n    inf(\"77 85\", \"bad zlib method\", 0, 15, 0, Z_DATA_ERROR);\n    inf(\"8 99\", \"set window size from header\", 0, 0, 0, Z_OK);\n    inf(\"78 9c\", \"bad zlib window size\", 0, 8, 0, Z_DATA_ERROR);\n    inf(\"78 9c 63 0 0 0 1 0 1\", \"check adler32\", 0, 15, 1, Z_STREAM_END);\n    inf(\"1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0\", \"bad header crc\", 0, 47, 1,\n        Z_DATA_ERROR);\n    inf(\"1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0\", \"check gzip length\",\n        0, 47, 0, Z_STREAM_END);\n    inf(\"78 90\", \"bad zlib header check\", 0, 47, 0, Z_DATA_ERROR);\n    inf(\"8 b8 0 0 0 1\", \"need dictionary\", 0, 8, 0, Z_NEED_DICT);\n    inf(\"78 9c 63 0\", \"compute adler32\", 0, 15, 1, Z_OK);\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, -8);\n    strm.avail_in = 2;\n    strm.next_in = (void *)\"\\x63\";\n    strm.avail_out = 1;\n    strm.next_out = (void *)&ret;\n    mem_limit(&strm, 1);\n    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);\n    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);\n    mem_limit(&strm, 0);\n    memset(dict, 0, 257);\n    ret = inflateSetDictionary(&strm, dict, 257);\n                                                assert(ret == Z_OK);\n    mem_limit(&strm, (sizeof(struct inflate_state) << 1) + 256);\n    ret = inflatePrime(&strm, 16, 0);           assert(ret == Z_OK);\n    strm.avail_in = 2;\n    strm.next_in = (void *)\"\\x80\";\n    ret = inflateSync(&strm);                   assert(ret == Z_DATA_ERROR);\n    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_STREAM_ERROR);\n    strm.avail_in = 4;\n    strm.next_in = (void *)\"\\0\\0\\xff\\xff\";\n    ret = inflateSync(&strm);                   assert(ret == Z_OK);\n    (void)inflateSyncPoint(&strm);\n    ret = inflateCopy(&copy, &strm);            assert(ret == Z_MEM_ERROR);\n    mem_limit(&strm, 0);\n    ret = inflateUndermine(&strm, 1);           assert(ret == Z_DATA_ERROR);\n    (void)inflateMark(&strm);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    mem_done(&strm, \"miscellaneous, force memory errors\");\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "12cded5e4a6087b2dcc74e56867208d9ce7dee5ad5decd85fe72fb4e504a83d1": [
  "local unsigned pull(void *desc, unsigned char **buf)\n{\n    static unsigned int next = 0;\n    static unsigned char dat[] = {0x63, 0, 2, 0};\n    struct inflate_state *state;\n\n    if (desc == Z_NULL) {\n        next = 0;\n        return 0;   /* no input (already provided at next_in) */\n    }\n    state = (void *)((z_stream *)desc)->state;\n    if (state != Z_NULL)\n        state->mode = SYNC;     /* force an otherwise impossible situation */\n    return next < sizeof(dat) ? (*buf = dat + next++, 1) : 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "ca2c692f89703c89cefba18c746fd7af51c35a4e619b9c9b039e80ab82012e9e": [
  "local int push(void *desc, unsigned char *buf, unsigned len)\n{\n    buf += len;\n    return desc != Z_NULL;      /* force error if desc not null */\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "6e2e7ad19a822edef50eac8861e116df7c06198a10c862a23582e1440368dff9": [
  "local void cover_back(void)\n{\n    int ret;\n    z_stream strm;\n    unsigned char win[32768];\n\n    ret = inflateBackInit_(Z_NULL, 0, win, 0, 0);\n                                                assert(ret == Z_VERSION_ERROR);\n    ret = inflateBackInit(Z_NULL, 0, win);      assert(ret == Z_STREAM_ERROR);\n    ret = inflateBack(Z_NULL, Z_NULL, Z_NULL, Z_NULL, Z_NULL);\n                                                assert(ret == Z_STREAM_ERROR);\n    ret = inflateBackEnd(Z_NULL);               assert(ret == Z_STREAM_ERROR);\n    fputs(\"inflateBack bad parameters\\n\", stderr);\n\n    mem_setup(&strm);\n    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);\n    strm.avail_in = 2;\n    strm.next_in = (void *)\"\\x03\";\n    ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);\n                                                assert(ret == Z_STREAM_END);\n        /* force output error */\n    strm.avail_in = 3;\n    strm.next_in = (void *)\"\\x63\\x00\";\n    ret = inflateBack(&strm, pull, Z_NULL, push, &strm);\n                                                assert(ret == Z_BUF_ERROR);\n        /* force mode error by mucking with state */\n    ret = inflateBack(&strm, pull, &strm, push, Z_NULL);\n                                                assert(ret == Z_STREAM_ERROR);\n    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);\n    mem_done(&strm, \"inflateBack bad state\");\n\n    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);\n    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);\n    fputs(\"inflateBack built-in memory routines\\n\", stderr);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "6f2c961419a516b84edd039ce352819054bb9515142ff301890f5d896ed9b2a7": [
  "local int try(char *hex, char *id, int err)\n{\n    int ret;\n    unsigned len, size;\n    unsigned char *in, *out, *win;\n    char *prefix;\n    z_stream strm;\n\n    /* convert to hex */\n    in = h2b(hex, &len);\n    assert(in != NULL);\n\n    /* allocate work areas */\n    size = len << 3;\n    out = malloc(size);\n    assert(out != NULL);\n    win = malloc(32768);\n    assert(win != NULL);\n    prefix = malloc(strlen(id) + 6);\n    assert(prefix != NULL);\n\n    /* first with inflate */\n    strcpy(prefix, id);\n    strcat(prefix, \"-late\");\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, err < 0 ? 47 : -15);\n    assert(ret == Z_OK);\n    strm.avail_in = len;\n    strm.next_in = in;\n    do {\n        strm.avail_out = size;\n        strm.next_out = out;\n        ret = inflate(&strm, Z_TREES);\n        assert(ret != Z_STREAM_ERROR && ret != Z_MEM_ERROR);\n        if (ret == Z_DATA_ERROR || ret == Z_NEED_DICT)\n            break;\n    } while (strm.avail_in || strm.avail_out == 0);\n    if (err) {\n        assert(ret == Z_DATA_ERROR);\n        assert(strcmp(id, strm.msg) == 0);\n    }\n    inflateEnd(&strm);\n    mem_done(&strm, prefix);\n\n    /* then with inflateBack */\n    if (err >= 0) {\n        strcpy(prefix, id);\n        strcat(prefix, \"-back\");\n        mem_setup(&strm);\n        ret = inflateBackInit(&strm, 15, win);\n        assert(ret == Z_OK);\n        strm.avail_in = len;\n        strm.next_in = in;\n        ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);\n        assert(ret != Z_STREAM_ERROR);\n        if (err) {\n            assert(ret == Z_DATA_ERROR);\n            assert(strcmp(id, strm.msg) == 0);\n        }\n        inflateBackEnd(&strm);\n        mem_done(&strm, prefix);\n    }\n\n    /* clean up */\n    free(prefix);\n    free(win);\n    free(out);\n    free(in);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "454dd63cf64b567c7af83e018129070f3579cb374fe324fd984393869d5b0dde": [
  "local void cover_inflate(void)\n{\n    try(\"0 0 0 0 0\", \"invalid stored block lengths\", 1);\n    try(\"3 0\", \"fixed\", 0);\n    try(\"6\", \"invalid block type\", 1);\n    try(\"1 1 0 fe ff 0\", \"stored\", 0);\n    try(\"fc 0 0\", \"too many length or distance symbols\", 1);\n    try(\"4 0 fe ff\", \"invalid code lengths set\", 1);\n    try(\"4 0 24 49 0\", \"invalid bit length repeat\", 1);\n    try(\"4 0 24 e9 ff ff\", \"invalid bit length repeat\", 1);\n    try(\"4 0 24 e9 ff 6d\", \"invalid code -- missing end-of-block\", 1);\n    try(\"4 80 49 92 24 49 92 24 71 ff ff 93 11 0\",\n        \"invalid literal/lengths set\", 1);\n    try(\"4 80 49 92 24 49 92 24 f b4 ff ff c3 84\", \"invalid distances set\", 1);\n    try(\"4 c0 81 8 0 0 0 0 20 7f eb b 0 0\", \"invalid literal/length code\", 1);\n    try(\"2 7e ff ff\", \"invalid distance code\", 1);\n    try(\"c c0 81 0 0 0 0 0 90 ff 6b 4 0\", \"invalid distance too far back\", 1);\n\n    /* also trailer mismatch just in inflate() */\n    try(\"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1\", \"incorrect data check\", -1);\n    try(\"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1\",\n        \"incorrect length check\", -1);\n    try(\"5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c\", \"pull 17\", 0);\n    try(\"5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f\",\n        \"long code\", 0);\n    try(\"ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f\", \"length extra\", 0);\n    try(\"ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c\",\n        \"long distance and extra\", 0);\n    try(\"ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \"\n        \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6\", \"window end\", 0);\n    inf(\"2 8 20 80 0 3 0\", \"inflate_fast TYPE return\", 0, -15, 258,\n        Z_STREAM_END);\n    inf(\"63 18 5 40 c 0\", \"window wrap\", 3, -8, 300, Z_OK);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "a953c0efcf522e13299af49a784b54ba448f61c670d7f90ba5de6a01152d6aa1": [
  "local void cover_trees(void)\n{\n    int ret;\n    unsigned bits;\n    unsigned short lens[16], work[16];\n    code *next, table[ENOUGH_DISTS];\n\n    /* we need to call inflate_table() directly in order to manifest not-\n       enough errors, since zlib insures that enough is always enough */\n    for (bits = 0; bits < 15; bits++)\n        lens[bits] = (unsigned short)(bits + 1);\n    lens[15] = 15;\n    next = table;\n    bits = 15;\n    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);\n                                                assert(ret == 1);\n    next = table;\n    bits = 1;\n    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);\n                                                assert(ret == 1);\n    fputs(\"inflate_table not enough errors\\n\", stderr);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "5f6af50d32a11205e16116278d579656d66bd559cc693b1dd91a30af334fb497": [
  "local void cover_fast(void)\n{\n    inf(\"e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68\"\n        \" ff 7f 0f 0 0 0\", \"fast length extra bits\", 0, -8, 258, Z_DATA_ERROR);\n    inf(\"25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49\"\n        \" 50 fe ff ff 3f 0 0\", \"fast distance extra bits\", 0, -8, 258,\n        Z_DATA_ERROR);\n    inf(\"3 7e 0 0 0 0 0\", \"fast invalid distance code\", 0, -8, 258,\n        Z_DATA_ERROR);\n    inf(\"1b 7 0 0 0 0 0\", \"fast invalid literal/length code\", 0, -8, 258,\n        Z_DATA_ERROR);\n    inf(\"d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0\",\n        \"fast 2nd level codes and too far back\", 0, -8, 258, Z_DATA_ERROR);\n    inf(\"63 18 5 8c 10 8 0 0 0 0\", \"very common case\", 0, -8, 259, Z_OK);\n    inf(\"63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0\",\n        \"contiguous and wrap around window\", 6, -8, 259, Z_OK);\n    inf(\"63 0 3 0 0 0 0 0\", \"copy direct from output\", 0, -8, 259,\n        Z_STREAM_END);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "a77a91ac2e33e117905c64e2651d49cfe0a3c25ed56efbae89b7e6b5a3a20d85": [
  "int main(void)\n{\n    fprintf(stderr, \"%s\\n\", zlibVersion());\n    cover_support();\n    cover_wrap();\n    cover_back();\n    cover_inflate();\n    cover_trees();\n    cover_fast();\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/infcover.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/infcover.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/infcover.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/infcover.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/infcover.c"
   ]
  }
 ],
 "797c2c2dfe6d627ccfe7424ce7e6f12106ab58842dab4b17391f972178d3a81a": [
  "void myfree(void *q, void *p)\n{\n    (void)q;\n    free(p);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "test/example.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "test/example.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "test/example.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "test/example.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "test/example.c"
   ]
  }
 ],
 "182135486f2a5a9a0644c8253abaf0e18e58264f10df04f12e6373494f67b76d": [
  "void do_banner()\n{\n    printf(\"MiniZip 1.1, demo of zLib + MiniZip64 package, written by Gilles Vollant\\n\");\n    printf(\"more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\\n\\n\");\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "32182f68e395e2296b96b61b0d576d5c635003aae043e5f7b71c6c2c82b85241": [
  "void do_help()\n{\n    printf(\"Usage : minizip [-o] [-a] [-0 to -9] [-p password] [-j] file.zip [files_to_add]\\n\\n\" \\\n           \"  -o  Overwrite existing file.zip\\n\" \\\n           \"  -a  Append to existing file.zip\\n\" \\\n           \"  -0  Store only\\n\" \\\n           \"  -1  Compress faster\\n\" \\\n           \"  -9  Compress better\\n\\n\" \\\n           \"  -j  exclude path. store only the file name.\\n\\n\");\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/minizip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "cfe910d2d47329bca3eba1cbdef9fdad4c6c973766f7ed934b08e5f2a9f2e393": [
  "int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)\n{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = FOPEN_FUNC(filenameinzip,\"rb\");\n\n   unsigned long size_read = 0;\n   unsigned long total_read = 0;\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = (int)fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32(calculate_crc,buf,size_read);\n            total_read += size_read;\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\", filenameinzip, calculate_crc);\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "e7aa1446bd6644cabb0b54ef2ec2a25e3f067ef4297bb6fa4419009d0a82568d": [
  "int isLargeFile(const char* filename)\n{\n  int largeFile = 0;\n  ZPOS64_T pos = 0;\n  FILE* pFile = FOPEN_FUNC(filename, \"rb\");\n\n  if(pFile != NULL)\n  {\n    int n = FSEEKO_FUNC(pFile, 0, SEEK_END);\n    pos = FTELLO_FUNC(pFile);\n\n                printf(\"File : %s is %lld bytes\\n\", filename, pos);\n\n    if(pos >= 0xffffffff)\n     largeFile = 1;\n\n                fclose(pFile);\n  }\n\n return largeFile;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "6cb777a7b0d42b89520046f67f95a25d86fa544d711d4125f4b152fa30c1c20e": [
  "local void free_datablock(linkedlist_datablock_internal* ldi)\n{\n    while (ldi!=NULL)\n    {\n        linkedlist_datablock_internal* ldinext = ldi->next_datablock;\n        TRYFREE(ldi);\n        ldi = ldinext;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "b74fc153822840abc551fce88c3cd577c4abf1d9925ad40ce1dfd5fd0236096b": [
  "local void init_linkedlist(linkedlist_data* ll)\n{\n    ll->first_block = ll->last_block = NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "5c172b93235334ba0fbe37dba9c71d74f887792e3e5d43144cf56119a8a0c82b": [
  "local void free_linkedlist(linkedlist_data* ll)\n{\n    free_datablock(ll->first_block);\n    ll->first_block = ll->last_block = NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "64a8c1aa6a8801b9156153503519392f0a82a1d6dc8f1d3a42d7441a35787865": [
  "local int add_data_in_datablock(linkedlist_data* ll, const void* buf, uLong len)\n{\n    linkedlist_datablock_internal* ldi;\n    const unsigned char* from_copy;\n\n    if (ll==NULL)\n        return ZIP_INTERNALERROR;\n\n    if (ll->last_block == NULL)\n    {\n        ll->first_block = ll->last_block = allocate_new_datablock();\n        if (ll->first_block == NULL)\n            return ZIP_INTERNALERROR;\n    }\n\n    ldi = ll->last_block;\n    from_copy = (unsigned char*)buf;\n\n    while (len>0)\n    {\n        uInt copy_this;\n        uInt i;\n        unsigned char* to_copy;\n\n        if (ldi->avail_in_this_block==0)\n        {\n            ldi->next_datablock = allocate_new_datablock();\n            if (ldi->next_datablock == NULL)\n                return ZIP_INTERNALERROR;\n            ldi = ldi->next_datablock ;\n            ll->last_block = ldi;\n        }\n\n        if (ldi->avail_in_this_block < len)\n            copy_this = (uInt)ldi->avail_in_this_block;\n        else\n            copy_this = (uInt)len;\n\n        to_copy = &(ldi->data[ldi->filled_in_this_block]);\n\n        for (i=0;i<copy_this;i++)\n            *(to_copy+i)=*(from_copy+i);\n\n        ldi->filled_in_this_block += copy_this;\n        ldi->avail_in_this_block -= copy_this;\n        from_copy += copy_this ;\n        len -= copy_this;\n    }\n    return ZIP_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "12754c9e8e2a0751e94f8209946bd38c1d918daa8ff1db7e32ce462024f3bc76": [
  "local int zip64local_putValue (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte)\n{\n    unsigned char buf[8];\n    int n;\n    for (n = 0; n < nbByte; n++)\n    {\n        buf[n] = (unsigned char)(x & 0xff);\n        x >>= 8;\n    }\n    if (x != 0)\n      {     /* data overflow - hack for ZIP64 (X Roche) */\n      for (n = 0; n < nbByte; n++)\n        {\n          buf[n] = 0xff;\n        }\n      }\n\n    if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)\n        return ZIP_ERRNO;\n    else\n        return ZIP_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "6ddf88558862e7020a6bd11a87e93985b3814231bbc85f271f971238ae6fb5c5": [
  "local void zip64local_putValue_inmemory (void* dest, ZPOS64_T x, int nbByte)\n{\n    unsigned char* buf=(unsigned char*)dest;\n    int n;\n    for (n = 0; n < nbByte; n++) {\n        buf[n] = (unsigned char)(x & 0xff);\n        x >>= 8;\n    }\n\n    if (x != 0)\n    {     /* data overflow - hack for ZIP64 */\n       for (n = 0; n < nbByte; n++)\n       {\n          buf[n] = 0xff;\n       }\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "13b6d34ff0978271dc4bd9f04897afdba1b47857b6d6381db7c8ca31a4ab0873": [
  "local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm)\n{\n    uLong year = (uLong)ptm->tm_year;\n    if (year>=1980)\n        year-=1980;\n    else if (year>=80)\n        year-=80;\n    return\n      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |\n        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "d837ebee181053329484eb7fda7581b5b5f38d70929024fa3ec0b759ea801057": [
  "local int zip64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def,voidpf filestream,int* pi)\n{\n    unsigned char c;\n    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);\n    if (err==1)\n    {\n        *pi = (int)c;\n        return ZIP_OK;\n    }\n    else\n    {\n        if (ZERROR64(*pzlib_filefunc_def,filestream))\n            return ZIP_ERRNO;\n        else\n            return ZIP_EOF;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "5b4f37246df78c33b30ed2ab5f4123bf155df278bec0b197385bf302b56bd192": [
  "local int zip64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)\n{\n    uLong x ;\n    int i = 0;\n    int err;\n\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x = (uLong)i;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<8;\n\n    if (err==ZIP_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "98075119a9fde1ae6d6092322d248a4b23c12e9c91dc7a6a288af38ba90e7a80": [
  "local int zip64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)\n{\n    uLong x ;\n    int i = 0;\n    int err;\n\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x = (uLong)i;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<8;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<16;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<24;\n\n    if (err==ZIP_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "d12626db414af1047c8899da4bc49f139d2c441b2246565c4904177169aeefdc": [
  "local int zip64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX)\n{\n  ZPOS64_T x;\n  int i = 0;\n  int err;\n\n  err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x = (ZPOS64_T)i;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<8;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<16;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<24;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<32;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<40;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<48;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<56;\n\n  if (err==ZIP_OK)\n    *pX = x;\n  else\n    *pX = 0;\n\n  return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "01b0d090080af23a7aa58d46970061bb2dbc9ff8495f71da79b4a3237394d8de": [
  "local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)\n{\n  unsigned char* buf;\n  ZPOS64_T uSizeFile;\n  ZPOS64_T uBackRead;\n  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n  ZPOS64_T uPosFound=0;\n\n  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n    return 0;\n\n\n  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n  if (uMaxBack>uSizeFile)\n    uMaxBack = uSizeFile;\n\n  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n  if (buf==NULL)\n    return 0;\n\n  uBackRead = 4;\n  while (uBackRead<uMaxBack)\n  {\n    uLong uReadSize;\n    ZPOS64_T uReadPos ;\n    int i;\n    if (uBackRead+BUFREADCOMMENT>uMaxBack)\n      uBackRead = uMaxBack;\n    else\n      uBackRead+=BUFREADCOMMENT;\n    uReadPos = uSizeFile-uBackRead ;\n\n    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      break;\n\n    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n      break;\n\n    for (i=(int)uReadSize-3; (i--)>0;)\n      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n        ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n      {\n        uPosFound = uReadPos+i;\n        break;\n      }\n\n      if (uPosFound!=0)\n        break;\n  }\n  TRYFREE(buf);\n  return uPosFound;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "904180685ea84a2676fd3008084b87c2c13706aee059ca124de581cfc0f2d919": [
  "local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)\n{\n  unsigned char* buf;\n  ZPOS64_T uSizeFile;\n  ZPOS64_T uBackRead;\n  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n  ZPOS64_T uPosFound=0;\n  uLong uL;\n  ZPOS64_T relativeOffset;\n\n  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n    return 0;\n\n  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n  if (uMaxBack>uSizeFile)\n    uMaxBack = uSizeFile;\n\n  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n  if (buf==NULL)\n    return 0;\n\n  uBackRead = 4;\n  while (uBackRead<uMaxBack)\n  {\n    uLong uReadSize;\n    ZPOS64_T uReadPos;\n    int i;\n    if (uBackRead+BUFREADCOMMENT>uMaxBack)\n      uBackRead = uMaxBack;\n    else\n      uBackRead+=BUFREADCOMMENT;\n    uReadPos = uSizeFile-uBackRead ;\n\n    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      break;\n\n    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n      break;\n\n    for (i=(int)uReadSize-3; (i--)>0;)\n    {\n      // Signature \"0x07064b50\" Zip64 end of central directory locater\n      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))\n      {\n        uPosFound = uReadPos+i;\n        break;\n      }\n    }\n\n      if (uPosFound!=0)\n        break;\n  }\n\n  TRYFREE(buf);\n  if (uPosFound == 0)\n    return 0;\n\n  /* Zip64 end of central directory locator */\n  if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)\n    return 0;\n\n  /* the signature, already checked */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n\n  /* number of the disk with the start of the zip64 end of  central directory */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n  if (uL != 0)\n    return 0;\n\n  /* relative offset of the zip64 end of central directory record */\n  if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)\n    return 0;\n\n  /* total number of disks */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n  if (uL != 1)\n    return 0;\n\n  /* Goto Zip64 end of central directory record */\n  if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)\n    return 0;\n\n  /* the signature */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n\n  if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'\n    return 0;\n\n  return relativeOffset;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "5bcf5433a3bafd1b256152e5bb7e04605b99e52a8ae4af7240afcebbcea0601f": [
  "int LoadCentralDirectoryRecord(zip64_internal* pziinit)\n{\n  int err=ZIP_OK;\n  ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n\n  ZPOS64_T size_central_dir;     /* size of the central directory  */\n  ZPOS64_T offset_central_dir;   /* offset of start of central directory */\n  ZPOS64_T central_pos;\n  uLong uL;\n\n  uLong number_disk;          /* number of the current dist, used for\n                              spaning ZIP, unsupported, always 0*/\n  uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                              for spaning ZIP, unsupported, always 0*/\n  ZPOS64_T number_entry;\n  ZPOS64_T number_entry_CD;      /* total number of entries in\n                                the central dir\n                                (same than number_entry on nospan) */\n  uLong VersionMadeBy;\n  uLong VersionNeeded;\n  uLong size_comment;\n\n  int hasZIP64Record = 0;\n\n  // check first if we find a ZIP64 record\n  central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);\n  if(central_pos > 0)\n  {\n    hasZIP64Record = 1;\n  }\n  else if(central_pos == 0)\n  {\n    central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);\n  }\n\n/* disable to allow appending to empty ZIP archive\n        if (central_pos==0)\n            err=ZIP_ERRNO;\n*/\n\n  if(hasZIP64Record)\n  {\n    ZPOS64_T sizeEndOfCentralDirectory;\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* size of zip64 end of central directory record */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version made by */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version needed to extract */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory on this disk */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* offset of start of central directory with respect to the\n    starting disk number */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    // TODO..\n    // read the comment from the standard central header.\n    size_comment = 0;\n  }\n  else\n  {\n    // Read End of central Directory info\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central dir on this disk */\n    number_entry = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      number_entry = uL;\n\n    /* total number of entries in the central dir */\n    number_entry_CD = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      number_entry_CD = uL;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    size_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      size_central_dir = uL;\n\n    /* offset of start of central directory with respect to the starting disk number */\n    offset_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      offset_central_dir = uL;\n\n\n    /* zipfile global comment length */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)\n      err=ZIP_ERRNO;\n  }\n\n  if ((central_pos<offset_central_dir+size_central_dir) &&\n    (err==ZIP_OK))\n    err=ZIP_BADZIPFILE;\n\n  if (err!=ZIP_OK)\n  {\n    ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);\n    return ZIP_ERRNO;\n  }\n\n  if (size_comment>0)\n  {\n    pziinit->globalcomment = (char*)ALLOC(size_comment+1);\n    if (pziinit->globalcomment)\n    {\n      size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);\n      pziinit->globalcomment[size_comment]=0;\n    }\n  }\n\n  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);\n  pziinit->add_position_when_writing_offset = byte_before_the_zipfile;\n\n  {\n    ZPOS64_T size_central_dir_to_read = size_central_dir;\n    size_t buf_size = SIZEDATA_INDATABLOCK;\n    void* buf_read = (void*)ALLOC(buf_size);\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    while ((size_central_dir_to_read>0) && (err==ZIP_OK))\n    {\n      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;\n      if (read_this > size_central_dir_to_read)\n        read_this = size_central_dir_to_read;\n\n      if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)\n        err=ZIP_ERRNO;\n\n      if (err==ZIP_OK)\n        err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);\n\n      size_central_dir_to_read-=read_this;\n    }\n    TRYFREE(buf_read);\n  }\n  pziinit->begin_pos = byte_before_the_zipfile;\n  pziinit->number_entry = number_entry_CD;\n\n  if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)\n    err=ZIP_ERRNO;\n\n  return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "7317671171908e1aef804bed6b4e08a519939433399f8a746beb4e43dcf034bb": [
  "extern zipFile ZEXPORT zipOpen3 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def)\n{\n    zip64_internal ziinit;\n    zip64_internal* zi;\n    int err=ZIP_OK;\n\n    ziinit.z_filefunc.zseek32_file = NULL;\n    ziinit.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);\n    else\n        ziinit.z_filefunc = *pzlib_filefunc64_32_def;\n\n    ziinit.filestream = ZOPEN64(ziinit.z_filefunc,\n                  pathname,\n                  (append == APPEND_STATUS_CREATE) ?\n                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :\n                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));\n\n    if (ziinit.filestream == NULL)\n        return NULL;\n\n    if (append == APPEND_STATUS_CREATEAFTER)\n        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);\n\n    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);\n    ziinit.in_opened_file_inzip = 0;\n    ziinit.ci.stream_initialised = 0;\n    ziinit.number_entry = 0;\n    ziinit.add_position_when_writing_offset = 0;\n    init_linkedlist(&(ziinit.central_dir));\n\n\n\n    zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));\n    if (zi==NULL)\n    {\n        ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);\n        return NULL;\n    }\n\n    /* now we add file in a zipfile */\n#    ifndef NO_ADDFILEINEXISTINGZIP\n    ziinit.globalcomment = NULL;\n    if (append == APPEND_STATUS_ADDINZIP)\n    {\n      // Read and Cache Central Directory Records\n      err = LoadCentralDirectoryRecord(&ziinit);\n    }\n\n    if (globalcomment)\n    {\n      *globalcomment = ziinit.globalcomment;\n    }\n#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n\n    if (err != ZIP_OK)\n    {\n#    ifndef NO_ADDFILEINEXISTINGZIP\n        TRYFREE(ziinit.globalcomment);\n#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n        TRYFREE(zi);\n        return NULL;\n    }\n    else\n    {\n        *zi = ziinit;\n        return (zipFile)zi;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "44746d51debc4aeab4940f86a7777a3469dab855d5666213822be59583d3ee97": [
  "extern zipFile ZEXPORT zipOpen2 (const char *pathname, int append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc32_def)\n{\n    if (pzlib_filefunc32_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);\n        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);\n    }\n    else\n        return zipOpen3(pathname, append, globalcomment, NULL);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "8534a778fb458936fcd9a662c88741ac63a538e0c0c5cbdf76ab0228955ed61c": [
  "extern zipFile ZEXPORT zipOpen2_64 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    if (pzlib_filefunc_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;\n        zlib_filefunc64_32_def_fill.ztell32_file = NULL;\n        zlib_filefunc64_32_def_fill.zseek32_file = NULL;\n        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);\n    }\n    else\n        return zipOpen3(pathname, append, globalcomment, NULL);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "880a1243950e8e595dac346df57410936762fcc08959d2bb4c08a7b08d847061": [
  "extern zipFile ZEXPORT zipOpen (const char* pathname, int append)\n{\n    return zipOpen3((const void*)pathname,append,NULL,NULL);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "7bdcf25e06144aa571f8c513c186a33010d882b5a535f759995070e23ec1dc2a": [
  "extern zipFile ZEXPORT zipOpen64 (const void* pathname, int append)\n{\n    return zipOpen3(pathname,append,NULL,NULL);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "7c393dfd5817d255b6b480c6adfd6639ba5734ef7e32e4ba2596d04f50a45731": [
  "int Write_LocalFileHeader(zip64_internal* zi, const char* filename, uInt size_extrafield_local, const void* extrafield_local)\n{\n  /* write the local header */\n  int err;\n  uInt size_filename = (uInt)strlen(filename);\n  uInt size_extrafield = size_extrafield_local;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);\n\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);\n\n  // CRC / Compressed size / Uncompressed size will be filled in later and rewritten later\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */\n  }\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);\n\n  if(zi->ci.zip64)\n  {\n    size_extrafield += 20;\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);\n\n  if ((err==ZIP_OK) && (size_filename > 0))\n  {\n    if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)\n      err = ZIP_ERRNO;\n  }\n\n  if ((err==ZIP_OK) && (size_extrafield_local > 0))\n  {\n    if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)\n      err = ZIP_ERRNO;\n  }\n\n\n  if ((err==ZIP_OK) && (zi->ci.zip64))\n  {\n      // write the Zip64 extended info\n      short HeaderID = 1;\n      short DataSize = 16;\n      ZPOS64_T CompressedSize = 0;\n      ZPOS64_T UncompressedSize = 0;\n\n      // Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)\n      zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);\n\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)HeaderID,2);\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)DataSize,2);\n\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);\n  }\n\n  return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "513a659a94f34c7628b0471841aef3239359f8d420704cbbe404df6a0dab3fe7": [
  "extern int ZEXPORT zipOpenNewFileInZip4 (zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                         const void* extrafield_local, uInt size_extrafield_local,\n                                         const void* extrafield_global, uInt size_extrafield_global,\n                                         const char* comment, int method, int level, int raw,\n                                         int windowBits,int memLevel, int strategy,\n                                         const char* password, uLong crcForCrypting,\n                                         uLong versionMadeBy, uLong flagBase)\n{\n    return zipOpenNewFileInZip4_64 (file, filename, zipfi,\n                                 extrafield_local, size_extrafield_local,\n                                 extrafield_global, size_extrafield_global,\n                                 comment, method, level, raw,\n                                 windowBits, memLevel, strategy,\n                                 password, crcForCrypting, versionMadeBy, flagBase, 0);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "737221a3f01443edefd65650a12bc91c7fd5abc7cf3c0db07b98ac04dad0a346": [
  "extern int ZEXPORT zipOpenNewFileInZip3 (zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                         const void* extrafield_local, uInt size_extrafield_local,\n                                         const void* extrafield_global, uInt size_extrafield_global,\n                                         const char* comment, int method, int level, int raw,\n                                         int windowBits,int memLevel, int strategy,\n                                         const char* password, uLong crcForCrypting)\n{\n    return zipOpenNewFileInZip4_64 (file, filename, zipfi,\n                                 extrafield_local, size_extrafield_local,\n                                 extrafield_global, size_extrafield_global,\n                                 comment, method, level, raw,\n                                 windowBits, memLevel, strategy,\n                                 password, crcForCrypting, VERSIONMADEBY, 0, 0);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "08e98c477c959f22a9f1a8ff7eb6660a017cf34b66b26e65df2120ebc927c0f4": [
  "extern int ZEXPORT zipOpenNewFileInZip3_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                         const void* extrafield_local, uInt size_extrafield_local,\n                                         const void* extrafield_global, uInt size_extrafield_global,\n                                         const char* comment, int method, int level, int raw,\n                                         int windowBits,int memLevel, int strategy,\n                                         const char* password, uLong crcForCrypting, int zip64)\n{\n    return zipOpenNewFileInZip4_64 (file, filename, zipfi,\n                                 extrafield_local, size_extrafield_local,\n                                 extrafield_global, size_extrafield_global,\n                                 comment, method, level, raw,\n                                 windowBits, memLevel, strategy,\n                                 password, crcForCrypting, VERSIONMADEBY, 0, zip64);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "2f784521113b7a1a3d07feb3ad69f15edde22e38bdd87e0eb523faed55f1b6db": [
  "extern int ZEXPORT zipOpenNewFileInZip2(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                        const void* extrafield_local, uInt size_extrafield_local,\n                                        const void* extrafield_global, uInt size_extrafield_global,\n                                        const char* comment, int method, int level, int raw)\n{\n    return zipOpenNewFileInZip4_64 (file, filename, zipfi,\n                                 extrafield_local, size_extrafield_local,\n                                 extrafield_global, size_extrafield_global,\n                                 comment, method, level, raw,\n                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                 NULL, 0, VERSIONMADEBY, 0, 0);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "e3e2adce0a9711d233f54ff93a2e271873cce6221609f427b27b406f79e8c114": [
  "extern int ZEXPORT zipOpenNewFileInZip2_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                        const void* extrafield_local, uInt size_extrafield_local,\n                                        const void* extrafield_global, uInt size_extrafield_global,\n                                        const char* comment, int method, int level, int raw, int zip64)\n{\n    return zipOpenNewFileInZip4_64 (file, filename, zipfi,\n                                 extrafield_local, size_extrafield_local,\n                                 extrafield_global, size_extrafield_global,\n                                 comment, method, level, raw,\n                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                 NULL, 0, VERSIONMADEBY, 0, zip64);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "ba87580f8ece6af3b5174b428c712595aa50681392fc0c3994508455ea7db100": [
  "extern int ZEXPORT zipOpenNewFileInZip64 (zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                        const void* extrafield_local, uInt size_extrafield_local,\n                                        const void*extrafield_global, uInt size_extrafield_global,\n                                        const char* comment, int method, int level, int zip64)\n{\n    return zipOpenNewFileInZip4_64 (file, filename, zipfi,\n                                 extrafield_local, size_extrafield_local,\n                                 extrafield_global, size_extrafield_global,\n                                 comment, method, level, 0,\n                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                 NULL, 0, VERSIONMADEBY, 0, zip64);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "cc28a9051227d6e1f0282ea8c70c41c8ecdd470fbdd562f4e6ac1a0c3877c77b": [
  "extern int ZEXPORT zipOpenNewFileInZip (zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                        const void* extrafield_local, uInt size_extrafield_local,\n                                        const void*extrafield_global, uInt size_extrafield_global,\n                                        const char* comment, int method, int level)\n{\n    return zipOpenNewFileInZip4_64 (file, filename, zipfi,\n                                 extrafield_local, size_extrafield_local,\n                                 extrafield_global, size_extrafield_global,\n                                 comment, method, level, 0,\n                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                 NULL, 0, VERSIONMADEBY, 0, 0);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "a37f18c350300e2411093bed601cc504b090d6b04f9e153a1b6d2634991ed47d": [
  "local int zip64FlushWriteBuffer(zip64_internal* zi)\n{\n    int err=ZIP_OK;\n\n    if (zi->ci.encrypt != 0)\n    {\n#ifndef NOCRYPT\n        uInt i;\n        int t;\n        for (i=0;i<zi->ci.pos_in_buffered_data;i++)\n            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);\n#endif\n    }\n\n    if (ZWRITE64(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)\n      err = ZIP_ERRNO;\n\n    zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;\n\n#ifdef HAVE_BZIP2\n    if(zi->ci.method == Z_BZIP2ED)\n    {\n      zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;\n      zi->ci.bstream.total_in_lo32 = 0;\n      zi->ci.bstream.total_in_hi32 = 0;\n    }\n    else\n#endif\n    {\n      zi->ci.totalUncompressedData += zi->ci.stream.total_in;\n      zi->ci.stream.total_in = 0;\n    }\n\n\n    zi->ci.pos_in_buffered_data = 0;\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "0bedb12636058897ab50864a381692360c781d6295f414eacb1d5140eb79516b": [
  "extern int ZEXPORT zipWriteInFileInZip (zipFile file,const void* buf,unsigned int len)\n{\n    zip64_internal* zi;\n    int err=ZIP_OK;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 0)\n        return ZIP_PARAMERROR;\n\n    zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);\n\n#ifdef HAVE_BZIP2\n    if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))\n    {\n      zi->ci.bstream.next_in = (void*)buf;\n      zi->ci.bstream.avail_in = len;\n      err = BZ_RUN_OK;\n\n      while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))\n      {\n        if (zi->ci.bstream.avail_out == 0)\n        {\n          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n            err = ZIP_ERRNO;\n          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;\n          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;\n        }\n\n\n        if(err != BZ_RUN_OK)\n          break;\n\n        if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n        {\n          uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;\n//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;\n          err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);\n\n          zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;\n        }\n      }\n\n      if(err == BZ_RUN_OK)\n        err = ZIP_OK;\n    }\n    else\n#endif\n    {\n      zi->ci.stream.next_in = (Bytef*)buf;\n      zi->ci.stream.avail_in = len;\n\n      while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))\n      {\n          if (zi->ci.stream.avail_out == 0)\n          {\n              if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n                  err = ZIP_ERRNO;\n              zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n              zi->ci.stream.next_out = zi->ci.buffered_data;\n          }\n\n\n          if(err != ZIP_OK)\n              break;\n\n          if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n          {\n              uLong uTotalOutBefore = zi->ci.stream.total_out;\n              err=deflate(&zi->ci.stream,  Z_NO_FLUSH);\n              if(uTotalOutBefore > zi->ci.stream.total_out)\n              {\n                int bBreak = 0;\n                bBreak++;\n              }\n\n              zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n          }\n          else\n          {\n              uInt copy_this,i;\n              if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)\n                  copy_this = zi->ci.stream.avail_in;\n              else\n                  copy_this = zi->ci.stream.avail_out;\n\n              for (i = 0; i < copy_this; i++)\n                  *(((char*)zi->ci.stream.next_out)+i) =\n                      *(((const char*)zi->ci.stream.next_in)+i);\n              {\n                  zi->ci.stream.avail_in -= copy_this;\n                  zi->ci.stream.avail_out-= copy_this;\n                  zi->ci.stream.next_in+= copy_this;\n                  zi->ci.stream.next_out+= copy_this;\n                  zi->ci.stream.total_in+= copy_this;\n                  zi->ci.stream.total_out+= copy_this;\n                  zi->ci.pos_in_buffered_data += copy_this;\n              }\n          }\n      }// while(...)\n    }\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "38a680d9ace1447ed2f6902f8470544e3f40041cebc326b4c3ff32ec75183451": [
  "extern int ZEXPORT zipCloseFileInZipRaw (zipFile file, uLong uncompressed_size, uLong crc32)\n{\n    return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "2d559d6b442738123f4b105324581045e4263291c4ecca8f2c29c871a7428b2c": [
  "extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_size, uLong crc32)\n{\n    zip64_internal* zi;\n    ZPOS64_T compressed_size;\n    uLong invalidValue = 0xffffffff;\n    short datasize = 0;\n    int err=ZIP_OK;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 0)\n        return ZIP_PARAMERROR;\n    zi->ci.stream.avail_in = 0;\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n                {\n                        while (err==ZIP_OK)\n                        {\n                                uLong uTotalOutBefore;\n                                if (zi->ci.stream.avail_out == 0)\n                                {\n                                        if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n                                                err = ZIP_ERRNO;\n                                        zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n                                        zi->ci.stream.next_out = zi->ci.buffered_data;\n                                }\n                                uTotalOutBefore = zi->ci.stream.total_out;\n                                err=deflate(&zi->ci.stream,  Z_FINISH);\n                                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n                        }\n                }\n    else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n#ifdef HAVE_BZIP2\n      err = BZ_FINISH_OK;\n      while (err==BZ_FINISH_OK)\n      {\n        uLong uTotalOutBefore;\n        if (zi->ci.bstream.avail_out == 0)\n        {\n          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n            err = ZIP_ERRNO;\n          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;\n          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;\n        }\n        uTotalOutBefore = zi->ci.bstream.total_out_lo32;\n        err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);\n        if(err == BZ_STREAM_END)\n          err = Z_STREAM_END;\n\n        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);\n      }\n\n      if(err == BZ_FINISH_OK)\n        err = ZIP_OK;\n#endif\n    }\n\n    if (err==Z_STREAM_END)\n        err=ZIP_OK; /* this is normal */\n\n    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))\n                {\n        if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)\n            err = ZIP_ERRNO;\n                }\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n    {\n        int tmp_err = deflateEnd(&zi->ci.stream);\n        if (err == ZIP_OK)\n            err = tmp_err;\n        zi->ci.stream_initialised = 0;\n    }\n#ifdef HAVE_BZIP2\n    else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n      int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);\n                        if (err==ZIP_OK)\n                                err = tmperr;\n                        zi->ci.stream_initialised = 0;\n    }\n#endif\n\n    if (!zi->ci.raw)\n    {\n        crc32 = (uLong)zi->ci.crc32;\n        uncompressed_size = zi->ci.totalUncompressedData;\n    }\n    compressed_size = zi->ci.totalCompressedData;\n\n#    ifndef NOCRYPT\n    compressed_size += zi->ci.crypt_header_size;\n#    endif\n\n    // update Current Item crc and sizes,\n    if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)\n    {\n      /*version Made by*/\n      zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);\n      /*version needed*/\n      zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);\n\n    }\n\n    zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/\n\n\n    if(compressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/\n\n    /// set internal file attributes field\n    if (zi->ci.stream.data_type == Z_ASCII)\n        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);\n\n    if(uncompressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/\n\n    // Add ZIP64 extra info field for uncompressed size\n    if(uncompressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for compressed size\n    if(compressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for relative offset to local file header of current file\n    if(zi->ci.pos_local_header >= 0xffffffff)\n      datasize += 8;\n\n    if(datasize > 0)\n    {\n      char* p = NULL;\n\n      if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)\n      {\n        // we can not write more data to the buffer that we have room for.\n        return ZIP_BADZIPFILE;\n      }\n\n      p = zi->ci.central_header + zi->ci.size_centralheader;\n\n      // Add Extra Information Header for 'ZIP64 information'\n      zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID\n      p += 2;\n      zip64local_putValue_inmemory(p, datasize, 2); // DataSize\n      p += 2;\n\n      if(uncompressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, uncompressed_size, 8);\n        p += 8;\n      }\n\n      if(compressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, compressed_size, 8);\n        p += 8;\n      }\n\n      if(zi->ci.pos_local_header >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);\n        p += 8;\n      }\n\n      // Update how much extra free space we got in the memory buffer\n      // and increase the centralheader size so the new ZIP64 fields are included\n      // ( 4 below is the size of HeaderID and DataSize field )\n      zi->ci.size_centralExtraFree -= datasize + 4;\n      zi->ci.size_centralheader += datasize + 4;\n\n      // Update the extra info size field\n      zi->ci.size_centralExtra += datasize + 4;\n      zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);\n    }\n\n    if (err==ZIP_OK)\n        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);\n\n    free(zi->ci.central_header);\n\n    if (err==ZIP_OK)\n    {\n        // Update the LocalFileHeader with the new values.\n\n        ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n\n        if (err==ZIP_OK)\n            err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */\n\n        if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )\n        {\n          if(zi->ci.pos_zip64extrainfo > 0)\n          {\n            // Update the size in the ZIP64 extended field.\n            if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)\n              err = ZIP_ERRNO;\n\n            if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);\n\n            if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);\n          }\n          else\n              err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal\n        }\n        else\n        {\n          if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);\n\n          if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);\n        }\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n    }\n\n    zi->number_entry ++;\n    zi->in_opened_file_inzip = 0;\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "345abdca22ad98c10b77e2495073b9c59a810abded5f05dc0a84ae609a6de159": [
  "extern int ZEXPORT zipCloseFileInZip (zipFile file)\n{\n    return zipCloseFileInZipRaw (file,0,0);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "a5a9f2fcb695464bde8b64d7e9331dcdddb4419cdbf0b18a199fdbc919719184": [
  "int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)\n{\n  int err = ZIP_OK;\n  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writing_offset;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);\n\n  /*num disks*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  /*relative offset*/\n    if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);\n\n  /*total disks*/ /* Do not support spawning of disk so always say 1 here*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "0b608c992e3023898ad7e0a92419c2c9d3664698c913a929d19cf942ffd50ed0": [
  "int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)\n{\n  int err = ZIP_OK;\n\n  uLong Zip64DataSize = 44;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?\n\n  if (err==ZIP_OK) /* version made by */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* version needed */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);\n  }\n  return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "c36a37b020c1885fbc19bd48d24c1c35298e87844e04e6d201f230ccd70c975e": [
  "int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)\n{\n  int err = ZIP_OK;\n\n  /*signature*/\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n  {\n    {\n      if(zi->number_entry >= 0xFFFF)\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n      else\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n    }\n  }\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n  {\n    if(zi->number_entry >= 0xFFFF)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n  }\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    if(pos >= 0xffffffff)\n    {\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);\n    }\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writing_offset),4);\n  }\n\n   return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "406131f07ee200d16b50115b9a86a74359c247ce79f90788db77e966105a5f4b": [
  "int Write_GlobalComment(zip64_internal* zi, const char* global_comment)\n{\n  int err = ZIP_OK;\n  uInt size_global_comment = 0;\n\n  if(global_comment != NULL)\n    size_global_comment = (uInt)strlen(global_comment);\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);\n\n  if (err == ZIP_OK && size_global_comment > 0)\n  {\n    if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)\n      err = ZIP_ERRNO;\n  }\n  return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "38284e1ba3f3cfe211869c878b5eb9aa9c40e0231925f11003f5c3ac121f7801": [
  "extern int ZEXPORT zipClose (zipFile file, const char* global_comment)\n{\n    zip64_internal* zi;\n    int err = 0;\n    uLong size_centraldir = 0;\n    ZPOS64_T centraldir_pos_inzip;\n    ZPOS64_T pos;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 1)\n    {\n        err = zipCloseFileInZip (file);\n    }\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    if (global_comment==NULL)\n        global_comment = zi->globalcomment;\n#endif\n\n    centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n    if (err==ZIP_OK)\n    {\n        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;\n        while (ldi!=NULL)\n        {\n            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))\n            {\n                if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)\n                    err = ZIP_ERRNO;\n            }\n\n            size_centraldir += ldi->filled_in_this_block;\n            ldi = ldi->next_datablock;\n        }\n    }\n    free_linkedlist(&(zi->central_dir));\n\n    pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)\n    {\n      ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);\n      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n\n      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);\n    }\n\n    if (err==ZIP_OK)\n      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n\n    if(err == ZIP_OK)\n      err = Write_GlobalComment(zi, global_comment);\n\n    if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)\n        if (err == ZIP_OK)\n            err = ZIP_ERRNO;\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    TRYFREE(zi->globalcomment);\n#endif\n    TRYFREE(zi);\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "6fc687e788935cda27aa40c6fd866e18c3e3dc989e0dd148b5adabf93976eaad": [
  "extern int ZEXPORT zipRemoveExtraInfoBlock (char* pData, int* dataLen, short sHeader)\n{\n  char* p = pData;\n  int size = 0;\n  char* pNewHeader;\n  char* pTmp;\n  short header;\n  short dataSize;\n\n  int retVal = ZIP_OK;\n\n  if(pData == NULL || *dataLen < 4)\n    return ZIP_PARAMERROR;\n\n  pNewHeader = (char*)ALLOC(*dataLen);\n  pTmp = pNewHeader;\n\n  while(p < (pData + *dataLen))\n  {\n    header = *(short*)p;\n    dataSize = *(((short*)p)+1);\n\n    if( header == sHeader ) // Header found.\n    {\n      p += dataSize + 4; // skip it. do not copy to temp buffer\n    }\n    else\n    {\n      // Extra Info block should not be removed, So copy it to the temp buffer.\n      memcpy(pTmp, p, dataSize + 4);\n      p += dataSize + 4;\n      size += dataSize + 4;\n    }\n\n  }\n\n  if(size < *dataLen)\n  {\n    // clean old extra info block.\n    memset(pData,0, *dataLen);\n\n    // copy the new extra info block over the old\n    if(size > 0)\n      memcpy(pData, pNewHeader, size);\n\n    // set the new extra info size\n    *dataLen = size;\n\n    retVal = ZIP_OK;\n  }\n  else\n    retVal = ZIP_ERRNO;\n\n  TRYFREE(pNewHeader);\n\n  return retVal;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "2edc5fc9f851800cee50a1f30f5d537894ae07ee3bd09f2767cdb4ee200d53e8": [
  "void Display64BitsSize(ZPOS64_T n, int size_char)\n{\n  /* to avoid compatibility problem , we do here the conversion */\n  char number[21];\n  int offset=19;\n  int pos_string = 19;\n  number[20]=0;\n  for (;;) {\n      number[offset]=(char)((n%10)+'0');\n      if (number[offset] != '0')\n          pos_string=offset;\n      n/=10;\n      if (offset==0)\n          break;\n      offset--;\n  }\n  {\n      int size_display_string = 19-pos_string;\n      while (size_char > size_display_string)\n      {\n          size_char--;\n          printf(\" \");\n      }\n  }\n\n  printf(\"%s\",&number[pos_string]);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/miniunz.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "ebc798fa706f9340343b9bc668e4700d9fc20564154cc7a787b8bb9c8d6ca506": [
  "local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi)\n{\n    unsigned char c;\n    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);\n    if (err==1)\n    {\n        *pi = (int)c;\n        return UNZ_OK;\n    }\n    else\n    {\n        if (ZERROR64(*pzlib_filefunc_def,filestream))\n            return UNZ_ERRNO;\n        else\n            return UNZ_EOF;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "0fd87d423d5d4ba0a06de7f15d5da0e3d30bc9d6ae163cf3032a21c9e96e552f": [
  "local int unz64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                             voidpf filestream,\n                             uLong *pX)\n{\n    uLong x ;\n    int i = 0;\n    int err;\n\n    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x = (uLong)i;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((uLong)i)<<8;\n\n    if (err==UNZ_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "2453cb38ee431e890d15999da48f4df86cff5ceb84ac1fddbdb32627a9abc43c": [
  "local int unz64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                            voidpf filestream,\n                            uLong *pX)\n{\n    uLong x ;\n    int i = 0;\n    int err;\n\n    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x = (uLong)i;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((uLong)i)<<8;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((uLong)i)<<16;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<24;\n\n    if (err==UNZ_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "2647b4e9d10e5219aef756f136b5ace9f4d595100f229bab875047be69c031b7": [
  "local int unz64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                            voidpf filestream,\n                            ZPOS64_T *pX)\n{\n    ZPOS64_T x ;\n    int i = 0;\n    int err;\n\n    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x = (ZPOS64_T)i;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((ZPOS64_T)i)<<8;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((ZPOS64_T)i)<<16;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((ZPOS64_T)i)<<24;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((ZPOS64_T)i)<<32;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((ZPOS64_T)i)<<40;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((ZPOS64_T)i)<<48;\n\n    if (err==UNZ_OK)\n        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x |= ((ZPOS64_T)i)<<56;\n\n    if (err==UNZ_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "467097cb453ee7c4e6508e16883e7ee8c3ccdd5c3c5fb46fa31278e9884edcff": [
  "local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)\n{\n    for (;;)\n    {\n        char c1=*(fileName1++);\n        char c2=*(fileName2++);\n        if ((c1>='a') && (c1<='z'))\n            c1 -= 0x20;\n        if ((c2>='a') && (c2<='z'))\n            c2 -= 0x20;\n        if (c1=='\\0')\n            return ((c2=='\\0') ? 0 : -1);\n        if (c2=='\\0')\n            return 1;\n        if (c1<c2)\n            return -1;\n        if (c1>c2)\n            return 1;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "be88f7b7d53e5cfa1e0376a5c5e260c7597028b28523fe0af918ca8dfc9988ce": [
  "extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,\n                                                 const char*  fileName2,\n                                                 int iCaseSensitivity)\n\n{\n    if (iCaseSensitivity==0)\n        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n\n    if (iCaseSensitivity==1)\n        return strcmp(fileName1,fileName2);\n\n    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "4414534175d59f0f6fedd054adcaef55828b8f07e586ae6c3f4f5685da875f90": [
  "local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)\n{\n    unsigned char* buf;\n    ZPOS64_T uSizeFile;\n    ZPOS64_T uBackRead;\n    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n    ZPOS64_T uPosFound=0;\n\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n        return 0;\n\n\n    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n    if (uMaxBack>uSizeFile)\n        uMaxBack = uSizeFile;\n\n    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n    if (buf==NULL)\n        return 0;\n\n    uBackRead = 4;\n    while (uBackRead<uMaxBack)\n    {\n        uLong uReadSize;\n        ZPOS64_T uReadPos ;\n        int i;\n        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n            uBackRead = uMaxBack;\n        else\n            uBackRead+=BUFREADCOMMENT;\n        uReadPos = uSizeFile-uBackRead ;\n\n        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            break;\n\n        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n            break;\n\n        for (i=(int)uReadSize-3; (i--)>0;)\n            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n            {\n                uPosFound = uReadPos+i;\n                break;\n            }\n\n        if (uPosFound!=0)\n            break;\n    }\n    TRYFREE(buf);\n    return uPosFound;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "e664e247a9f7dfb0797458d374f7fedb381f6310278fe3ae05b8660b3e815e73": [
  "local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                                      voidpf filestream)\n{\n    unsigned char* buf;\n    ZPOS64_T uSizeFile;\n    ZPOS64_T uBackRead;\n    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n    ZPOS64_T uPosFound=0;\n    uLong uL;\n                ZPOS64_T relativeOffset;\n\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n        return 0;\n\n\n    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n    if (uMaxBack>uSizeFile)\n        uMaxBack = uSizeFile;\n\n    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n    if (buf==NULL)\n        return 0;\n\n    uBackRead = 4;\n    while (uBackRead<uMaxBack)\n    {\n        uLong uReadSize;\n        ZPOS64_T uReadPos;\n        int i;\n        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n            uBackRead = uMaxBack;\n        else\n            uBackRead+=BUFREADCOMMENT;\n        uReadPos = uSizeFile-uBackRead ;\n\n        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            break;\n\n        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n            break;\n\n        for (i=(int)uReadSize-3; (i--)>0;)\n            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n                ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))\n            {\n                uPosFound = uReadPos+i;\n                break;\n            }\n\n        if (uPosFound!=0)\n            break;\n    }\n    TRYFREE(buf);\n    if (uPosFound == 0)\n        return 0;\n\n    /* Zip64 end of central directory locator */\n    if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return 0;\n\n    /* the signature, already checked */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n\n    /* number of the disk with the start of the zip64 end of  central directory */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n    if (uL != 0)\n        return 0;\n\n    /* relative offset of the zip64 end of central directory record */\n    if (unz64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=UNZ_OK)\n        return 0;\n\n    /* total number of disks */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n    if (uL != 1)\n        return 0;\n\n    /* Goto end of central directory record */\n    if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return 0;\n\n     /* the signature */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n\n    if (uL != 0x06064b50)\n        return 0;\n\n    return relativeOffset;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "d57998fa46e637a767b2b677a6cbe92474fe91cbafcdd31f882492ea32d77d99": [
  "local unzFile unzOpenInternal (const void *path,\n                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,\n                               int is64bitOpenFunction)\n{\n    unz64_s us;\n    unz64_s *s;\n    ZPOS64_T central_pos;\n    uLong   uL;\n\n    uLong number_disk;          /* number of the current dist, used for\n                                   spaning ZIP, unsupported, always 0*/\n    uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                                   for spaning ZIP, unsupported, always 0*/\n    ZPOS64_T number_entry_CD;      /* total number of entries in\n                                   the central dir\n                                   (same than number_entry on nospan) */\n\n    int err=UNZ_OK;\n\n    if (unz_copyright[0]!=' ')\n        return NULL;\n\n    us.z_filefunc.zseek32_file = NULL;\n    us.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);\n    else\n        us.z_filefunc = *pzlib_filefunc64_32_def;\n    us.is64bitOpenFunction = is64bitOpenFunction;\n\n\n\n    us.filestream = ZOPEN64(us.z_filefunc,\n                                                 path,\n                                                 ZLIB_FILEFUNC_MODE_READ |\n                                                 ZLIB_FILEFUNC_MODE_EXISTING);\n    if (us.filestream==NULL)\n        return NULL;\n\n    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);\n    if (central_pos)\n    {\n        uLong uS;\n        ZPOS64_T uL64;\n\n        us.isZip64 = 1;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* size of zip64 end of central directory record */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version made by */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version needed to extract */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory on this disk */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* offset of start of central directory with respect to the\n          starting disk number */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        us.gi.size_comment = 0;\n    }\n    else\n    {\n        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);\n        if (central_pos==0)\n            err=UNZ_ERRNO;\n\n        us.isZip64 = 0;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central dir on this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.gi.number_entry = uL;\n\n        /* total number of entries in the central dir */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        number_entry_CD = uL;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.size_central_dir = uL;\n\n        /* offset of start of central directory with respect to the\n            starting disk number */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.offset_central_dir = uL;\n\n        /* zipfile comment length */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)\n            err=UNZ_ERRNO;\n    }\n\n    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&\n        (err==UNZ_OK))\n        err=UNZ_BADZIPFILE;\n\n    if (err!=UNZ_OK)\n    {\n        ZCLOSE64(us.z_filefunc, us.filestream);\n        return NULL;\n    }\n\n    us.byte_before_the_zipfile = central_pos -\n                            (us.offset_central_dir+us.size_central_dir);\n    us.central_pos = central_pos;\n    us.pfile_in_zip_read = NULL;\n    us.encrypted = 0;\n\n\n    s=(unz64_s*)ALLOC(sizeof(unz64_s));\n    if( s != NULL)\n    {\n        *s=us;\n        unzGoToFirstFile((unzFile)s);\n    }\n    return (unzFile)s;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "912c91a1de0c5da0c7558fcf9e9837c6b08d7d22333d20cb141b60ad3d1949fd": [
  "extern unzFile ZEXPORT unzOpen2 (const char *path,\n                                        zlib_filefunc_def* pzlib_filefunc32_def)\n{\n    if (pzlib_filefunc32_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);\n        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 0);\n    }\n    else\n        return unzOpenInternal(path, NULL, 0);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "6933403e9153ac90e8200b75b8915a919493c6b505de96e6f3e53fe9ba8af130": [
  "extern unzFile ZEXPORT unzOpen2_64 (const void *path,\n                                     zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    if (pzlib_filefunc_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;\n        zlib_filefunc64_32_def_fill.ztell32_file = NULL;\n        zlib_filefunc64_32_def_fill.zseek32_file = NULL;\n        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 1);\n    }\n    else\n        return unzOpenInternal(path, NULL, 1);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "af19f7ff7e8111881eafe0fe351479bf995691c661eca2809ad3113ffb100c4b": [
  "extern unzFile ZEXPORT unzOpen (const char *path)\n{\n    return unzOpenInternal(path, NULL, 0);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "f408be734db5287308704012af13332d976e281c1bed691c8272b33dd0a2bcef": [
  "extern unzFile ZEXPORT unzOpen64 (const void *path)\n{\n    return unzOpenInternal(path, NULL, 1);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "62f2019a6e82fb61d424e895dfe395e905a6c0ec5e71b0306e449eca7e135e70": [
  "extern int ZEXPORT unzClose (unzFile file)\n{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    if (s->pfile_in_zip_read!=NULL)\n        unzCloseCurrentFile(file);\n\n    ZCLOSE64(s->z_filefunc, s->filestream);\n    TRYFREE(s);\n    return UNZ_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "e1a3cb5e6224f0ab5e4f94e01cc7047ba7bd174798b3c9f2af8c7dd582e1f0bf": [
  "extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)\n{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    *pglobal_info=s->gi;\n    return UNZ_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "4c62c500100d7943356817c95e993d8f45395bbe0aa50f03a36f00ca2effc53a": [
  "extern int ZEXPORT unzGetGlobalInfo (unzFile file, unz_global_info* pglobal_info32)\n{\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    /* to do : check if number_entry is not truncated */\n    pglobal_info32->number_entry = (uLong)s->gi.number_entry;\n    pglobal_info32->size_comment = s->gi.size_comment;\n    return UNZ_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "8525f7010d0b1cc26528496a4571061411d16538143e2a5cb4252fa81a2f0610": [
  "local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)\n{\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (uInt)(uDate&0x1f) ;\n    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "f252a456e8039d3c2c7675f322f149c8260d2431604281cfd33411cd27846856": [
  "local int unz64local_GetCurrentFileInfoInternal (unzFile file,\n                                                  unz_file_info64 *pfile_info,\n                                                  unz_file_info64_internal\n                                                  *pfile_info_internal,\n                                                  char *szFileName,\n                                                  uLong fileNameBufferSize,\n                                                  void *extraField,\n                                                  uLong extraFieldBufferSize,\n                                                  char *szComment,\n                                                  uLong commentBufferSize)\n{\n    unz64_s* s;\n    unz_file_info64 file_info;\n    unz_file_info64_internal file_info_internal;\n    int err=UNZ_OK;\n    uLong uMagic;\n    long lSeek=0;\n    uLong uL;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (ZSEEK64(s->z_filefunc, s->filestream,\n              s->pos_in_central_dir+s->byte_before_the_zipfile,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n\n    /* we check the magic */\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x02014b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.compressed_size = uL;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.uncompressed_size = uL;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n                // relative offset of local header\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info_internal.offset_curfile = uL;\n\n    lSeek+=file_info.size_filename;\n    if ((err==UNZ_OK) && (szFileName!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_filename<fileNameBufferSize)\n        {\n            *(szFileName+file_info.size_filename)='\\0';\n            uSizeRead = file_info.size_filename;\n        }\n        else\n            uSizeRead = fileNameBufferSize;\n\n        if ((file_info.size_filename>0) && (fileNameBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek -= uSizeRead;\n    }\n\n    // Read extrafield\n    if ((err==UNZ_OK) && (extraField!=NULL))\n    {\n        ZPOS64_T uSizeRead ;\n        if (file_info.size_file_extra<extraFieldBufferSize)\n            uSizeRead = file_info.size_file_extra;\n        else\n            uSizeRead = extraFieldBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n\n        lSeek += file_info.size_file_extra - (uLong)uSizeRead;\n    }\n    else\n        lSeek += file_info.size_file_extra;\n\n\n    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))\n    {\n                                uLong acc = 0;\n\n        // since lSeek now points to after the extra field we need to move back\n        lSeek -= file_info.size_file_extra;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        while(acc < file_info.size_file_extra)\n        {\n            uLong headerId;\n                                                uLong dataSize;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            /* ZIP64 extra fields */\n            if (headerId == 0x0001)\n            {\n                                                        uLong uL;\n\n                                                                if(file_info.uncompressed_size == MAXU32)\n                                                                {\n                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)\n                                                                                        err=UNZ_ERRNO;\n                                                                }\n\n                                                                if(file_info.compressed_size == MAXU32)\n                                                                {\n                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)\n                                                                                  err=UNZ_ERRNO;\n                                                                }\n\n                                                                if(file_info_internal.offset_curfile == MAXU32)\n                                                                {\n                                                                        /* Relative Header offset */\n                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)\n                                                                                err=UNZ_ERRNO;\n                                                                }\n\n                                                                if(file_info.disk_num_start == MAXU32)\n                                                                {\n                                                                        /* Disk Start Number */\n                                                                        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n                                                                                err=UNZ_ERRNO;\n                                                                }\n\n            }\n            else\n            {\n                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)\n                    err=UNZ_ERRNO;\n            }\n\n            acc += 2 + 2 + dataSize;\n        }\n    }\n\n    if ((err==UNZ_OK) && (szComment!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_file_comment<commentBufferSize)\n        {\n            *(szComment+file_info.size_file_comment)='\\0';\n            uSizeRead = file_info.size_file_comment;\n        }\n        else\n            uSizeRead = commentBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_comment>0) && (commentBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek+=file_info.size_file_comment - uSizeRead;\n    }\n    else\n        lSeek+=file_info.size_file_comment;\n\n\n    if ((err==UNZ_OK) && (pfile_info!=NULL))\n        *pfile_info=file_info;\n\n    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n        *pfile_info_internal=file_info_internal;\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "4e4e7e049cf71d957044280db3db4f877916bde5b8c432b1514d3186681343f7": [
  "extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,\n                                          unz_file_info64 * pfile_info,\n                                          char * szFileName, uLong fileNameBufferSize,\n                                          void *extraField, uLong extraFieldBufferSize,\n                                          char* szComment,  uLong commentBufferSize)\n{\n    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "73986f22392ad93221cd76a207c9ea8dcdb70e9c4a26d52572f6ad9512245f43": [
  "extern int ZEXPORT unzGetCurrentFileInfo (unzFile file,\n                                          unz_file_info * pfile_info,\n                                          char * szFileName, uLong fileNameBufferSize,\n                                          void *extraField, uLong extraFieldBufferSize,\n                                          char* szComment,  uLong commentBufferSize)\n{\n    int err;\n    unz_file_info64 file_info64;\n    err = unz64local_GetCurrentFileInfoInternal(file,&file_info64,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n    if ((err==UNZ_OK) && (pfile_info != NULL))\n    {\n        pfile_info->version = file_info64.version;\n        pfile_info->version_needed = file_info64.version_needed;\n        pfile_info->flag = file_info64.flag;\n        pfile_info->compression_method = file_info64.compression_method;\n        pfile_info->dosDate = file_info64.dosDate;\n        pfile_info->crc = file_info64.crc;\n\n        pfile_info->size_filename = file_info64.size_filename;\n        pfile_info->size_file_extra = file_info64.size_file_extra;\n        pfile_info->size_file_comment = file_info64.size_file_comment;\n\n        pfile_info->disk_num_start = file_info64.disk_num_start;\n        pfile_info->internal_fa = file_info64.internal_fa;\n        pfile_info->external_fa = file_info64.external_fa;\n\n        pfile_info->tmu_date = file_info64.tmu_date,\n\n\n        pfile_info->compressed_size = (uLong)file_info64.compressed_size;\n        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;\n\n    }\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "515cc182c11ed400bb999ecad3882902995bcf04be2bd8908e064f9c083be70f": [
  "extern int ZEXPORT unzGoToFirstFile (unzFile file)\n{\n    int err=UNZ_OK;\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    s->pos_in_central_dir=s->offset_central_dir;\n    s->num_file=0;\n    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                             &s->cur_file_info_internal,\n                                             NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "e95a8da02266b0fef17d448b05fa396bdf4c70900f29b14f651a35fb3b1afdcf": [
  "extern int ZEXPORT unzGoToNextFile (unzFile  file)\n{\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */\n      if (s->num_file+1==s->gi.number_entry)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n    s->num_file++;\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "10f00c68f1f8451f3a06fc6027fe85dbc6280053579cb99e626f7b82be507f5d": [
  "extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)\n{\n    unz64_s* s;\n    int err;\n\n    /* We remember the 'current' position in the file so that we can jump\n     * back there if we fail.\n     */\n    unz_file_info64 cur_file_infoSaved;\n    unz_file_info64_internal cur_file_info_internalSaved;\n    ZPOS64_T num_fileSaved;\n    ZPOS64_T pos_in_central_dirSaved;\n\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n\n    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n        return UNZ_PARAMERROR;\n\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    /* Save the current state */\n    num_fileSaved = s->num_file;\n    pos_in_central_dirSaved = s->pos_in_central_dir;\n    cur_file_infoSaved = s->cur_file_info;\n    cur_file_info_internalSaved = s->cur_file_info_internal;\n\n    err = unzGoToFirstFile(file);\n\n    while (err == UNZ_OK)\n    {\n        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n        err = unzGetCurrentFileInfo64(file,NULL,\n                                    szCurrentFileName,sizeof(szCurrentFileName)-1,\n                                    NULL,0,NULL,0);\n        if (err == UNZ_OK)\n        {\n            if (unzStringFileNameCompare(szCurrentFileName,\n                                            szFileName,iCaseSensitivity)==0)\n                return UNZ_OK;\n            err = unzGoToNextFile(file);\n        }\n    }\n\n    /* We failed, so restore the state of the 'current file' to where we\n     * were.\n     */\n    s->num_file = num_fileSaved ;\n    s->pos_in_central_dir = pos_in_central_dirSaved ;\n    s->cur_file_info = cur_file_infoSaved;\n    s->cur_file_info_internal = cur_file_info_internalSaved;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "231b54b6cf023c83d9923e4679fa2ba489f988b73787cfd9ef094f8b4525210b": [
  "extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)\n{\n    unz64_s* s;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;\n    file_pos->num_of_file           = s->num_file;\n\n    return UNZ_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "a22d8b46283cadc146c03bddf7954510b88e35970fa0b50ac8caa953dcac32cb": [
  "extern int ZEXPORT unzGetFilePos(\n    unzFile file,\n    unz_file_pos* file_pos)\n{\n    unz64_file_pos file_pos64;\n    int err = unzGetFilePos64(file,&file_pos64);\n    if (err==UNZ_OK)\n    {\n        file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;\n        file_pos->num_of_file = (uLong)file_pos64.num_of_file;\n    }\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "44f548ffa3a22dab5046726d7ab699a9363b4cad7cd464c369d3ac660643e931": [
  "extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos)\n{\n    unz64_s* s;\n    int err;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    /* jump to the right spot */\n    s->pos_in_central_dir = file_pos->pos_in_zip_directory;\n    s->num_file           = file_pos->num_of_file;\n\n    /* set the current file */\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    /* return results */\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "8a639e07d953ec15e49ba4d5fbe999f35b5a31a27b78a5ba0a4545e859c2f9be": [
  "extern int ZEXPORT unzGoToFilePos(\n    unzFile file,\n    unz_file_pos* file_pos)\n{\n    unz64_file_pos file_pos64;\n    if (file_pos == NULL)\n        return UNZ_PARAMERROR;\n\n    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;\n    file_pos64.num_of_file = file_pos->num_of_file;\n    return unzGoToFilePos64(file,&file_pos64);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "02f7be5ef0e43727964a46c48634b407aa1d7124ce14b40cb273ab30994c0ac3": [
  "local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,\n                                                    ZPOS64_T * poffset_local_extrafield,\n                                                    uInt  * psize_local_extrafield)\n{\n    uLong uMagic,uData,uFlags;\n    uLong size_filename;\n    uLong size_extra_field;\n    int err=UNZ_OK;\n\n    *piSizeVar = 0;\n    *poffset_local_extrafield = 0;\n    *psize_local_extrafield = 0;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x04034b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n/*\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n*/\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n        err=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n        err=UNZ_BADZIPFILE;\n\n    *piSizeVar += (uInt)size_filename;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n        err=UNZ_ERRNO;\n    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n                                    SIZEZIPLOCALHEADER + size_filename;\n    *psize_local_extrafield = (uInt)size_extra_field;\n\n    *piSizeVar += (uInt)size_extra_field;\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "b40a2bd6e298b481d6b32e3686397f03b6be633b4cc46ad9e0d71aecb49b30c5": [
  "extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,\n                                            int* level, int raw, const char* password)\n{\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        TRYFREE(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\n        err=UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "5e1396d08c5a87b2b5bd99a7092212e7fb9f759b642077061334f733616b9e86": [
  "extern int ZEXPORT unzOpenCurrentFile (unzFile file)\n{\n    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "cd5a6fcc33b70b9b654c51025314817235d33167c9d4e1adbfb1dcf52ab428ff": [
  "extern int ZEXPORT unzOpenCurrentFilePassword (unzFile file, const char*  password)\n{\n    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "2a1a52fbd31cfc8add06377158c87cd8c7065b6839823e37410534f4d977d9de": [
  "extern int ZEXPORT unzOpenCurrentFile2 (unzFile file, int* method, int* level, int raw)\n{\n    return unzOpenCurrentFile3(file, method, level, raw, NULL);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "4517e4ae2226e35633ccf48ab6730c4dedaae363a7d056c52ee4132d79cee137": [
  "extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)\n{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    s=(unz64_s*)file;\n    if (file==NULL)\n        return 0; //UNZ_PARAMERROR;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n    if (pfile_in_zip_read_info==NULL)\n        return 0; //UNZ_PARAMERROR;\n    return pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "0a14b990fa132d3cd735e6a75fa54032f86d36ecd7512abc1810846c7c449091": [
  "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)\n{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if (pfile_in_zip_read_info->read_buffer == NULL)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return iRead;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "d504430d6df4c9b662ff3ea251d31275140bdff1d4cf471824f8ad8e5d9f43a6": [
  "extern z_off_t ZEXPORT unztell (unzFile file)\n{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "e136f5445856a43b56747d6f12985f7163889df5afe07106cd9ccdbcf5794686": [
  "extern ZPOS64_T ZEXPORT unztell64 (unzFile file)\n{\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return (ZPOS64_T)-1;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return (ZPOS64_T)-1;\n\n    return pfile_in_zip_read_info->total_out_64;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "e1ed3122b1406f79d93525814aaaf998d5533bffa307f648cde9040b2440026c": [
  "extern int ZEXPORT unzeof (unzFile file)\n{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n        return 1;\n    else\n        return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "d20ea18174fae01e503153ab2ff61bdb92e9b6c82ebf3cb38b0e34d49f9e0835": [
  "extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)\n{\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    uInt read_now;\n    ZPOS64_T size_to_read;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n                pfile_in_zip_read_info->pos_local_extrafield);\n\n    if (buf==NULL)\n        return (int)size_to_read;\n\n    if (len>size_to_read)\n        read_now = (uInt)size_to_read;\n    else\n        read_now = (uInt)len ;\n\n    if (read_now==0)\n        return 0;\n\n    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              pfile_in_zip_read_info->offset_local_extrafield +\n              pfile_in_zip_read_info->pos_local_extrafield,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              buf,read_now)!=read_now)\n        return UNZ_ERRNO;\n\n    return (int)read_now;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "d67e072b00ca426ee85a0b041fd7d60d413b21386771b4160ccf636c98631841": [
  "extern int ZEXPORT unzCloseCurrentFile (unzFile file)\n{\n    int err=UNZ_OK;\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n        (!pfile_in_zip_read_info->raw))\n    {\n        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n            err=UNZ_CRCERROR;\n    }\n\n\n    TRYFREE(pfile_in_zip_read_info->read_buffer);\n    pfile_in_zip_read_info->read_buffer = NULL;\n    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)\n        inflateEnd(&pfile_in_zip_read_info->stream);\n#ifdef HAVE_BZIP2\n    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)\n        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);\n#endif\n\n\n    pfile_in_zip_read_info->stream_initialised = 0;\n    TRYFREE(pfile_in_zip_read_info);\n\n    s->pfile_in_zip_read=NULL;\n\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "cdaf8c842b2d7c6557fb836b388647b5c1373d0b0a87a2c2f2fbb6165ee6aed7": [
  "extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)\n{\n    unz64_s* s;\n    uLong uReadThis ;\n    if (file==NULL)\n        return (int)UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    uReadThis = uSizeBuf;\n    if (uReadThis>s->gi.size_comment)\n        uReadThis = s->gi.size_comment;\n\n    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (uReadThis>0)\n    {\n      *szComment='\\0';\n      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)\n        return UNZ_ERRNO;\n    }\n\n    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n        *(szComment+s->gi.size_comment)='\\0';\n    return (int)uReadThis;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "c79127bd47c94e5b253de2f9845adc232dfd68df05a566ed9077ee0dc90e4c0c": [
  "extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)\n{\n    unz64_s* s;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n      return 0;\n    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n      if (s->num_file==s->gi.number_entry)\n         return 0;\n    return s->pos_in_central_dir;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "6c5de6a947c2a11bfca4f2d36f18befe53aa0cd26075e9f7c65d55bd302c1228": [
  "extern uLong ZEXPORT unzGetOffset (unzFile file)\n{\n    ZPOS64_T offset64;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    offset64 = unzGetOffset64(file);\n    return (uLong)offset64;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "9957815d0d19c7ccbb76166be8bb80a47064079dcf50849e6f5be3dfa743b9d7": [
  "extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos)\n{\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    s->pos_in_central_dir = pos;\n    s->num_file = s->gi.number_entry;      /* hack */\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                              &s->cur_file_info_internal,\n                                              NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "184b3afa2042374fd350721fac73e44cd30ce187ac4a21d7705d676bca7515a8": [
  "extern int ZEXPORT unzSetOffset (unzFile file, uLong pos)\n{\n    return unzSetOffset64(file,pos);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "45e6320725c5bb323de2cb11d2a99aa566fef5a774f9c9fa46d5a52d831471ad": [
  "voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode)\n{\n    if (pfilefunc->zfile_func64.zopen64_file != NULL)\n        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,filename,mode);\n    else\n    {\n        return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,(const char*)filename,mode);\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "2408b12719b1b50fbb1e99b7647c2fab6b7090a726d5f74d25cd9cf71bf15101": [
  "long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)\n{\n    if (pfilefunc->zfile_func64.zseek64_file != NULL)\n        return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);\n    else\n    {\n        uLong offsetTruncated = (uLong)offset;\n        if (offsetTruncated != offset)\n            return -1;\n        else\n            return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "2ef5004efb1cd166c5f25513626ece47e183de2b2b51114b9f9af16baceea63e": [
  "ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)\n{\n    if (pfilefunc->zfile_func64.zseek64_file != NULL)\n        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);\n    else\n    {\n        uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);\n        if ((tell_uLong) == MAXU32)\n            return (ZPOS64_T)-1;\n        else\n            return tell_uLong;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "8dc8fc7fd6cc724d77834fb12defd915b76e789cd081947b99a69fd2ee9ab5be": [
  "void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32)\n{\n    p_filefunc64_32->zfile_func64.zopen64_file = NULL;\n    p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;\n    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;\n    p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;\n    p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;\n    p_filefunc64_32->zfile_func64.ztell64_file = NULL;\n    p_filefunc64_32->zfile_func64.zseek64_file = NULL;\n    p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;\n    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;\n    p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;\n    p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;\n    p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "280ef65a4be67afc729d9a8848b89dfb1dd49bb08549572248414ccbe5e1b828": [
  "static voidpf ZCALLBACK fopen_file_func (voidpf opaque, const char* filename, int mode)\n{\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = fopen(filename, mode_fopen);\n    return file;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "ba9938443f5d5c8c4be826ab6abac25c84c2a03d5fade0a4c273166266386851": [
  "static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)\n{\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = FOPEN_FUNC((const char*)filename, mode_fopen);\n    return file;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "76894ef1f9c1a3c9052504c7a5104af0af7302b85708dfd0575897b97940accf": [
  "static uLong ZCALLBACK fread_file_func (voidpf opaque, voidpf stream, void* buf, uLong size)\n{\n    uLong ret;\n    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "8776da844c76bd690d49fee46d76d73de02265a07caa4ee1ddec9cd3cb86b896": [
  "static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const void* buf, uLong size)\n{\n    uLong ret;\n    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "be977147f0c88f9d8bcd71f208679eb21b807cad497b66742a4f8126226ec86c": [
  "static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)\n{\n    long ret;\n    ret = ftell((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "c2429badcbb82777ff7463a055e6d89a4c60d8ea12df67039677b993dc0aeafa": [
  "static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)\n{\n    ZPOS64_T ret;\n    ret = FTELLO_FUNC((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "741a738ea1308a16678c0315a4d52925ce94ec814bd72744b66a820eedd83dbc": [
  "static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)\n{\n    int fseek_origin=0;\n    long ret;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n    if (fseek((FILE *)stream, offset, fseek_origin) != 0)\n        ret = -1;\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "fda11af26844b4458bfd64cfd1161b664f33908719dfe864a70572849ee1766d": [
  "static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)\n{\n    int fseek_origin=0;\n    long ret;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n\n    if(FSEEKO_FUNC((FILE *)stream, offset, fseek_origin) != 0)\n                        ret = -1;\n\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "de9086f064ea5545cae7c0be66145e93d34f9aec1c845161c1bebd01d67ee0dd": [
  "static int ZCALLBACK fclose_file_func (voidpf opaque, voidpf stream)\n{\n    int ret;\n    ret = fclose((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "11c63985a8101120a28987184d7aa52b807bbdfb1179144193e44e5c06dab258": [
  "static int ZCALLBACK ferror_file_func (voidpf opaque, voidpf stream)\n{\n    int ret;\n    ret = ferror((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "e2152cd4dd1bfa6933db2a50c04515e4749ace610fcdee39acacdbf711d31faa": [
  "void fill_fopen64_filefunc (zlib_filefunc64_def*  pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen64_file = fopen64_file_func;\n    pzlib_filefunc_def->zread_file = fread_file_func;\n    pzlib_filefunc_def->zwrite_file = fwrite_file_func;\n    pzlib_filefunc_def->ztell64_file = ftell64_file_func;\n    pzlib_filefunc_def->zseek64_file = fseek64_file_func;\n    pzlib_filefunc_def->zclose_file = fclose_file_func;\n    pzlib_filefunc_def->zerror_file = ferror_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "73c0cfbd17dcad446f7c4016b5d9442a2627e996cfa23a2d416e829345118c7c": [
  "static void win32_translate_open_mode(int mode,\n                                      DWORD* lpdwDesiredAccess,\n                                      DWORD* lpdwCreationDisposition,\n                                      DWORD* lpdwShareMode,\n                                      DWORD* lpdwFlagsAndAttributes)\n{\n    *lpdwDesiredAccess = *lpdwShareMode = *lpdwFlagsAndAttributes = *lpdwCreationDisposition = 0;\n\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n    {\n        *lpdwDesiredAccess = GENERIC_READ;\n        *lpdwCreationDisposition = OPEN_EXISTING;\n        *lpdwShareMode = FILE_SHARE_READ;\n    }\n    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n    {\n        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;\n        *lpdwCreationDisposition = OPEN_EXISTING;\n    }\n    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n    {\n        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;\n        *lpdwCreationDisposition = CREATE_ALWAYS;\n    }\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "65bb93cd18462f185c5b28e25c35aa9d5462b40bc336aef3beb78619d92eb6d9": [
  "static voidpf win32_build_iowin(HANDLE hFile)\n{\n    voidpf ret=NULL;\n\n    if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))\n    {\n        WIN32FILE_IOWIN w32fiow;\n        w32fiow.hf = hFile;\n        w32fiow.error = 0;\n        ret = malloc(sizeof(WIN32FILE_IOWIN));\n\n        if (ret==NULL)\n            CloseHandle(hFile);\n        else\n            *((WIN32FILE_IOWIN*)ret) = w32fiow;\n    }\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "351ebe4cf2a3b36b985e77ed9441d3504244c323847925cb5f6f555ed817bfde": [
  "voidpf ZCALLBACK win32_open64_file_func (voidpf opaque,const void* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n#ifdef UNICODE\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n    {\n        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];\n        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);\n        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n    }\n#endif\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "633fd2ac5459ea7eacba36ba203f84721e0ddbf1fa4864c43a7a88f55f3e3e90": [
  "voidpf ZCALLBACK win32_open64_file_funcA (voidpf opaque,const void* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n    {\n        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];\n        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);\n        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n    }\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFileA((LPCSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "7b9560220102f6ade2a7f48d08b843073e88d17ec8044b96955af295738945b8": [
  "voidpf ZCALLBACK win32_open64_file_funcW (voidpf opaque,const void* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile2((LPCWSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition,NULL);\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFileW((LPCWSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "2ee8296a56e55a78f3d4ce86c8ad0840713b48b2d820fbbc951f9a69e6d1a1e7": [
  "voidpf ZCALLBACK win32_open_file_func (voidpf opaque,const char* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n#ifdef UNICODE\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n    {\n        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];\n        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);\n        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n    }\n#endif\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "70dbf6474addd8b85c465fbb9c72d80ffdbe251a5c875b7aa48fd1cacf98e79b": [
  "uLong ZCALLBACK win32_read_file_func (voidpf opaque, voidpf stream, void* buf,uLong size)\n{\n    uLong ret=0;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n\n    if (hFile != NULL)\n    {\n        if (!ReadFile(hFile, buf, size, &ret, NULL))\n        {\n            DWORD dwErr = GetLastError();\n            if (dwErr == ERROR_HANDLE_EOF)\n                dwErr = 0;\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n        }\n    }\n\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "0f6f0827fdff4216fc4714dfb0757b01f1db189126b5cf3bde871f940c696166": [
  "uLong ZCALLBACK win32_write_file_func (voidpf opaque,voidpf stream,const void* buf,uLong size)\n{\n    uLong ret=0;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n\n    if (hFile != NULL)\n    {\n        if (!WriteFile(hFile, buf, size, &ret, NULL))\n        {\n            DWORD dwErr = GetLastError();\n            if (dwErr == ERROR_HANDLE_EOF)\n                dwErr = 0;\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n        }\n    }\n\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "bf5ebcf02710ee1bcf0965905a708b59b4bcdc98f540cacbd95f2224a4be6511": [
  "static BOOL MySetFilePointerEx(HANDLE hFile, LARGE_INTEGER pos, LARGE_INTEGER *newPos,  DWORD dwMoveMethod)\n{\n#ifdef IOWIN32_USING_WINRT_API\n    return SetFilePointerEx(hFile, pos, newPos, dwMoveMethod);\n#else\n    LONG lHigh = pos.HighPart;\n    DWORD dwNewPos = SetFilePointer(hFile, pos.LowPart, &lHigh, dwMoveMethod);\n    BOOL fOk = TRUE;\n    if (dwNewPos == 0xFFFFFFFF)\n        if (GetLastError() != NO_ERROR)\n            fOk = FALSE;\n    if ((newPos != NULL) && (fOk))\n    {\n        newPos->LowPart = dwNewPos;\n        newPos->HighPart = lHigh;\n    }\n    return fOk;\n#endif\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "6b7b0cb0095cb69e085f43926ef96cdb606dbddc76944cec7c3d85d0b46f22ed": [
  "long ZCALLBACK win32_tell_file_func (voidpf opaque,voidpf stream)\n{\n    long ret=-1;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n    if (hFile != NULL)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = 0;\n\n        if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=(long)pos.LowPart;\n    }\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "948c6bcc79bf43c62dfe508b3cda5697cf9773029d61cc3c2e85e44e8ec92bc8": [
  "ZPOS64_T ZCALLBACK win32_tell64_file_func (voidpf opaque, voidpf stream)\n{\n    ZPOS64_T ret= (ZPOS64_T)-1;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream)->hf;\n\n    if (hFile)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = 0;\n\n        if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = (ZPOS64_T)-1;\n        }\n        else\n            ret=pos.QuadPart;\n    }\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "f1310af6266885ac356d86158af32701a64872c813c185c8144697ae23f5e1e5": [
  "long ZCALLBACK win32_seek_file_func (voidpf opaque,voidpf stream,uLong offset,int origin)\n{\n    DWORD dwMoveMethod=0xFFFFFFFF;\n    HANDLE hFile = NULL;\n\n    long ret=-1;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        dwMoveMethod = FILE_CURRENT;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        dwMoveMethod = FILE_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        dwMoveMethod = FILE_BEGIN;\n        break;\n    default: return -1;\n    }\n\n    if (hFile != NULL)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = offset;\n        if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=0;\n    }\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "fb9c76448a98ee474a8a23319f80b69d667e62e21a673124cdee8563742c7d15": [
  "long ZCALLBACK win32_seek64_file_func (voidpf opaque, voidpf stream,ZPOS64_T offset,int origin)\n{\n    DWORD dwMoveMethod=0xFFFFFFFF;\n    HANDLE hFile = NULL;\n    long ret=-1;\n\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream)->hf;\n\n    switch (origin)\n    {\n        case ZLIB_FILEFUNC_SEEK_CUR :\n            dwMoveMethod = FILE_CURRENT;\n            break;\n        case ZLIB_FILEFUNC_SEEK_END :\n            dwMoveMethod = FILE_END;\n            break;\n        case ZLIB_FILEFUNC_SEEK_SET :\n            dwMoveMethod = FILE_BEGIN;\n            break;\n        default: return -1;\n    }\n\n    if (hFile)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = offset;\n        if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=0;\n    }\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "36df9020a586b26b64afe7ea49ff298c0570faffbc336ba28dff49b3ae49b687": [
  "int ZCALLBACK win32_close_file_func (voidpf opaque, voidpf stream)\n{\n    int ret=-1;\n\n    if (stream!=NULL)\n    {\n        HANDLE hFile;\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n        if (hFile != NULL)\n        {\n            CloseHandle(hFile);\n            ret=0;\n        }\n        free(stream);\n    }\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "0addf5d3144ff725c119cd64d419dce4b3fdf437ba4f9ce4ae1e1c62ccd4e884": [
  "int ZCALLBACK win32_error_file_func (voidpf opaque,voidpf stream)\n{\n    int ret=-1;\n    if (stream!=NULL)\n    {\n        ret = ((WIN32FILE_IOWIN*)stream) -> error;\n    }\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "1ba96e0e5ef24fcf43d1759db156abca05c6f2455ac886e9fb35680a190e63e0": [
  "void fill_win32_filefunc (zlib_filefunc_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen_file = win32_open_file_func;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell_file = win32_tell_file_func;\n    pzlib_filefunc_def->zseek_file = win32_seek_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "1486b8ab93815cdb8be8719fa7a6f1e9c258513e183d349395cf0b61d437c880": [
  "void fill_win32_filefunc64(zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_func;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "3fbd72b199bf3365fcbc2fc7cae0d6caa0e81b8b8939874272ac7db6b5ba940d": [
  "void fill_win32_filefunc64A(zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcA;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "57e8d70c13fb04084a86b497d80f9f0c87d15df565ede98c569f9c41ebf0c31d": [
  "void fill_win32_filefunc64W(zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcW;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "773a50a7067d31b2fe7183024af3178d2a35680dbdd4cf3ca04e91e4328c78e8": [
  "local int decomp(struct state *s)\n{\n    int lit;            /* true if literals are coded */\n    int dict;           /* log2(dictionary size) - 6 */\n    int symbol;         /* decoded symbol, extra bits for distance */\n    int len;            /* length for copy */\n    unsigned dist;      /* distance for copy */\n    int copy;           /* copy counter */\n    unsigned char *from, *to;   /* copy pointers */\n    static int virgin = 1;                              /* build tables once */\n    static short litcnt[MAXBITS+1], litsym[256];        /* litcode memory */\n    static short lencnt[MAXBITS+1], lensym[16];         /* lencode memory */\n    static short distcnt[MAXBITS+1], distsym[64];       /* distcode memory */\n    static struct huffman litcode = {litcnt, litsym};   /* length code */\n    static struct huffman lencode = {lencnt, lensym};   /* length code */\n    static struct huffman distcode = {distcnt, distsym};/* distance code */\n        /* bit lengths of literal codes */\n    static const unsigned char litlen[] = {\n        11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,\n        9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,\n        7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,\n        8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,\n        44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,\n        44, 173};\n        /* bit lengths of length codes 0..15 */\n    static const unsigned char lenlen[] = {2, 35, 36, 53, 38, 23};\n        /* bit lengths of distance codes 0..63 */\n    static const unsigned char distlen[] = {2, 20, 53, 230, 247, 151, 248};\n    static const short base[16] = {     /* base for length codes */\n        3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264};\n    static const char extra[16] = {     /* extra bits for length codes */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n\n    /* set up decoding tables (once--might not be thread-safe) */\n    if (virgin) {\n        construct(&litcode, litlen, sizeof(litlen));\n        construct(&lencode, lenlen, sizeof(lenlen));\n        construct(&distcode, distlen, sizeof(distlen));\n        virgin = 0;\n    }\n\n    /* read header */\n    lit = bits(s, 8);\n    if (lit > 1) return -1;\n    dict = bits(s, 8);\n    if (dict < 4 || dict > 6) return -2;\n\n    /* decode literals and length/distance pairs */\n    do {\n        if (bits(s, 1)) {\n            /* get length */\n            symbol = decode(s, &lencode);\n            len = base[symbol] + bits(s, extra[symbol]);\n            if (len == 519) break;              /* end code */\n\n            /* get distance */\n            symbol = len == 2 ? 2 : dict;\n            dist = decode(s, &distcode) << symbol;\n            dist += bits(s, symbol);\n            dist++;\n            if (s->first && dist > s->next)\n                return -3;              /* distance too far back */\n\n            /* copy length bytes from distance bytes back */\n            do {\n                to = s->out + s->next;\n                from = to - dist;\n                copy = MAXWIN;\n                if (s->next < dist) {\n                    from += copy;\n                    copy = dist;\n                }\n                copy -= s->next;\n                if (copy > len) copy = len;\n                len -= copy;\n                s->next += copy;\n                do {\n                    *to++ = *from++;\n                } while (--copy);\n                if (s->next == MAXWIN) {\n                    if (s->outfun(s->outhow, s->out, s->next)) return 1;\n                    s->next = 0;\n                    s->first = 0;\n                }\n            } while (len != 0);\n        }\n        else {\n            /* get literal and write it */\n            symbol = lit ? decode(s, &litcode) : bits(s, 8);\n            s->out[s->next++] = symbol;\n            if (s->next == MAXWIN) {\n                if (s->outfun(s->outhow, s->out, s->next)) return 1;\n                s->next = 0;\n                s->first = 0;\n            }\n        }\n    } while (1);\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/blast/blast.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/blast/blast.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "c93dff4d5783bd74589ac762ce0ebd99790a00ec33b2a97cdd44e5b3768b8531": [
  "int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow,\n          unsigned *left, unsigned char **in)\n{\n    struct state s;             /* input/output state */\n    int err;                    /* return value */\n\n    /* initialize input state */\n    s.infun = infun;\n    s.inhow = inhow;\n    if (left != NULL && *left) {\n        s.left = *left;\n        s.in = *in;\n    }\n    else\n        s.left = 0;\n    s.bitbuf = 0;\n    s.bitcnt = 0;\n\n    /* initialize output state */\n    s.outfun = outfun;\n    s.outhow = outhow;\n    s.next = 0;\n    s.first = 1;\n\n    /* return if bits() or decode() tries to read past available input */\n    if (setjmp(s.env) != 0)             /* if came back here via longjmp(), */\n        err = 2;                        /*  then skip decomp(), return error */\n    else\n        err = decomp(&s);               /* decompress */\n\n    /* return unused input */\n    if (left != NULL)\n        *left = s.left;\n    if (in != NULL)\n        *in = s.left ? s.in : NULL;\n\n    /* write any leftover output and update the error code if needed */\n    if (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)\n        err = 1;\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "224f5eedd33ca03d3d3b766aaf015ca0e46ccbbd1c4b5fca134e4102ade9622c": [
  "int main(void)\n{\n    int ret;\n    unsigned left;\n\n    /* decompress to stdout */\n    left = 0;\n    ret = blast(inf, stdin, outf, stdout, &left, NULL);\n    if (ret != 0)\n        fprintf(stderr, \"blast error: %d\\n\", ret);\n\n    /* count any leftover bytes */\n    while (getchar() != EOF)\n        left++;\n    if (left)\n        fprintf(stderr, \"blast warning: %u unused bytes of input\\n\", left);\n\n    /* return blast() error code */\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/blast/blast.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/blast/blast.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/blast/blast.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/blast/blast.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/blast/blast.c"
   ]
  }
 ],
 "76ddc0ce150ab94c95922308b949b293195d704920f4e0884f2a99cc9e9e5d7f": [
  "local size_t bythirds(size_t size)\n{\n    int n;\n    size_t m;\n\n    m = size;\n    for (n = 0; m; n++)\n        m >>= 1;\n    if (n < 3)\n        return size + 1;\n    n -= 3;\n    m = size >> n;\n    m += m == 6 ? 2 : 1;\n    m <<= n;\n    return m > size ? m : (size_t)(-1);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/pufftest.c"
   ]
  }
 ],
 "6dd8ce33e0f182494ffc9648298ec4963c2cf76c0e09b9b725261b2ffa7bf9a3": [
  "local void *load(const char *name, size_t *len)\n{\n    size_t size;\n    void *buf, *swap;\n    FILE *in;\n\n    *len = 0;\n    buf = malloc(size = 4096);\n    if (buf == NULL)\n        return NULL;\n    in = name == NULL ? stdin : fopen(name, \"rb\");\n    if (in != NULL) {\n        for (;;) {\n            *len += fread((char *)buf + *len, 1, size - *len, in);\n            if (*len < size) break;\n            size = bythirds(size);\n            if (size == *len || (swap = realloc(buf, size)) == NULL) {\n                free(buf);\n                buf = NULL;\n                break;\n            }\n            buf = swap;\n        }\n        fclose(in);\n    }\n    return buf;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/pufftest.c"
   ]
  }
 ],
 "b39ed40af6256d695f4b3ff06e65904130cd38d782d4bfc80d1f593a717a9f95": [
  "int main(int argc, char **argv)\n{\n    int ret, put = 0, fail = 0;\n    unsigned skip = 0;\n    char *arg, *name = NULL;\n    unsigned char *source = NULL, *dest;\n    size_t len = 0;\n    unsigned long sourcelen, destlen;\n\n    /* process arguments */\n    while (arg = *++argv, --argc)\n        if (arg[0] == '-') {\n            if (arg[1] == 'w' && arg[2] == 0)\n                put = 1;\n            else if (arg[1] == 'f' && arg[2] == 0)\n                fail = 1, put = 1;\n            else if (arg[1] >= '0' && arg[1] <= '9')\n                skip = (unsigned)atoi(arg + 1);\n            else {\n                fprintf(stderr, \"invalid option %s\\n\", arg);\n                return 3;\n            }\n        }\n        else if (name != NULL) {\n            fprintf(stderr, \"only one file name allowed\\n\");\n            return 3;\n        }\n        else\n            name = arg;\n    source = load(name, &len);\n    if (source == NULL) {\n        fprintf(stderr, \"memory allocation failure\\n\");\n        return 4;\n    }\n    if (len == 0) {\n        fprintf(stderr, \"could not read %s, or it was empty\\n\",\n                name == NULL ? \"<stdin>\" : name);\n        free(source);\n        return 3;\n    }\n    if (skip >= len) {\n        fprintf(stderr, \"skip request of %d leaves no input\\n\", skip);\n        free(source);\n        return 3;\n    }\n\n    /* test inflate data with offset skip */\n    len -= skip;\n    sourcelen = (unsigned long)len;\n    ret = puff(NIL, &destlen, source + skip, &sourcelen);\n    if (ret)\n        fprintf(stderr, \"puff() failed with return code %d\\n\", ret);\n    else {\n        fprintf(stderr, \"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n        if (sourcelen < len) fprintf(stderr, \"%lu compressed bytes unused\\n\",\n                                     len - sourcelen);\n    }\n\n    /* if requested, inflate again and write decompressd data to stdout */\n    if (put && ret == 0) {\n        if (fail)\n            destlen >>= 1;\n        dest = malloc(destlen);\n        if (dest == NULL) {\n            fprintf(stderr, \"memory allocation failure\\n\");\n            free(source);\n            return 4;\n        }\n        puff(dest, &destlen, source + skip, &sourcelen);\n        SET_BINARY_MODE(stdout);\n        fwrite(dest, 1, destlen, stdout);\n        free(dest);\n    }\n\n    /* clean up */\n    free(source);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/pufftest.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/pufftest.c"
   ]
  }
 ],
 "9bdea6a4835d1d8e18327a2c30b390b9f4c21b9311fcfdd1c8fb88326895f648": [
  "local int decode(struct state *s, const struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n\n    code = first = index = 0;\n    for (len = 1; len <= MAXBITS; len++) {\n        code |= bits(s, 1);             /* get next bit */\n        count = h->count[len];\n        if (code - count < first)       /* if length len, return symbol */\n            return h->symbol[index + (code - first)];\n        index += count;                 /* else update for next length */\n        first += count;\n        first <<= 1;\n        code <<= 1;\n    }\n    return -10;                         /* ran out of codes */\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "9bd7a96de1df1ee1fab7a5b3a574d8db0ed32b91372f2ce66968faec3ad4a8c6": [
  "local int decode(struct state *s, const struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n    int bitbuf;         /* bits from stream */\n    int left;           /* bits left in next or left to process */\n    short *next;        /* next number of codes */\n\n    bitbuf = s->bitbuf;\n    left = s->bitcnt;\n    code = first = index = 0;\n    len = 1;\n    next = h->count + 1;\n    while (1) {\n        while (left--) {\n            code |= bitbuf & 1;\n            bitbuf >>= 1;\n            count = *next++;\n            if (code - count < first) { /* if length len, return symbol */\n                s->bitbuf = bitbuf;\n                s->bitcnt = (s->bitcnt - len) & 7;\n                return h->symbol[index + (code - first)];\n            }\n            index += count;             /* else update for next length */\n            first += count;\n            first <<= 1;\n            code <<= 1;\n            len++;\n        }\n        left = (MAXBITS+1) - len;\n        if (left == 0)\n            break;\n        if (s->incnt == s->inlen)\n            longjmp(s->env, 1);         /* out of input */\n        bitbuf = s->in[s->incnt++];\n        if (left > 8)\n            left = 8;\n    }\n    return -10;                         /* ran out of codes */\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "6ce6adbb20e68945e11ef142a1d1a020b91e86e7bddb83c51f8408d0d4b32990": [
  "local int construct(struct huffman *h, const short *length, int n)\n{\n    int symbol;         /* current symbol when stepping through length[] */\n    int len;            /* current length when stepping through h->count[] */\n    int left;           /* number of possible codes left of current length */\n    short offs[MAXBITS+1];      /* offsets in symbol table for each length */\n\n    /* count number of codes of each length */\n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n    if (h->count[0] == n)               /* no codes! */\n        return 0;                       /* complete, but decode() will fail */\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;                           /* one possible code of zero length */\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     /* one more bit, double codes left */\n        left -= h->count[len];          /* deduct count from possible codes */\n        if (left < 0)\n            return left;                /* over-subscribed--return negative */\n    }                                   /* left > 0 means incomplete */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n\n    /*\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     */\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n\n    /* return zero for complete set, positive for incomplete set */\n    return left;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "198f69a07220f60b0fd6950a0b0c774c64d8c196d80b07dc62d559ffe59b753a": [
  "local int codes(struct state *s,\n                const struct huffman *lencode,\n                const struct huffman *distcode)\n{\n    int symbol;         /* decoded symbol */\n    int len;            /* length for copy */\n    unsigned dist;      /* distance for copy */\n    static const short lens[29] = { /* Size base for length codes 257..285 */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n    static const short lext[29] = { /* Extra bits for length codes 257..285 */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n    static const short dists[30] = { /* Offset base for distance codes 0..29 */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\n    static const short dext[30] = { /* Extra bits for distance codes 0..29 */\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n    /* decode literals and length/distance pairs */\n    do {\n        symbol = decode(s, lencode);\n        if (symbol < 0)\n            return symbol;              /* invalid symbol */\n        if (symbol < 256) {             /* literal: symbol is the byte */\n            /* write out the literal */\n            if (s->out != NIL) {\n                if (s->outcnt == s->outlen)\n                    return 1;\n                s->out[s->outcnt] = symbol;\n            }\n            s->outcnt++;\n        }\n        else if (symbol > 256) {        /* length */\n            /* get and compute length */\n            symbol -= 257;\n            if (symbol >= 29)\n                return -10;             /* invalid fixed code */\n            len = lens[symbol] + bits(s, lext[symbol]);\n\n            /* get and check distance */\n            symbol = decode(s, distcode);\n            if (symbol < 0)\n                return symbol;          /* invalid symbol */\n            dist = dists[symbol] + bits(s, dext[symbol]);\n#ifndef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n            if (dist > s->outcnt)\n                return -11;     /* distance too far back */\n#endif\n\n            /* copy length bytes from distance bytes back */\n            if (s->out != NIL) {\n                if (s->outcnt + len > s->outlen)\n                    return 1;\n                while (len--) {\n                    s->out[s->outcnt] =\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                        dist > s->outcnt ?\n                            0 :\n#endif\n                            s->out[s->outcnt - dist];\n                    s->outcnt++;\n                }\n            }\n            else\n                s->outcnt += len;\n        }\n    } while (symbol != 256);            /* end of block symbol */\n\n    /* done with a valid fixed or dynamic block */\n    return 0;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "d2ef131c677cac3cdb8f1ec079d6d6ab4f90b74cd2da341cade0e76a5d90aade": [
  "local int fixed(struct state *s)\n{\n    static int virgin = 1;\n    static short lencnt[MAXBITS+1], lensym[FIXLCODES];\n    static short distcnt[MAXBITS+1], distsym[MAXDCODES];\n    static struct huffman lencode, distcode;\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        int symbol;\n        short lengths[FIXLCODES];\n\n        /* construct lencode and distcode */\n        lencode.count = lencnt;\n        lencode.symbol = lensym;\n        distcode.count = distcnt;\n        distcode.symbol = distsym;\n\n        /* literal/length table */\n        for (symbol = 0; symbol < 144; symbol++)\n            lengths[symbol] = 8;\n        for (; symbol < 256; symbol++)\n            lengths[symbol] = 9;\n        for (; symbol < 280; symbol++)\n            lengths[symbol] = 7;\n        for (; symbol < FIXLCODES; symbol++)\n            lengths[symbol] = 8;\n        construct(&lencode, lengths, FIXLCODES);\n\n        /* distance table */\n        for (symbol = 0; symbol < MAXDCODES; symbol++)\n            lengths[symbol] = 5;\n        construct(&distcode, lengths, MAXDCODES);\n\n        /* do this just once */\n        virgin = 0;\n    }\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "ec930d4b02cb2aa53ead7e8d16f87bfbeb3b6efca67870603cb92ff48a58fb78": [
  "local int dynamic(struct state *s)\n{\n    int nlen, ndist, ncode;             /* number of lengths in descriptor */\n    int index;                          /* index of lengths[] */\n    int err;                            /* construct() return value */\n    short lengths[MAXCODES];            /* descriptor code lengths */\n    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */\n    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */\n    struct huffman lencode, distcode;   /* length and distance codes */\n    static const short order[19] =      /* permutation of code length codes */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* construct lencode and distcode */\n    lencode.count = lencnt;\n    lencode.symbol = lensym;\n    distcode.count = distcnt;\n    distcode.symbol = distsym;\n\n    /* get number of lengths in each table, check lengths */\n    nlen = bits(s, 5) + 257;\n    ndist = bits(s, 5) + 1;\n    ncode = bits(s, 4) + 4;\n    if (nlen > MAXLCODES || ndist > MAXDCODES)\n        return -3;                      /* bad counts */\n\n    /* read code length code lengths (really), missing lengths are zero */\n    for (index = 0; index < ncode; index++)\n        lengths[order[index]] = bits(s, 3);\n    for (; index < 19; index++)\n        lengths[order[index]] = 0;\n\n    /* build huffman table for code lengths codes (use lencode temporarily) */\n    err = construct(&lencode, lengths, 19);\n    if (err != 0)               /* require complete code set here */\n        return -4;\n\n    /* read length/literal and distance code length tables */\n    index = 0;\n    while (index < nlen + ndist) {\n        int symbol;             /* decoded value */\n        int len;                /* last length to repeat */\n\n        symbol = decode(s, &lencode);\n        if (symbol < 0)\n            return symbol;          /* invalid symbol */\n        if (symbol < 16)                /* length in 0..15 */\n            lengths[index++] = symbol;\n        else {                          /* repeat instruction */\n            len = 0;                    /* assume repeating zeros */\n            if (symbol == 16) {         /* repeat last length 3..6 times */\n                if (index == 0)\n                    return -5;          /* no last length! */\n                len = lengths[index - 1];       /* last length */\n                symbol = 3 + bits(s, 2);\n            }\n            else if (symbol == 17)      /* repeat zero 3..10 times */\n                symbol = 3 + bits(s, 3);\n            else                        /* == 18, repeat zero 11..138 times */\n                symbol = 11 + bits(s, 7);\n            if (index + symbol > nlen + ndist)\n                return -6;              /* too many lengths! */\n            while (symbol--)            /* repeat last or zero symbol times */\n                lengths[index++] = len;\n        }\n    }\n\n    /* check for end-of-block code -- there better be one! */\n    if (lengths[256] == 0)\n        return -9;\n\n    /* build huffman table for literal/length codes */\n    err = construct(&lencode, lengths, nlen);\n    if (err && (err < 0 || nlen != lencode.count[0] + lencode.count[1]))\n        return -7;      /* incomplete code ok only for single length 1 code */\n\n    /* build huffman table for distance codes */\n    err = construct(&distcode, lengths + nlen, ndist);\n    if (err && (err < 0 || ndist != distcode.count[0] + distcode.count[1]))\n        return -8;      /* incomplete code ok only for single length 1 code */\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "4f63ec3c77848e25d98351b025d6e971abcb1108dab9a54d2b88dd7c8b4a93a0": [
  "int puff(unsigned char *dest,           /* pointer to destination pointer */\n         unsigned long *destlen,        /* amount of output space */\n         const unsigned char *source,   /* pointer to source data pointer */\n         unsigned long *sourcelen)      /* amount of input available */\n{\n    struct state s;             /* input/output state */\n    int last, type;             /* block information */\n    int err;                    /* return value */\n\n    /* initialize output state */\n    s.out = dest;\n    s.outlen = *destlen;                /* ignored if dest is NIL */\n    s.outcnt = 0;\n\n    /* initialize input state */\n    s.in = source;\n    s.inlen = *sourcelen;\n    s.incnt = 0;\n    s.bitbuf = 0;\n    s.bitcnt = 0;\n\n    /* return if bits() or decode() tries to read past available input */\n    if (setjmp(s.env) != 0)             /* if came back here via longjmp() */\n        err = 2;                        /* then skip do-loop, return error */\n    else {\n        /* process blocks until last block or error */\n        do {\n            last = bits(&s, 1);         /* one if last block */\n            type = bits(&s, 2);         /* block type 0..3 */\n            err = type == 0 ?\n                    stored(&s) :\n                    (type == 1 ?\n                        fixed(&s) :\n                        (type == 2 ?\n                            dynamic(&s) :\n                            -1));       /* type == 3, invalid */\n            if (err != 0)\n                break;                  /* return with error */\n        } while (!last);\n    }\n\n    /* update the lengths and return */\n    if (err <= 0) {\n        *destlen = s.outcnt;\n        *sourcelen = s.incnt;\n    }\n    return err;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/puff/puff.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/puff/puff.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/puff/puff.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/puff/puff.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/puff/puff.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "70b1802cd182e25cfca63bfa08b8c0de0d0231605e0bb27b143cb6d829bca504": [
  "void MyDoMinus64(LARGE_INTEGER *R,LARGE_INTEGER A,LARGE_INTEGER B)\r\n{\r\n    R->HighPart = A.HighPart - B.HighPart;\r\n    if (A.LowPart >= B.LowPart)\r\n        R->LowPart = A.LowPart - B.LowPart;\r\n    else\r\n    {\r\n        R->LowPart = A.LowPart - B.LowPart;\r\n        R->HighPart --;\r\n    }\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "2f977090e194a281f87dfdbdeadb71f0395025ea313c8a6a9ab22c911bfbb255": [
  "void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\r\n{\r\n //   printf(\"rdtsc = %I64x\\n\",__rdtsc());\r\n   pbeginTime64->QuadPart=__rdtsc();\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "e30b3392fb13de8e476a56b5b0062832dc979d57e32a6671dbd64c4e1e2e9feb": [
  "LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n{\r\n    LARGE_INTEGER LIres;\r\n    unsigned _int64 res=__rdtsc()-((unsigned _int64)(beginTime64.QuadPart));\r\n    LIres.QuadPart=res;\r\n   // printf(\"rdtsc = %I64x\\n\",__rdtsc());\r\n    return LIres;\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "b0a1957b52951723a10ceeaaefce5967ed2a81f89fc9be3d6607ae0aa8e9afa1": [
  "void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)\r\n{\r\n    DWORD dwEdx,dwEax;\r\n    _asm\r\n    {\r\n        rdtsc\r\n        mov dwEax,eax\r\n        mov dwEdx,edx\r\n    }\r\n    pbeginTime64->LowPart=dwEax;\r\n    pbeginTime64->HighPart=dwEdx;\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "ef354ffa3478263b09eaeb7d2670b1b411ed49b6347dcbf1bb64a76b55588b51": [
  "void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\r\n{\r\n    myGetRDTSC32(pbeginTime64);\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "102857bf8923d441623858625be5c42333d8cf38f0d4e3f89e80cd6e065c0b84": [
  "LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n{\r\n    LARGE_INTEGER LIres,endTime64;\r\n    myGetRDTSC32(&endTime64);\r\n\r\n    LIres.LowPart=LIres.HighPart=0;\r\n    MyDoMinus64(&LIres,endTime64,beginTime64);\r\n    return LIres;\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "7d2ed82ff9cd3d57ad22c99476e5403f7e4068b9df0bb74e0a1a10e480045b2d": [
  "void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)\r\n{\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "afdc6ef2428fc60e10737bc53abd6424ea5a4255db56f2f2d8772b24e86cd5e1": [
  "void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\r\n{\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "a8613ead7dcc9e4ca27f584681f36914c27fc11ec22059626b48a79875275000": [
  "LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n{\r\n    LARGE_INTEGER lr;\r\n    lr.QuadPart=0;\r\n    return lr;\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "1c2bd2132e465f36fb7be8cc8deb5e330bbf8fc8dea2277234c32887fe7255e3": [
  "void BeginCountPerfCounter(LARGE_INTEGER * pbeginTime64,BOOL fComputeTimeQueryPerf)\r\n{\r\n    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(pbeginTime64)))\r\n    {\r\n        pbeginTime64->LowPart = GetTickCount();\r\n        pbeginTime64->HighPart = 0;\r\n    }\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "6507aa87a5c23d754c6c276519ea3bd547a3151af7c0bdc1bf290d21fe6fb160": [
  "DWORD GetMsecSincePerfCounter(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n{\r\n    LARGE_INTEGER endTime64,ticksPerSecond,ticks;\r\n    DWORDLONG ticksShifted,tickSecShifted;\r\n    DWORD dwLog=16+0;\r\n    DWORD dwRet;\r\n    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(&endTime64)))\r\n        dwRet = (GetTickCount() - beginTime64.LowPart)*1;\r\n    else\r\n    {\r\n        MyDoMinus64(&ticks,endTime64,beginTime64);\r\n        QueryPerformanceFrequency(&ticksPerSecond);\r\n\r\n\r\n        {\r\n            ticksShifted = Int64ShrlMod32(*(DWORDLONG*)&ticks,dwLog);\r\n            tickSecShifted = Int64ShrlMod32(*(DWORDLONG*)&ticksPerSecond,dwLog);\r\n\r\n        }\r\n\r\n        dwRet = (DWORD)((((DWORD)ticksShifted)*1000)/(DWORD)(tickSecShifted));\r\n        dwRet *=1;\r\n    }\r\n    return dwRet;\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "2a24c16ebe5f4909777ae6a477d62aed35f2d4142e038cf4f5bebd90c207bee3": [
  "int ReadFileMemory(const char* filename,long* plFileSize,unsigned char** pFilePtr)\r\n{\r\n    FILE* stream;\r\n    unsigned char* ptr;\r\n    int retVal=1;\r\n    stream=fopen(filename, \"rb\");\r\n    if (stream==NULL)\r\n        return 0;\r\n\r\n    fseek(stream,0,SEEK_END);\r\n\r\n    *plFileSize=ftell(stream);\r\n    fseek(stream,0,SEEK_SET);\r\n    ptr=malloc((*plFileSize)+1);\r\n    if (ptr==NULL)\r\n        retVal=0;\r\n    else\r\n    {\r\n        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))\r\n            retVal=0;\r\n    }\r\n    fclose(stream);\r\n    *pFilePtr=ptr;\r\n    return retVal;\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "1b031df92e34ebbcbf8b7a3b6db2f2e55dd5f24090e6044bccbbb3e96997e6b3": [
  "int main(int argc, char *argv[])\r\n{\r\n    int BlockSizeCompress=0x8000;\r\n    int BlockSizeUncompress=0x8000;\r\n    int cprLevel=Z_DEFAULT_COMPRESSION ;\r\n    long lFileSize;\r\n    unsigned char* FilePtr;\r\n    long lBufferSizeCpr;\r\n    long lBufferSizeUncpr;\r\n    long lCompressedSize=0;\r\n    unsigned char* CprPtr;\r\n    unsigned char* UncprPtr;\r\n    long lSizeCpr,lSizeUncpr;\r\n    DWORD dwGetTick,dwMsecQP;\r\n    LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;\r\n\r\n    if (argc<=1)\r\n    {\r\n        printf(\"run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\\n\");\r\n        return 0;\r\n    }\r\n\r\n    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)\r\n    {\r\n        printf(\"error reading %s\\n\",argv[1]);\r\n        return 1;\r\n    }\r\n    else printf(\"file %s read, %u bytes\\n\",argv[1],lFileSize);\r\n\r\n    if (argc>=3)\r\n        BlockSizeCompress=atol(argv[2]);\r\n\r\n    if (argc>=4)\r\n        BlockSizeUncompress=atol(argv[3]);\r\n\r\n    if (argc>=5)\r\n        cprLevel=(int)atol(argv[4]);\r\n\r\n    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;\r\n    lBufferSizeUncpr = lBufferSizeCpr;\r\n\r\n    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);\r\n\r\n    BeginCountPerfCounter(&li_qp,TRUE);\r\n    dwGetTick=GetTickCount();\r\n    BeginCountRdtsc(&li_rdtsc);\r\n    {\r\n        z_stream zcpr;\r\n        int ret=Z_OK;\r\n        long lOrigToDo = lFileSize;\r\n        long lOrigDone = 0;\r\n        int step=0;\r\n        memset(&zcpr,0,sizeof(z_stream));\r\n        deflateInit(&zcpr,cprLevel);\r\n\r\n        zcpr.next_in = FilePtr;\r\n        zcpr.next_out = CprPtr;\r\n\r\n\r\n        do\r\n        {\r\n            long all_read_before = zcpr.total_in;\r\n            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);\r\n            zcpr.avail_out = BlockSizeCompress;\r\n            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);\r\n            lOrigDone += (zcpr.total_in-all_read_before);\r\n            lOrigToDo -= (zcpr.total_in-all_read_before);\r\n            step++;\r\n        } while (ret==Z_OK);\r\n\r\n        lSizeCpr=zcpr.total_out;\r\n        deflateEnd(&zcpr);\r\n        dwGetTick=GetTickCount()-dwGetTick;\r\n        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);\r\n        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);\r\n        printf(\"total compress size = %u, in %u step\\n\",lSizeCpr,step);\r\n        printf(\"time = %u msec = %f sec\\n\",dwGetTick,dwGetTick/(double)1000.);\r\n        printf(\"defcpr time QP = %u msec = %f sec\\n\",dwMsecQP,dwMsecQP/(double)1000.);\r\n        printf(\"defcpr result rdtsc = %I64x\\n\\n\",dwResRdtsc.QuadPart);\r\n    }\r\n\r\n    CprPtr=(unsigned char*)realloc(CprPtr,lSizeCpr);\r\n    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);\r\n\r\n    BeginCountPerfCounter(&li_qp,TRUE);\r\n    dwGetTick=GetTickCount();\r\n    BeginCountRdtsc(&li_rdtsc);\r\n    {\r\n        z_stream zcpr;\r\n        int ret=Z_OK;\r\n        long lOrigToDo = lSizeCpr;\r\n        long lOrigDone = 0;\r\n        int step=0;\r\n        memset(&zcpr,0,sizeof(z_stream));\r\n        inflateInit(&zcpr);\r\n\r\n        zcpr.next_in = CprPtr;\r\n        zcpr.next_out = UncprPtr;\r\n\r\n\r\n        do\r\n        {\r\n            long all_read_before = zcpr.total_in;\r\n            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);\r\n            zcpr.avail_out = BlockSizeUncompress;\r\n            ret=inflate(&zcpr,Z_SYNC_FLUSH);\r\n            lOrigDone += (zcpr.total_in-all_read_before);\r\n            lOrigToDo -= (zcpr.total_in-all_read_before);\r\n            step++;\r\n        } while (ret==Z_OK);\r\n\r\n        lSizeUncpr=zcpr.total_out;\r\n        inflateEnd(&zcpr);\r\n        dwGetTick=GetTickCount()-dwGetTick;\r\n        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);\r\n        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);\r\n        printf(\"total uncompress size = %u, in %u step\\n\",lSizeUncpr,step);\r\n        printf(\"time = %u msec = %f sec\\n\",dwGetTick,dwGetTick/(double)1000.);\r\n        printf(\"uncpr  time QP = %u msec = %f sec\\n\",dwMsecQP,dwMsecQP/(double)1000.);\r\n        printf(\"uncpr  result rdtsc = %I64x\\n\\n\",dwResRdtsc.QuadPart);\r\n    }\r\n\r\n    if (lSizeUncpr==lFileSize)\r\n    {\r\n        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)\r\n            printf(\"compare ok\\n\");\r\n\r\n    }\r\n\r\n    return 0;\r\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "0238c651ecdff6cc002afa0a5f8a2dfdb0876283468e9cf89df0ddaf6ab5ee3b": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef ZLIB_DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifdef NO_vsnprintf\n    flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#else\n    flags += 1L << 24;\n#  ifdef NO_snprintf\n    flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "zutil.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "zutil.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "zutil.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "zutil.c"
   ]
  }
 ],
 "599c48b732363082947f87c47f4a16e28ae63f452438841f95afc22dfd5ad770": [
  "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf;\n    ulg bsize = (ulg)items*size;\n\n    (void)opaque;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "zutil.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "zutil.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "zutil.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "zutil.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "zutil.c"
   ]
  }
 ],
 "70fa384dff7fcb6258fdd1b9cc2234470b0ab79a41f8ff2b22492f0e55896404": [
  "void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    int n;\n\n    (void)opaque;\n\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    Assert(0, \"zcfree: ptr not found\");\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "zutil.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "zutil.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "zutil.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "zutil.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "zutil.c"
   ]
  }
 ],
 "1b81e95139c146d911660b903550f895fbe9626b6ed8e9c8890cec5f021c8073": [
  "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)\n{\n    (void)opaque;\n    return _halloc((long)items, size);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "zutil.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "zutil.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "zutil.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "zutil.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "zutil.c"
   ]
  }
 ],
 "ae51b6a7ff3f66c51dc84dad50a23029a96dbcc25bd1dde701c91be9c0fec322": [
  "void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    (void)opaque;\n    _hfree(ptr);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "zutil.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "zutil.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "zutil.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "zutil.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "zutil.c"
   ]
  }
 ],
 "e762e9c6773eadac1ce953350807e9e3667c38de54e86dfdbb018262c265fbc7": [
  "local void make_crc_table()\n{\n    z_crc_t c;\n    int n, k;\n    z_crc_t poly;                       /* polynomial exclusive-or pattern */\n    /* terms of polynomial defining this crc (except x^32): */\n    static volatile int first = 1;      /* flag to limit concurrent making */\n    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n    /* See if another task is already doing this (not thread-safe, but better\n       than nothing -- significantly reduces duration of vulnerability in\n       case the advice about DYNAMIC_CRC_TABLE is ignored) */\n    if (first) {\n        first = 0;\n\n        /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n        poly = 0;\n        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)\n            poly |= (z_crc_t)1 << (31 - p[n]);\n\n        /* generate a crc for every 8-bit value */\n        for (n = 0; n < 256; n++) {\n            c = (z_crc_t)n;\n            for (k = 0; k < 8; k++)\n                c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n            crc_table[0][n] = c;\n        }\n\n#ifdef BYFOUR\n        /* generate crc for each value followed by one, two, and three zeros,\n           and then the byte reversal of those as well as the first table */\n        for (n = 0; n < 256; n++) {\n            c = crc_table[0][n];\n            crc_table[4][n] = ZSWAP32(c);\n            for (k = 1; k < 4; k++) {\n                c = crc_table[0][c & 0xff] ^ (c >> 8);\n                crc_table[k][n] = c;\n                crc_table[k + 4][n] = ZSWAP32(c);\n            }\n        }\n#endif /* BYFOUR */\n\n        crc_table_empty = 0;\n    }\n    else {      /* not first */\n        /* wait for the other guy to finish (not efficient, but rare) */\n        while (crc_table_empty)\n            ;\n    }\n\n#ifdef MAKECRCH\n    /* write out CRC tables to crc32.h */\n    {\n        FILE *out;\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n        fprintf(out, \"local const z_crc_t FAR \");\n        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n        write_table(out, crc_table[0]);\n#  ifdef BYFOUR\n        fprintf(out, \"#ifdef BYFOUR\\n\");\n        for (k = 1; k < 8; k++) {\n            fprintf(out, \"  },\\n  {\\n\");\n            write_table(out, crc_table[k]);\n        }\n        fprintf(out, \"#endif\\n\");\n#  endif /* BYFOUR */\n        fprintf(out, \"  }\\n};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "crc32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "crc32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "crc32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "crc32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "crc32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "crc32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "crc32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "crc32.c"
   ]
  }
 ],
 "cf91e571c9d18d3b6130ca3e09b0c034d5298917754d2d6bd0d74366c98ed8ce": [
  "const z_crc_t FAR * ZEXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n    if (crc_table_empty)\n        make_crc_table();\n#endif /* DYNAMIC_CRC_TABLE */\n    return (const z_crc_t FAR *)crc_table;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "crc32.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "crc32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "crc32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "crc32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "crc32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "crc32.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "crc32.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "crc32.c"
   ]
  }
 ],
 "459e907a194579e6a04cd32a6bba09fe8be6c5ec21b83bb154ca84f3cc87579f": [
  "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)\n{\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memcpy(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "gzwrite.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "gzwrite.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "gzwrite.c"
   ]
  }
 ],
 "ee355368226284a3f8257fd4c57ac433e5cafd347d8a57c67ca8fce3e14380f4": [
  "int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)\n{\n    va_list va;\n    int ret;\n\n    va_start(va, format);\n    ret = gzvprintf(file, format, va);\n    va_end(va);\n    return ret;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "gzwrite.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "gzwrite.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "gzwrite.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "gzwrite.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "gzwrite.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "gzwrite.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "gzwrite.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "gzwrite.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "gzwrite.c"
   ]
  }
 ],
 "3d41b661343fc456ae950fffd122ae7ae029e98b2655164ead23c5f212c088c6": [
  "unsigned ZLIB_INTERNAL gz_intmax()\n{\n    unsigned p, q;\n\n    p = 1;\n    do {\n        q = p;\n        p <<= 1;\n        p++;\n    } while (p > q);\n    return q >> 1;\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "gzlib.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "gzlib.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "gzlib.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "gzlib.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "gzlib.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "gzlib.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "gzlib.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "gzlib.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "gzlib.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "gzlib.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "gzlib.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "gzlib.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "gzlib.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "gzlib.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "gzlib.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "gzlib.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "gzlib.c"
   ]
  }
 ],
 "2787b3432cd65a0ead3c9ae597a37ff924a1b14f6edf19722b488d0328882a6f": [
  "void makefixed()\n{\n    unsigned low, size;\n    struct inflate_state state;\n\n    fixedtables(&state);\n    puts(\"    /* inffixed.h -- table for decoding fixed codes\");\n    puts(\"     * Generated automatically by makefixed().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 7) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", (low & 127) == 99 ? 64 : state.lencode[low].op,\n               state.lencode[low].bits, state.lencode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.distcode[low].op, state.distcode[low].bits,\n               state.distcode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "inflate.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "inflate.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "inflate.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "inflate.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "inflate.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "inflate.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "inflate.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "inflate.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "inflate.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "inflate.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "inflate.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "inflate.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "inflate.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "inflate.c"
   ]
  }
 ],
 "20658b18d9b31968b43927657cb6d41f8a1f0593f22bcfbe3599fcb4d4a0f0a5": [
  "local void tr_static_init()\n{\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n#endif\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            _length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            _dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            _dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "trees.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "trees.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "trees.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "trees.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "trees.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "trees.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "trees.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "trees.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "trees.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "trees.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "trees.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "trees.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "trees.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "trees.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "trees.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "trees.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "trees.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "trees.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "trees.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "trees.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "trees.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "trees.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "trees.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "trees.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "trees.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "trees.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "trees.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "trees.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "trees.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "trees.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "trees.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "trees.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "trees.c"
   ]
  }
 ],
 "69abb05055ff734077ccdb98f2a65256079b03adb6a1292e1d66ed010c54af6c": [
  "void gen_trees_header()\n{\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header != NULL, \"Can't open trees.h\");\n    fprintf(header,\n            \"/* header created automatically with -DGEN_TREES_H */\\n\\n\");\n\n    fprintf(header, \"local const ct_data static_ltree[L_CODES+2] = {\\n\");\n    for (i = 0; i < L_CODES+2; i++) {\n        fprintf(header, \"{{%3u},{%3u}}%s\", static_ltree[i].Code,\n                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));\n    }\n\n    fprintf(header, \"local const ct_data static_dtree[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"{{%2u},{%2u}}%s\", static_dtree[i].Code,\n                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));\n    }\n\n    fprintf(header, \"const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\\n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) {\n        fprintf(header, \"%2u%s\", _dist_code[i],\n                SEPARATOR(i, DIST_CODE_LEN-1, 20));\n    }\n\n    fprintf(header,\n        \"const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\\n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {\n        fprintf(header, \"%2u%s\", _length_code[i],\n                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    }\n\n    fprintf(header, \"local const int base_length[LENGTH_CODES] = {\\n\");\n    for (i = 0; i < LENGTH_CODES; i++) {\n        fprintf(header, \"%1u%s\", base_length[i],\n                SEPARATOR(i, LENGTH_CODES-1, 20));\n    }\n\n    fprintf(header, \"local const int base_dist[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"%5u%s\", base_dist[i],\n                SEPARATOR(i, D_CODES-1, 10));\n    }\n\n    fclose(header);\n}",
  {
   "v1.2.10": [
    "2017-01-02 17:53:59",
    "trees.c"
   ],
   "v1.2.11": [
    "2017-01-15 09:18:46",
    "trees.c"
   ],
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "trees.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "trees.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "trees.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "trees.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "trees.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "trees.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "trees.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "trees.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "trees.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "trees.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "trees.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "trees.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "trees.c"
   ],
   "v1.2.9": [
    "2016-12-31 11:41:31",
    "trees.c"
   ]
  }
 ],
 "4c803c840956fc4f9a24e55e431219295361e016b8a4ed8efa018c903975c001": [
  "local void string_clear(string_t *s) {\n    s->str[0] = 0;\n    s->len = 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "eadbde8c56ceb87f23e9e9164e1c85983629f8e60386586d85d24c37772d7d6a": [
  "local void string_init(string_t *s) {\n    s->size = 16;\n    s->str = malloc(s->size);\n    assert(s->str != NULL && \"out of memory\");\n    string_clear(s);\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "5c925fc274334547f8e48b4520cf469628b35bcdf043e4c6fa54e7e64f19664d": [
  "local void string_free(string_t *s) {\n    free(s->str);\n    s->str = NULL;\n    s->size = 0;\n    s->len = 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "fc39fbb1ff0474a551c1d084f3caba01ec95b2f8799ec5add6d0be7efad612ac": [
  "local void string_printf(string_t *s, char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    size_t len = s->len;\n    int ret = vsnprintf(s->str + len, s->size - len, fmt, ap);\n    assert(ret >= 0 && \"out of memory\");\n    s->len += ret;\n    if (s->size < s->len + 1) {\n        do {\n            s->size <<= 1;\n            assert(s->size != 0 && \"overflow\");\n        } while (s->size < s->len + 1);\n        s->str = realloc(s->str, s->size);\n        assert(s->str != NULL && \"out of memory\");\n        vsnprintf(s->str + len, s->size - len, fmt, ap);\n    }\n    va_end(ap);\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "54af497a37833615e7faa2a025f430891ee668f08a7ce0fda3d7de317306b33c": [
  "local inline size_t map(int syms, int left, int len) {\n    return ((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) +\n            (left >> 1) - 1) * (g.max - 1) +\n           len - 1;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "06fd06480f18acece20956fe2090f664bad55f08f3d73e559356a3f48ee4b194": [
  "local void cleanup(void) {\n    if (g.done != NULL) {\n        for (size_t n = 0; n < g.size; n++)\n            if (g.done[n].len)\n                free(g.done[n].vec);\n        g.size = 0;\n        free(g.done);   g.done = NULL;\n    }\n    free(g.num);    g.num = NULL;\n    free(g.code);   g.code = NULL;\n    string_free(&g.out);\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "58bf5b1ecc520e7d6947506b3d24f281f0496e3fdff48b2373a6f390a25026c8": [
  "local big_t count(int syms, int left, int len) {\n    // see if only one possible code\n    if (syms == left)\n        return 1;\n\n    // note and verify the expected state\n    assert(syms > left && left > 0 && len < g.max);\n\n    // see if we've done this one already\n    size_t index = map(syms, left, len);\n    big_t got = g.num[index];\n    if (got)\n        return got;         // we have -- return the saved result\n\n    // we need to use at least this many bit patterns so that the code won't be\n    // incomplete at the next length (more bit patterns than symbols)\n    int least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    // we can use at most this many bit patterns, lest there not be enough\n    // available for the remaining symbols at the maximum length (if there were\n    // no limit to the code length, this would become: most = left - 1)\n    int most = (((code_t)left << (g.max - len)) - syms) /\n               (((code_t)1 << (g.max - len)) - 1);\n\n    // count all possible codes from this juncture and add them up\n    big_t sum = 0;\n    for (int use = least; use <= most; use++) {\n        got = count(syms - use, (left - use) << 1, len + 1);\n        sum += got;\n        if (got == (big_t)-1 || sum < got)      // overflow\n            return (big_t)-1;\n    }\n\n    // verify that all recursive calls are productive\n    assert(sum != 0);\n\n    // save the result and return it\n    g.num[index] = sum;\n    return sum;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "6c4ad51533c18b42bfdd3c30abacef1820e43bde6157fe198bebb6f4e5fa4829": [
  "local int been_here(int syms, int left, int len, int mem, int rem) {\n    // point to vector for (syms,left,len), bit in vector for (mem,rem)\n    size_t index = map(syms, left, len);\n    mem -= 1 << g.root;             // mem always includes the root table\n    mem >>= 1;                      // mem and rem are always even\n    rem >>= 1;\n    size_t offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    int bit = 1 << (mem & 7);\n\n    // see if we've been here\n    size_t length = g.done[index].len;\n    if (offset < length && (g.done[index].vec[offset] & bit) != 0)\n        return 1;       // done this!\n\n    // we haven't been here before -- set the bit to show we have now\n\n    // see if we need to lengthen the vector in order to set the bit\n    if (length <= offset) {\n        // if we have one already, enlarge it, zero out the appended space\n        char *vector;\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(g.done[index].vec, length);\n            assert(vector != NULL && \"out of memory\");\n            memset(vector + g.done[index].len, 0, length - g.done[index].len);\n        }\n\n        // otherwise we need to make a new vector and zero it out\n        else {\n            length = 16;\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, 1);\n            assert(vector != NULL && \"out of memory\");\n        }\n\n        // install the new vector\n        g.done[index].len = length;\n        g.done[index].vec = vector;\n    }\n\n    // set the bit\n    g.done[index].vec[offset] |= bit;\n    return 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "8223ec0f58138d4a523422d74bb0f74640d55b2fcdaf3bb758a8ba9b1b0925c5": [
  "local void examine(int syms, int left, int len, int mem, int rem) {\n    // see if we have a complete code\n    if (syms == left) {\n        // set the last code entry\n        g.code[len] = left;\n\n        // complete computation of memory used by this code\n        while (rem < left) {\n            left -= rem;\n            rem = 1 << (len - g.root);\n            mem += rem;\n        }\n        assert(rem == left);\n\n        // if this is at the maximum, show the sub-code\n        if (mem >= g.large) {\n            // if this is a new maximum, update the maximum and clear out the\n            // printed sub-codes from the previous maximum\n            if (mem > g.large) {\n                g.large = mem;\n                string_clear(&g.out);\n            }\n\n            // compute the starting state for this sub-code\n            syms = 0;\n            left = 1 << g.max;\n            for (int bits = g.max; bits > g.root; bits--) {\n                syms += g.code[bits];\n                left -= g.code[bits];\n                assert((left & 1) == 0);\n                left >>= 1;\n            }\n\n            // print the starting state and the resulting sub-code to g.out\n            string_printf(&g.out, \"<%u, %u, %u>:\",\n                          syms, g.root + 1, ((1 << g.root) - left) << 1);\n            for (int bits = g.root + 1; bits <= g.max; bits++)\n                if (g.code[bits])\n                    string_printf(&g.out, \" %d[%d]\", g.code[bits], bits);\n            string_printf(&g.out, \"\\n\");\n        }\n\n        // remove entries as we drop back down in the recursion\n        g.code[len] = 0;\n        return;\n    }\n\n    // prune the tree if we can\n    if (been_here(syms, left, len, mem, rem))\n        return;\n\n    // we need to use at least this many bit patterns so that the code won't be\n    // incomplete at the next length (more bit patterns than symbols)\n    int least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    // we can use at most this many bit patterns, lest there not be enough\n    // available for the remaining symbols at the maximum length (if there were\n    // no limit to the code length, this would become: most = left - 1)\n    int most = (((code_t)left << (g.max - len)) - syms) /\n               (((code_t)1 << (g.max - len)) - 1);\n\n    // occupy least table spaces, creating new sub-tables as needed\n    int use = least;\n    while (rem < use) {\n        use -= rem;\n        rem = 1 << (len - g.root);\n        mem += rem;\n    }\n    rem -= use;\n\n    // examine codes from here, updating table space as we go\n    for (use = least; use <= most; use++) {\n        g.code[len] = use;\n        examine(syms - use, (left - use) << 1, len + 1,\n                mem + (rem ? 1 << (len - g.root) : 0), rem << 1);\n        if (rem == 0) {\n            rem = 1 << (len - g.root);\n            mem += rem;\n        }\n        rem--;\n    }\n\n    // remove entries as we drop back down in the recursion\n    g.code[len] = 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "6aa8ecf1605ac07fc9c10efa3d6f3a3cf64756c89a9cf50f67a33e148810793f": [
  "local void enough(int syms) {\n    // clear code\n    for (int n = 0; n <= g.max; n++)\n        g.code[n] = 0;\n\n    // look at all (root + 1) bit and longer codes\n    string_clear(&g.out);           // empty saved results\n    g.large = 1 << g.root;          // base table\n    if (g.root < g.max)             // otherwise, there's only a base table\n        for (int n = 3; n <= syms; n++)\n            for (int left = 2; left < n; left += 2) {\n                // look at all reachable (root + 1) bit nodes, and the\n                // resulting codes (complete at root + 2 or more)\n                size_t index = map(n, left, g.root + 1);\n                if (g.root + 1 < g.max && g.num[index]) // reachable node\n                    examine(n, left, g.root + 1, 1 << g.root, 0);\n\n                // also look at root bit codes with completions at root + 1\n                // bits (not saved in num, since complete), just in case\n                if (g.num[index - 1] && n <= left << 1)\n                    examine((n - left) << 1, (n - left) << 1, g.root + 1,\n                            1 << g.root, 0);\n            }\n\n    // done\n    printf(\"maximum of %d table entries for root = %d\\n\", g.large, g.root);\n    fputs(g.out.str, stdout);\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "5a65493f3cb16b770ea068143d36cbe6a724d64ca159c98f9354ba93e4dffc29": [
  "int main(int argc, char **argv) {\n    // set up globals for cleanup()\n    g.code = NULL;\n    g.num = NULL;\n    g.done = NULL;\n    string_init(&g.out);\n\n    // get arguments -- default to the deflate literal/length code\n    int syms = 286;\n    g.root = 9;\n    g.max = 15;\n    if (argc > 1) {\n        syms = atoi(argv[1]);\n        if (argc > 2) {\n            g.root = atoi(argv[2]);\n            if (argc > 3)\n                g.max = atoi(argv[3]);\n        }\n    }\n    if (argc > 4 || syms < 2 || g.root < 1 || g.max < 1) {\n        fputs(\"invalid arguments, need: [sym >= 2 [root >= 1 [max >= 1]]]\\n\",\n              stderr);\n        return 1;\n    }\n\n    // if not restricting the code length, the longest is syms - 1\n    if (g.max > syms - 1)\n        g.max = syms - 1;\n\n    // determine the number of bits in a code_t\n    int bits = 0;\n    for (code_t word = 1; word; word <<= 1)\n        bits++;\n\n    // make sure that the calculation of most will not overflow\n    if (g.max > bits || (code_t)(syms - 2) >= ((code_t)-1 >> (g.max - 1))) {\n        fputs(\"abort: code length too long for internal types\\n\", stderr);\n        return 1;\n    }\n\n    // reject impossible code requests\n    if ((code_t)(syms - 1) > ((code_t)1 << g.max) - 1) {\n        fprintf(stderr, \"%d symbols cannot be coded in %d bits\\n\",\n                syms, g.max);\n        return 1;\n    }\n\n    // allocate code vector\n    g.code = calloc(g.max + 1, sizeof(int));\n    assert(g.code != NULL && \"out of memory\");\n\n    // determine size of saved results array, checking for overflows,\n    // allocate and clear the array (set all to zero with calloc())\n    if (syms == 2)              // iff max == 1\n        g.num = NULL;           // won't be saving any results\n    else {\n        g.size = syms >> 1;\n        int n = (syms - 1) >> 1;\n        assert(g.size <= (size_t)-1 / n && \"overflow\");\n        g.size *= n;\n        n = g.max - 1;\n        assert(g.size <= (size_t)-1 / n && \"overflow\");\n        g.size *= n;\n        g.num = calloc(g.size, sizeof(big_t));\n        assert(g.num != NULL && \"out of memory\");\n    }\n\n    // count possible codes for all numbers of symbols, add up counts\n    big_t sum = 0;\n    for (int n = 2; n <= syms; n++) {\n        big_t got = count(n, 2, 1);\n        sum += got;\n        assert(got != (big_t)-1 && sum >= got && \"overflow\");\n    }\n    printf(\"%\"PRIbig\" total codes for 2 to %d symbols\", sum, syms);\n    if (g.max < syms - 1)\n        printf(\" (%d-bit length limit)\\n\", g.max);\n    else\n        puts(\" (no length limit)\");\n\n    // allocate and clear done array for been_here()\n    if (syms == 2)\n        g.done = NULL;\n    else {\n        g.done = calloc(g.size, sizeof(struct tab));\n        assert(g.done != NULL && \"out of memory\");\n    }\n\n    // find and show maximum inflate table usage\n    if (g.root > g.max)             // reduce root to max length\n        g.root = g.max;\n    if ((code_t)syms < ((code_t)1 << (g.root + 1)))\n        enough(syms);\n    else\n        fputs(\"cannot handle minimum code lengths > root\", stderr);\n\n    // done\n    cleanup();\n    return 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/enough.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/enough.c"
   ]
  }
 ],
 "00a5c8cc4c89d6f7f220dbda77e86e6dd5f57cc952ba6d01685dd88686f6c29d": [
  "void deflate_index_free(struct deflate_index *index)\n{\n    if (index != NULL) {\n        free(index->list);\n        free(index);\n    }\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zran.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zran.c"
   ]
  }
 ],
 "1019a782b195b555769f08377aca717b512c8fec309dcb2275314167a7e6fc67": [
  "static struct deflate_index *addpoint(struct deflate_index *index, int bits,\n                                      off_t in, off_t out, unsigned left,\n                                      unsigned char *window)\n{\n    struct point *next;\n\n    /* if list is empty, create it (start with eight points) */\n    if (index == NULL) {\n        index = malloc(sizeof(struct deflate_index));\n        if (index == NULL) return NULL;\n        index->list = malloc(sizeof(struct point) << 3);\n        if (index->list == NULL) {\n            free(index);\n            return NULL;\n        }\n        index->gzip = 8;\n        index->have = 0;\n    }\n\n    /* if list is full, make it bigger */\n    else if (index->have == index->gzip) {\n        index->gzip <<= 1;\n        next = realloc(index->list, sizeof(struct point) * index->gzip);\n        if (next == NULL) {\n            deflate_index_free(index);\n            return NULL;\n        }\n        index->list = next;\n    }\n\n    /* fill in entry and increment how many we have */\n    next = (struct point *)(index->list) + index->have;\n    next->bits = bits;\n    next->in = in;\n    next->out = out;\n    if (left)\n        memcpy(next->window, window + WINSIZE - left, left);\n    if (left < WINSIZE)\n        memcpy(next->window + left, window, WINSIZE - left);\n    index->have++;\n\n    /* return list, possibly reallocated */\n    return index;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zran.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zran.c"
   ]
  }
 ],
 "e8acc1843db323c12cb213d737faeef612a92206625f2a905507441675983383": [
  "int deflate_index_build(FILE *in, off_t span, struct deflate_index **built)\n{\n    int ret;\n    int gzip = 0;               /* true if reading a gzip file */\n    off_t totin, totout;        /* our own total counters to avoid 4GB limit */\n    off_t last;                 /* totout value of last access point */\n    struct deflate_index *index;    /* access points being generated */\n    z_stream strm;\n    unsigned char input[CHUNK];\n    unsigned char window[WINSIZE];\n\n    /* initialize inflate */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, 47);      /* automatic zlib or gzip decoding */\n    if (ret != Z_OK)\n        return ret;\n\n    /* inflate the input, maintain a sliding window, and build an index -- this\n       also validates the integrity of the compressed data using the check\n       information in the gzip or zlib stream */\n    totin = totout = last = 0;\n    index = NULL;               /* will be allocated by first addpoint() */\n    strm.avail_out = 0;\n    do {\n        /* get some compressed data from input file */\n        strm.avail_in = fread(input, 1, CHUNK, in);\n        if (ferror(in)) {\n            ret = Z_ERRNO;\n            goto deflate_index_build_error;\n        }\n        if (strm.avail_in == 0) {\n            ret = Z_DATA_ERROR;\n            goto deflate_index_build_error;\n        }\n        strm.next_in = input;\n\n        /* check for a gzip stream */\n        if (totin == 0 && strm.avail_in >= 3 &&\n            input[0] == 31 && input[1] == 139 && input[2] == 8)\n            gzip = 1;\n\n        /* process all of that, or until end of stream */\n        do {\n            /* reset sliding window if necessary */\n            if (strm.avail_out == 0) {\n                strm.avail_out = WINSIZE;\n                strm.next_out = window;\n            }\n\n            /* inflate until out of input, output, or at end of block --\n               update the total input and output counters */\n            totin += strm.avail_in;\n            totout += strm.avail_out;\n            ret = inflate(&strm, Z_BLOCK);      /* return at end of block */\n            totin -= strm.avail_in;\n            totout -= strm.avail_out;\n            if (ret == Z_NEED_DICT)\n                ret = Z_DATA_ERROR;\n            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n                goto deflate_index_build_error;\n            if (ret == Z_STREAM_END) {\n                if (gzip &&\n                    (strm.avail_in || ungetc(getc(in), in) != EOF)) {\n                    ret = inflateReset(&strm);\n                    if (ret != Z_OK)\n                        goto deflate_index_build_error;\n                    continue;\n                }\n                break;\n            }\n\n            /* if at end of block, consider adding an index entry (note that if\n               data_type indicates an end-of-block, then all of the\n               uncompressed data from that block has been delivered, and none\n               of the compressed data after that block has been consumed,\n               except for up to seven bits) -- the totout == 0 provides an\n               entry point after the zlib or gzip header, and assures that the\n               index always has at least one access point; we avoid creating an\n               access point after the last block by checking bit 6 of data_type\n             */\n            if ((strm.data_type & 128) && !(strm.data_type & 64) &&\n                (totout == 0 || totout - last > span)) {\n                index = addpoint(index, strm.data_type & 7, totin,\n                                 totout, strm.avail_out, window);\n                if (index == NULL) {\n                    ret = Z_MEM_ERROR;\n                    goto deflate_index_build_error;\n                }\n                last = totout;\n            }\n        } while (strm.avail_in != 0);\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return index (release unused entries in list) */\n    (void)inflateEnd(&strm);\n    index->list = realloc(index->list, sizeof(struct point) * index->have);\n    index->gzip = gzip;\n    index->length = totout;\n    *built = index;\n    return index->have;\n\n    /* return error */\n  deflate_index_build_error:\n    (void)inflateEnd(&strm);\n    deflate_index_free(index);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zran.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zran.c"
   ]
  }
 ],
 "328409e076c4345dc98e11fa8019addbbb0e5f874d0e38c44cf012805cb79df5": [
  "int deflate_index_extract(FILE *in, struct deflate_index *index, off_t offset,\n                          unsigned char *buf, int len)\n{\n    int ret, skip;\n    z_stream strm;\n    struct point *here;\n    unsigned char input[CHUNK];\n    unsigned char discard[WINSIZE];\n\n    /* proceed only if something reasonable to do */\n    if (len < 0)\n        return 0;\n\n    /* find where in stream to start */\n    here = index->list;\n    ret = index->have;\n    while (--ret && here[1].out <= offset)\n        here++;\n\n    /* initialize file and inflate state to start there */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, -15);         /* raw inflate */\n    if (ret != Z_OK)\n        return ret;\n    ret = fseeko(in, here->in - (here->bits ? 1 : 0), SEEK_SET);\n    if (ret == -1)\n        goto deflate_index_extract_ret;\n    if (here->bits) {\n        ret = getc(in);\n        if (ret == -1) {\n            ret = ferror(in) ? Z_ERRNO : Z_DATA_ERROR;\n            goto deflate_index_extract_ret;\n        }\n        (void)inflatePrime(&strm, here->bits, ret >> (8 - here->bits));\n    }\n    (void)inflateSetDictionary(&strm, here->window, WINSIZE);\n\n    /* skip uncompressed bytes until offset reached, then satisfy request */\n    offset -= here->out;\n    strm.avail_in = 0;\n    skip = 1;                               /* while skipping to offset */\n    do {\n        /* define where to put uncompressed data, and how much */\n        if (offset > WINSIZE) {             /* skip WINSIZE bytes */\n            strm.avail_out = WINSIZE;\n            strm.next_out = discard;\n            offset -= WINSIZE;\n        }\n        else if (offset > 0) {              /* last skip */\n            strm.avail_out = (unsigned)offset;\n            strm.next_out = discard;\n            offset = 0;\n        }\n        else if (skip) {                    /* at offset now */\n            strm.avail_out = len;\n            strm.next_out = buf;\n            skip = 0;                       /* only do this once */\n        }\n\n        /* uncompress until avail_out filled, or end of stream */\n        do {\n            if (strm.avail_in == 0) {\n                strm.avail_in = fread(input, 1, CHUNK, in);\n                if (ferror(in)) {\n                    ret = Z_ERRNO;\n                    goto deflate_index_extract_ret;\n                }\n                if (strm.avail_in == 0) {\n                    ret = Z_DATA_ERROR;\n                    goto deflate_index_extract_ret;\n                }\n                strm.next_in = input;\n            }\n            ret = inflate(&strm, Z_NO_FLUSH);       /* normal inflate */\n            if (ret == Z_NEED_DICT)\n                ret = Z_DATA_ERROR;\n            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n                goto deflate_index_extract_ret;\n            if (ret == Z_STREAM_END) {\n                /* the raw deflate stream has ended */\n                if (index->gzip == 0)\n                    /* this is a zlib stream that has ended -- done */\n                    break;\n\n                /* near the end of a gzip member, which might be followed by\n                   another gzip member -- skip the gzip trailer and see if\n                   there is more input after it */\n                if (strm.avail_in < 8) {\n                    fseeko(in, 8 - strm.avail_in, SEEK_CUR);\n                    strm.avail_in = 0;\n                }\n                else {\n                    strm.avail_in -= 8;\n                    strm.next_in += 8;\n                }\n                if (strm.avail_in == 0 && ungetc(getc(in), in) == EOF)\n                    /* the input ended after the gzip trailer -- done */\n                    break;\n\n                /* there is more input, so another gzip member should follow --\n                   validate and skip the gzip header */\n                ret = inflateReset2(&strm, 31);\n                if (ret != Z_OK)\n                    goto deflate_index_extract_ret;\n                do {\n                    if (strm.avail_in == 0) {\n                        strm.avail_in = fread(input, 1, CHUNK, in);\n                        if (ferror(in)) {\n                            ret = Z_ERRNO;\n                            goto deflate_index_extract_ret;\n                        }\n                        if (strm.avail_in == 0) {\n                            ret = Z_DATA_ERROR;\n                            goto deflate_index_extract_ret;\n                        }\n                        strm.next_in = input;\n                    }\n                    ret = inflate(&strm, Z_BLOCK);\n                    if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n                        goto deflate_index_extract_ret;\n                } while ((strm.data_type & 128) == 0);\n\n                /* set up to continue decompression of the raw deflate stream\n                   that follows the gzip header */\n                ret = inflateReset2(&strm, -15);\n                if (ret != Z_OK)\n                    goto deflate_index_extract_ret;\n            }\n\n            /* continue to process the available input before reading more */\n        } while (strm.avail_out != 0);\n\n        if (ret == Z_STREAM_END)\n            /* reached the end of the compressed data -- return the data that\n               was available, possibly less than requested */\n            break;\n\n        /* do until offset reached and requested data read */\n    } while (skip);\n\n    /* compute the number of uncompressed bytes read after the offset */\n    ret = skip ? 0 : len - strm.avail_out;\n\n    /* clean up and return the bytes read, or the negative error */\n  deflate_index_extract_ret:\n    (void)inflateEnd(&strm);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zran.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zran.c"
   ]
  }
 ],
 "ee4f4abc7ef027401b45c1c12ba8e02af3d9567c4a1f9bb5dde8486088e5d0e3": [
  "int main(int argc, char **argv)\n{\n    int len;\n    off_t offset = -1;\n    FILE *in;\n    struct deflate_index *index = NULL;\n    unsigned char buf[LEN];\n\n    /* open input file */\n    if (argc < 2 || argc > 3) {\n        fprintf(stderr, \"usage: zran file.gz [offset]\\n\");\n        return 1;\n    }\n    in = fopen(argv[1], \"rb\");\n    if (in == NULL) {\n        fprintf(stderr, \"zran: could not open %s for reading\\n\", argv[1]);\n        return 1;\n    }\n\n    /* get optional offset */\n    if (argc == 3) {\n        char *end;\n        offset = strtoll(argv[2], &end, 10);\n        if (*end || offset < 0) {\n            fprintf(stderr, \"zran: %s is not a valid offset\\n\", argv[2]);\n            return 1;\n        }\n    }\n\n    /* build index */\n    len = deflate_index_build(in, SPAN, &index);\n    if (len < 0) {\n        fclose(in);\n        switch (len) {\n        case Z_MEM_ERROR:\n            fprintf(stderr, \"zran: out of memory\\n\");\n            break;\n        case Z_DATA_ERROR:\n            fprintf(stderr, \"zran: compressed data error in %s\\n\", argv[1]);\n            break;\n        case Z_ERRNO:\n            fprintf(stderr, \"zran: read error on %s\\n\", argv[1]);\n            break;\n        default:\n            fprintf(stderr, \"zran: error %d while building index\\n\", len);\n        }\n        return 1;\n    }\n    fprintf(stderr, \"zran: built index with %d access points\\n\", len);\n\n    /* use index by reading some bytes from an arbitrary offset */\n    if (offset == -1)\n        offset = (index->length << 1) / 3;\n    len = deflate_index_extract(in, index, offset, buf, LEN);\n    if (len < 0)\n        fprintf(stderr, \"zran: extraction failed: %s error\\n\",\n                len == Z_MEM_ERROR ? \"out of memory\" : \"input corrupted\");\n    else {\n        fwrite(buf, 1, len, stdout);\n        fprintf(stderr, \"zran: extracted %d bytes at %llu\\n\", len, offset);\n    }\n\n    /* clean up and exit */\n    deflate_index_free(index);\n    fclose(in);\n    return 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/zran.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/zran.c"
   ]
  }
 ],
 "3eacf77801939039734d9a98538c85c18d5c5d7ab06d6e845c95d5cd9dc40158": [
  "local int log_recover(struct log *log, int op)\n{\n    int fd, ret = 0;\n    unsigned char *data = NULL;\n    size_t len = 0;\n    struct stat st;\n\n    /* log recovery */\n    log_log(log, op, \"start\");\n\n    /* load foo.add file if expected and present */\n    if (op == APPEND_OP || op == COMPRESS_OP) {\n        strcpy(log->end, \".add\");\n        if (stat(log->path, &st) == 0 && st.st_size) {\n            len = (size_t)(st.st_size);\n            if ((off_t)len != st.st_size ||\n                    (data = malloc(st.st_size)) == NULL) {\n                log_log(log, op, \"allocation failure\");\n                return -2;\n            }\n            if ((fd = open(log->path, O_RDONLY, 0)) < 0) {\n                free(data);\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            ret = (size_t)read(fd, data, len) != len;\n            close(fd);\n            if (ret) {\n                free(data);\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            log_log(log, op, \"loaded .add file\");\n        }\n        else\n            log_log(log, op, \"missing .add file!\");\n    }\n\n    /* recover the interrupted operation */\n    switch (op) {\n    case APPEND_OP:\n        ret = log_append(log, data, len);\n        break;\n    case COMPRESS_OP:\n        ret = log_compress(log, data, len);\n        break;\n    case REPLACE_OP:\n        ret = log_replace(log);\n    }\n\n    /* log status */\n    log_log(log, op, ret ? \"failure\" : \"complete\");\n\n    /* clean up */\n    if (data != NULL)\n        free(data);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzlog.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzlog.c"
   ]
  }
 ],
 "0b54631721cab3bf58838f12b9ee1bcc587b84b2a1d48b1c371d84a83ac98622": [
  "local char *aprintf(char *fmt, ...) {\n    // Get the length of the result of the printf.\n    va_list args;\n    va_start(args, fmt);\n    int len = vsnprintf(NULL, 0, fmt, args);\n    va_end(args);\n    if (len < 0)\n        return NULL;\n\n    // Allocate the required space and printf to it.\n    char *str = malloc(len + 1);\n    if (str == NULL)\n        return NULL;\n    va_start(args, fmt);\n    vsnprintf(str, len + 1, fmt, args);\n    va_end(args);\n    return str;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gznorm.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gznorm.c"
   ]
  }
 ],
 "38df779f908ef03d7a3b282a954d11506f2de950cc1e9c8fa5d7fd01e61f24a9": [
  "local int gzip_normalize(FILE *in, FILE *out, char **err) {\n    // initialize the inflate engine to process a gzip member\n    z_stream strm;\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    if (inflateInit2(&strm, 15 + 16) != Z_OK)\n        BYE(\"out of memory\");\n\n    // State while processing the input gzip stream.\n    enum {              // BETWEEN -> HEAD -> BLOCK -> TAIL -> BETWEEN -> ...\n        BETWEEN,        // between gzip members (must end in this state)\n        HEAD,           // reading a gzip header\n        BLOCK,          // reading deflate blocks\n        TAIL            // reading a gzip trailer\n    } state = BETWEEN;              // current component being processed\n    unsigned long crc = 0;          // accumulated CRC of uncompressed data\n    unsigned long len = 0;          // accumulated length of uncompressed data\n    unsigned long buf = 0;          // deflate stream bit buffer of num bits\n    int num = 0;                    // number of bits in buf (at bottom)\n\n    // Write a canonical gzip header (no mod time, file name, comment, extra\n    // block, or extra flags, and OS is marked as unknown).\n    fwrite(\"\\x1f\\x8b\\x08\\0\\0\\0\\0\\0\\0\\xff\", 1, 10, out);\n\n    // Process the gzip stream from in until reaching the end of the input,\n    // encountering invalid input, or experiencing an i/o error.\n    int more;                       // true if not at the end of the input\n    do {\n        // State inside this loop.\n        unsigned char *put;         // next input buffer location to process\n        int prev;                   // number of bits from previous block in\n                                    // the bit buffer, or -1 if not at the\n                                    // start of a block\n        unsigned long long memb;    // uncompressed length of member\n        size_t tail;                // number of trailer bytes read (0..8)\n        unsigned long part;         // accumulated trailer component\n\n        // Get the next chunk of input from in.\n        unsigned char dat[CHUNK];\n        strm.avail_in = fread(dat, 1, CHUNK, in);\n        if (strm.avail_in == 0)\n            break;\n        more = strm.avail_in == CHUNK;\n        strm.next_in = put = dat;\n\n        // Run that chunk of input through the inflate engine to exhaustion.\n        do {\n            // At this point it is assured that strm.avail_in > 0.\n\n            // Inflate until the end of a gzip component (header, deflate\n            // block, trailer) is reached, or until all of the chunk is\n            // consumed. The resulting decompressed data is discarded, though\n            // the total size of the decompressed data in each member is\n            // tracked, for the calculation of the total CRC.\n            do {\n                // inflate and handle any errors\n                unsigned char scrap[CHUNK];\n                strm.avail_out = CHUNK;\n                strm.next_out = scrap;\n                int ret = inflate(&strm, Z_BLOCK);\n                if (ret == Z_MEM_ERROR)\n                    BYE(\"out of memory\");\n                if (ret == Z_DATA_ERROR)\n                    BYE(\"input invalid: %s\", strm.msg);\n                if (ret != Z_OK && ret != Z_BUF_ERROR && ret != Z_STREAM_END)\n                    BYE(\"internal error\");\n\n                // Update the number of uncompressed bytes generated in this\n                // member. The actual count (not modulo 2^32) is required to\n                // correctly compute the total CRC.\n                unsigned got = CHUNK - strm.avail_out;\n                memb += got;\n                if (memb < got)\n                    BYE(\"overflow error\");\n\n                // Continue to process this chunk until it is consumed, or\n                // until the end of a component (header, deflate block, or\n                // trailer) is reached.\n            } while (strm.avail_out == 0 && (strm.data_type & 0x80) == 0);\n\n            // Since strm.avail_in was > 0 for the inflate call, some input was\n            // just consumed. It is therefore assured that put < strm.next_in.\n\n            // Disposition the consumed component or part of a component.\n            switch (state) {\n                case BETWEEN:\n                    state = HEAD;\n                    // Fall through to HEAD when some or all of the header is\n                    // processed.\n\n                case HEAD:\n                    // Discard the header.\n                    if (strm.data_type & 0x80) {\n                        // End of header reached -- deflate blocks follow.\n                        put = strm.next_in;\n                        prev = num;\n                        memb = 0;\n                        state = BLOCK;\n                    }\n                    break;\n\n                case BLOCK:\n                    // Copy the deflate stream to the output, but with the\n                    // last-block-bit cleared. Re-synchronize stored block\n                    // headers to the output byte boundaries. The bytes at\n                    // put..strm.next_in-1 is the compressed data that has been\n                    // processed and is ready to be copied to the output.\n\n                    // At this point, it is assured that new compressed data is\n                    // available, i.e., put < strm.next_in. If prev is -1, then\n                    // that compressed data starts in the middle of a deflate\n                    // block. If prev is not -1, then the bits in the bit\n                    // buffer, possibly combined with the bits in *put, contain\n                    // the three-bit header of the new deflate block. In that\n                    // case, prev is the number of bits from the previous block\n                    // that remain in the bit buffer. Since num is the number\n                    // of bits in the bit buffer, we have that num - prev is\n                    // the number of bits from the new block currently in the\n                    // bit buffer.\n\n                    // If strm.data_type & 0xc0 is 0x80, then the last byte of\n                    // the available compressed data includes the last bits of\n                    // the end of a deflate block. In that case, that last byte\n                    // also has strm.data_type & 0x1f bits of the next deflate\n                    // block, in the range 0..7. If strm.data_type & 0xc0 is\n                    // 0xc0, then the last byte of the compressed data is the\n                    // end of the deflate stream, followed by strm.data_type &\n                    // 0x1f pad bits, also in the range 0..7.\n\n                    // Set bits to the number of bits not yet consumed from the\n                    // last byte. If we are at the end of the block, bits is\n                    // either the number of bits in the last byte belonging to\n                    // the next block, or the number of pad bits after the\n                    // final block. In either of those cases, bits is in the\n                    // range 0..7.\n                    ;                   // (required due to C syntax oddity)\n                    int bits = strm.data_type & 0x1f;\n\n                    if (prev != -1) {\n                        // We are at the start of a new block. Clear the last\n                        // block bit, and check for special cases. If it is a\n                        // stored block, then emit the header and pad to the\n                        // next byte boundary. If it is a final, empty fixed\n                        // block, then excise it.\n\n                        // Some or all of the three header bits for this block\n                        // may already be in the bit buffer. Load any remaining\n                        // header bits into the bit buffer.\n                        if (num - prev < 3) {\n                            buf += (unsigned long)*put++ << num;\n                            num += 8;\n                        }\n\n                        // Set last to have a 1 in the position of the last\n                        // block bit in the bit buffer.\n                        unsigned long last = (unsigned long)1 << prev;\n\n                        if (((buf >> prev) & 7) == 3) {\n                            // This is a final fixed block. Load at least ten\n                            // bits from this block, including the header, into\n                            // the bit buffer. We already have at least three,\n                            // so at most one more byte needs to be loaded.\n                            if (num - prev < 10) {\n                                if (put == strm.next_in)\n                                    // Need to go get and process more input.\n                                    // We'll end up back here to finish this.\n                                    break;\n                                buf += (unsigned long)*put++ << num;\n                                num += 8;\n                            }\n                            if (((buf >> prev) & 0x3ff) == 3) {\n                                // That final fixed block is empty. Delete it\n                                // to avoid adding an empty block every time a\n                                // gzip stream is normalized.\n                                num = prev;\n                                buf &= last - 1;    // zero the pad bits\n                            }\n                        }\n                        else if (((buf >> prev) & 6) == 0) {\n                            // This is a stored block. Flush to the next\n                            // byte boundary after the three-bit header.\n                            num = (prev + 10) & ~7;\n                            buf &= last - 1;        // zero the pad bits\n                        }\n\n                        // Clear the last block bit.\n                        buf &= ~last;\n\n                        // Write out complete bytes in the bit buffer.\n                        while (num >= 8) {\n                            putc(buf, out);\n                            buf >>= 8;\n                            num -= 8;\n                        }\n\n                        // If no more bytes left to process, then we have\n                        // consumed the byte that had bits from the next block.\n                        if (put == strm.next_in)\n                            bits = 0;\n                    }\n\n                    // We are done handling the deflate block header. Now copy\n                    // all or almost all of the remaining compressed data that\n                    // has been processed so far. Don't copy one byte at the\n                    // end if it contains bits from the next deflate block or\n                    // pad bits at the end of a deflate block.\n\n                    // mix is 1 if we are at the end of a deflate block, and if\n                    // some of the bits in the last byte follow this block. mix\n                    // is 0 if we are in the middle of a deflate block, if the\n                    // deflate block ended on a byte boundary, or if all of the\n                    // compressed data processed so far has been consumed.\n                    int mix = (strm.data_type & 0x80) && bits;\n\n                    // Copy all of the processed compressed data to the output,\n                    // except for the last byte if it contains bits from the\n                    // next deflate block or pad bits at the end of the deflate\n                    // stream. Copy the data after shifting in num bits from\n                    // buf in front of it, leaving num bits from the end of the\n                    // compressed data in buf when done.\n                    unsigned char *end = strm.next_in - mix;\n                    if (put < end) {\n                        if (num)\n                            // Insert num bits from buf before the data being\n                            // copied.\n                            do {\n                                buf += (unsigned)(*put++) << num;\n                                putc(buf, out);\n                                buf >>= 8;\n                            } while (put < end);\n                        else {\n                            // No shifting needed -- write directly.\n                            fwrite(put, 1, end - put, out);\n                            put = end;\n                        }\n                    }\n\n                    // Process the last processed byte if it wasn't written.\n                    if (mix) {\n                        // Load the last byte into the bit buffer.\n                        buf += (unsigned)(*put++) << num;\n                        num += 8;\n\n                        if (strm.data_type & 0x40) {\n                            // We are at the end of the deflate stream and\n                            // there are bits pad bits. Discard the pad bits\n                            // and write a byte to the output, if available.\n                            // Leave the num bits left over in buf to prepend\n                            // to the next deflate stream.\n                            num -= bits;\n                            if (num >= 8) {\n                                putc(buf, out);\n                                num -= 8;\n                                buf >>= 8;\n                            }\n\n                            // Force the pad bits in the bit buffer to zeros.\n                            buf &= ((unsigned long)1 << num) - 1;\n\n                            // Don't need to set prev here since going to TAIL.\n                        }\n                        else\n                            // At the end of an internal deflate block. Leave\n                            // the last byte in the bit buffer to examine on\n                            // the next entry to BLOCK, when more bits from the\n                            // next block will be available.\n                            prev = num - bits;      // number of bits in buffer\n                                                    // from current block\n                    }\n\n                    // Don't have a byte left over, so we are in the middle of\n                    // a deflate block, or the deflate block ended on a byte\n                    // boundary. Set prev appropriately for the next entry into\n                    // BLOCK.\n                    else if (strm.data_type & 0x80)\n                        // The block ended on a byte boundary, so no header\n                        // bits are in the bit buffer.\n                        prev = num;\n                    else\n                        // In the middle of a deflate block, so no header here.\n                        prev = -1;\n\n                    // Check for the end of the deflate stream.\n                    if ((strm.data_type & 0xc0) == 0xc0) {\n                        // That ends the deflate stream on the input side, the\n                        // pad bits were discarded, and any remaining bits from\n                        // the last block in the stream are saved in the bit\n                        // buffer to prepend to the next stream. Process the\n                        // gzip trailer next.\n                        tail = 0;\n                        part = 0;\n                        state = TAIL;\n                    }\n                    break;\n\n                case TAIL:\n                    // Accumulate available trailer bytes to update the total\n                    // CRC and the total uncompressed length.\n                    do {\n                        part = (part >> 8) + ((unsigned long)(*put++) << 24);\n                        tail++;\n                        if (tail == 4) {\n                            // Update the total CRC.\n                            z_off_t len2 = memb;\n                            if (len2 < 0 || (unsigned long long)len2 != memb)\n                                BYE(\"overflow error\");\n                            crc = crc ? crc32_combine(crc, part, len2) : part;\n                            part = 0;\n                        }\n                        else if (tail == 8) {\n                            // Update the total uncompressed length. (It's ok\n                            // if this sum is done modulo 2^32.)\n                            len += part;\n\n                            // At the end of a member. Set up to inflate an\n                            // immediately following gzip member. (If we made\n                            // it this far, then the trailer was valid.)\n                            if (inflateReset(&strm) != Z_OK)\n                                BYE(\"internal error\");\n                            state = BETWEEN;\n                            break;\n                        }\n                    } while (put < strm.next_in);\n                    break;\n            }\n\n            // Process the input buffer until completely consumed.\n        } while (strm.avail_in > 0);\n\n        // Process input until end of file, invalid input, or i/o error.\n    } while (more);\n\n    // Done with the inflate engine.\n    inflateEnd(&strm);\n\n    // Verify the validity of the input.\n    if (state != BETWEEN)\n        BYE(\"input invalid: incomplete gzip stream\");\n\n    // Write the remaining deflate stream bits, followed by a terminating\n    // deflate fixed block.\n    buf += (unsigned long)3 << num;\n    putc(buf, out);\n    putc(buf >> 8, out);\n    if (num > 6)\n        putc(0, out);\n\n    // Write the gzip trailer, which is the CRC and the uncompressed length\n    // modulo 2^32, both in little-endian order.\n    putc(crc, out);\n    putc(crc >> 8, out);\n    putc(crc >> 16, out);\n    putc(crc >> 24, out);\n    putc(len, out);\n    putc(len >> 8, out);\n    putc(len >> 16, out);\n    putc(len >> 24, out);\n    fflush(out);\n\n    // Check for any i/o errors.\n    if (ferror(in) || ferror(out))\n        BYE(\"i/o error: %s\", strerror(errno));\n\n    // All good!\n    *err = NULL;\n    return 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gznorm.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gznorm.c"
   ]
  }
 ],
 "d9210acf7847177d7b7793dbb5cd8d7901253f7e698e6b7aaedf294398c30f05": [
  "int main(void) {\n    // Avoid end-of-line conversions on evil operating systems.\n    SET_BINARY_MODE(stdin);\n    SET_BINARY_MODE(stdout);\n\n    // Normalize from stdin to stdout, returning 1 on error, 0 if ok.\n    char *err;\n    int ret = gzip_normalize(stdin, stdout, &err);\n    if (ret)\n        fprintf(stderr, \"gznorm error: %s\\n\", err);\n    free(err);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gznorm.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gznorm.c"
   ]
  }
 ],
 "8d6554ba110e3e707f03c2a11299aca546612b6223b04ad76f01aff0bb652a91": [
  "local void rotate(unsigned char *list, unsigned len, unsigned rot)\n{\n    unsigned char tmp;\n    unsigned cycles;\n    unsigned char *start, *last, *to, *from;\n\n    /* normalize rot and handle degenerate cases */\n    if (len < 2) return;\n    if (rot >= len) rot %= len;\n    if (rot == 0) return;\n\n    /* pointer to last entry in list */\n    last = list + (len - 1);\n\n    /* do simple left shift by one */\n    if (rot == 1) {\n        tmp = *list;\n        memmove(list, list + 1, len - 1);\n        *last = tmp;\n        return;\n    }\n\n    /* do simple right shift by one */\n    if (rot == len - 1) {\n        tmp = *last;\n        memmove(list + 1, list, len - 1);\n        *list = tmp;\n        return;\n    }\n\n    /* otherwise do rotate as a set of cycles in place */\n    cycles = gcd(len, rot);             /* number of cycles */\n    do {\n        start = from = list + cycles;   /* start index is arbitrary */\n        tmp = *from;                    /* save entry to be overwritten */\n        for (;;) {\n            to = from;                  /* next step in cycle */\n            from += rot;                /* go right rot positions */\n            if (from > last) from -= len;   /* (pointer better not wrap) */\n            if (from == start) break;   /* all but one shifted */\n            *to = *from;                /* shift left */\n        }\n        *to = tmp;                      /* complete the circle */\n    } while (--cycles);\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "examples/gzappend.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "examples/gzappend.c"
   ]
  }
 ],
 "956cd6e835830616a4b83bd3db2b7d711e3cc9853ac2b6b505f5d42b63a66c76": [
  "static void do_banner()\n{\n    printf(\"MiniZip 1.1, demo of zLib + MiniZip64 package, written by Gilles Vollant\\n\");\n    printf(\"more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\\n\\n\");\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "3452a6a137ca6a1d146827338d99984a5a532c7b42d28a978f53a5ce5a4668d5": [
  "static void do_help()\n{\n    printf(\"Usage : minizip [-o] [-a] [-0 to -9] [-p password] [-j] file.zip [files_to_add]\\n\\n\" \\\n           \"  -o  Overwrite existing file.zip\\n\" \\\n           \"  -a  Append to existing file.zip\\n\" \\\n           \"  -0  Store only\\n\" \\\n           \"  -1  Compress faster\\n\" \\\n           \"  -9  Compress better\\n\\n\" \\\n           \"  -j  exclude path. store only the file name.\\n\\n\");\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "ef3d61b225596979d7b0e055d97ab83b482ee319bbe80ec91842bf977aedc894": [
  "static int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)\n{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = FOPEN_FUNC(filenameinzip,\"rb\");\n\n   unsigned long size_read = 0;\n   unsigned long total_read = 0;\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32_z(calculate_crc,buf,size_read);\n            total_read += size_read;\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\", filenameinzip, calculate_crc);\n    return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "ad7cf26ac97e8332a48731149fca8195051dce2a2c683c59d271e0c1955fdd0a": [
  "static int isLargeFile(const char* filename)\n{\n  int largeFile = 0;\n  ZPOS64_T pos = 0;\n  FILE* pFile = FOPEN_FUNC(filename, \"rb\");\n\n  if(pFile != NULL)\n  {\n    FSEEKO_FUNC(pFile, 0, SEEK_END);\n    pos = (ZPOS64_T)FTELLO_FUNC(pFile);\n\n                printf(\"File : %s is %lld bytes\\n\", filename, pos);\n\n    if(pos >= 0xffffffff)\n     largeFile = 1;\n\n                fclose(pFile);\n  }\n\n return largeFile;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "a47dde724d20529bc424243a8ae5f579de666f9e94598f6007ba2dbd0412ef49": [
  "local int zip64local_putValue (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte)\n{\n    unsigned char buf[8];\n    int n;\n    for (n = 0; n < nbByte; n++)\n    {\n        buf[n] = (unsigned char)(x & 0xff);\n        x >>= 8;\n    }\n    if (x != 0)\n      {     /* data overflow - hack for ZIP64 (X Roche) */\n      for (n = 0; n < nbByte; n++)\n        {\n          buf[n] = 0xff;\n        }\n      }\n\n    if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,(uLong)nbByte)!=(uLong)nbByte)\n        return ZIP_ERRNO;\n    else\n        return ZIP_OK;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "0196b1ced161224e7aa92cb48fc5609ddf80df50b0bf29c36967a4a7ebc8dd67": [
  "local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm)\n{\n    uLong year = (uLong)ptm->tm_year;\n    if (year>=1980)\n        year-=1980;\n    else if (year>=80)\n        year-=80;\n    return\n      (uLong) (((uLong)(ptm->tm_mday) + (32 * (uLong)(ptm->tm_mon+1)) + (512 * year)) << 16) |\n        (((uLong)ptm->tm_sec/2) + (32 * (uLong)ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "c58a074f0dcd8320df9afc523cb0eec5689e0a8da25d09469b976c4678c2369b": [
  "local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)\n{\n  unsigned char* buf;\n  ZPOS64_T uSizeFile;\n  ZPOS64_T uBackRead;\n  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n  ZPOS64_T uPosFound=0;\n\n  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n    return 0;\n\n\n  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n  if (uMaxBack>uSizeFile)\n    uMaxBack = uSizeFile;\n\n  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n  if (buf==NULL)\n    return 0;\n\n  uBackRead = 4;\n  while (uBackRead<uMaxBack)\n  {\n    uLong uReadSize;\n    ZPOS64_T uReadPos ;\n    int i;\n    if (uBackRead+BUFREADCOMMENT>uMaxBack)\n      uBackRead = uMaxBack;\n    else\n      uBackRead+=BUFREADCOMMENT;\n    uReadPos = uSizeFile-uBackRead ;\n\n    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      break;\n\n    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n      break;\n\n    for (i=(int)uReadSize-3; (i--)>0;)\n      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n        ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n      {\n        uPosFound = uReadPos+(unsigned)i;\n        break;\n      }\n\n    if (uPosFound!=0)\n      break;\n  }\n  TRYFREE(buf);\n  return uPosFound;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "99bf500566f28ecfcbbc79b18ed2b764766747eaccdbb9b08c7b76757c83d730": [
  "local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)\n{\n  unsigned char* buf;\n  ZPOS64_T uSizeFile;\n  ZPOS64_T uBackRead;\n  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n  ZPOS64_T uPosFound=0;\n  uLong uL;\n  ZPOS64_T relativeOffset;\n\n  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n    return 0;\n\n  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n  if (uMaxBack>uSizeFile)\n    uMaxBack = uSizeFile;\n\n  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n  if (buf==NULL)\n    return 0;\n\n  uBackRead = 4;\n  while (uBackRead<uMaxBack)\n  {\n    uLong uReadSize;\n    ZPOS64_T uReadPos;\n    int i;\n    if (uBackRead+BUFREADCOMMENT>uMaxBack)\n      uBackRead = uMaxBack;\n    else\n      uBackRead+=BUFREADCOMMENT;\n    uReadPos = uSizeFile-uBackRead ;\n\n    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      break;\n\n    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n      break;\n\n    for (i=(int)uReadSize-3; (i--)>0;)\n    {\n      // Signature \"0x07064b50\" Zip64 end of central directory locater\n      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))\n      {\n        uPosFound = uReadPos+(unsigned)i;\n        break;\n      }\n    }\n\n      if (uPosFound!=0)\n        break;\n  }\n\n  TRYFREE(buf);\n  if (uPosFound == 0)\n    return 0;\n\n  /* Zip64 end of central directory locator */\n  if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)\n    return 0;\n\n  /* the signature, already checked */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n\n  /* number of the disk with the start of the zip64 end of  central directory */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n  if (uL != 0)\n    return 0;\n\n  /* relative offset of the zip64 end of central directory record */\n  if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)\n    return 0;\n\n  /* total number of disks */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n  if (uL != 1)\n    return 0;\n\n  /* Goto Zip64 end of central directory record */\n  if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)\n    return 0;\n\n  /* the signature */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n\n  if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'\n    return 0;\n\n  return relativeOffset;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "25ef8e75741e0f9c1c1470e3082611457b2767772a1aa1962d268e4c5ba4c88d": [
  "local int LoadCentralDirectoryRecord(zip64_internal* pziinit)\n{\n  int err=ZIP_OK;\n  ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n\n  ZPOS64_T size_central_dir;     /* size of the central directory  */\n  ZPOS64_T offset_central_dir;   /* offset of start of central directory */\n  ZPOS64_T central_pos;\n  uLong uL;\n\n  uLong number_disk;          /* number of the current dist, used for\n                              spaning ZIP, unsupported, always 0*/\n  uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                              for spaning ZIP, unsupported, always 0*/\n  ZPOS64_T number_entry;\n  ZPOS64_T number_entry_CD;      /* total number of entries in\n                                the central dir\n                                (same than number_entry on nospan) */\n  uLong VersionMadeBy;\n  uLong VersionNeeded;\n  uLong size_comment;\n\n  int hasZIP64Record = 0;\n\n  // check first if we find a ZIP64 record\n  central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);\n  if(central_pos > 0)\n  {\n    hasZIP64Record = 1;\n  }\n  else if(central_pos == 0)\n  {\n    central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);\n  }\n\n/* disable to allow appending to empty ZIP archive\n        if (central_pos==0)\n            err=ZIP_ERRNO;\n*/\n\n  if(hasZIP64Record)\n  {\n    ZPOS64_T sizeEndOfCentralDirectory;\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* size of zip64 end of central directory record */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version made by */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version needed to extract */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory on this disk */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* offset of start of central directory with respect to the\n    starting disk number */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    // TODO..\n    // read the comment from the standard central header.\n    size_comment = 0;\n  }\n  else\n  {\n    // Read End of central Directory info\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central dir on this disk */\n    number_entry = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      number_entry = uL;\n\n    /* total number of entries in the central dir */\n    number_entry_CD = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      number_entry_CD = uL;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    size_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      size_central_dir = uL;\n\n    /* offset of start of central directory with respect to the starting disk number */\n    offset_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      offset_central_dir = uL;\n\n\n    /* zipfile global comment length */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)\n      err=ZIP_ERRNO;\n  }\n\n  if ((central_pos<offset_central_dir+size_central_dir) &&\n    (err==ZIP_OK))\n    err=ZIP_BADZIPFILE;\n\n  if (err!=ZIP_OK)\n  {\n    ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);\n    return ZIP_ERRNO;\n  }\n\n  if (size_comment>0)\n  {\n    pziinit->globalcomment = (char*)ALLOC(size_comment+1);\n    if (pziinit->globalcomment)\n    {\n      size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);\n      pziinit->globalcomment[size_comment]=0;\n    }\n  }\n\n  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);\n  pziinit->add_position_when_writing_offset = byte_before_the_zipfile;\n\n  {\n    ZPOS64_T size_central_dir_to_read = size_central_dir;\n    size_t buf_size = SIZEDATA_INDATABLOCK;\n    void* buf_read = (void*)ALLOC(buf_size);\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    while ((size_central_dir_to_read>0) && (err==ZIP_OK))\n    {\n      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;\n      if (read_this > size_central_dir_to_read)\n        read_this = size_central_dir_to_read;\n\n      if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)\n        err=ZIP_ERRNO;\n\n      if (err==ZIP_OK)\n        err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);\n\n      size_central_dir_to_read-=read_this;\n    }\n    TRYFREE(buf_read);\n  }\n  pziinit->begin_pos = byte_before_the_zipfile;\n  pziinit->number_entry = number_entry_CD;\n\n  if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)\n    err=ZIP_ERRNO;\n\n  return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "9db609d1feb507b6960d0e6b86ea7ac7bd963f0c8a6c590ec8ad2bb57ea7978e": [
  "local int Write_LocalFileHeader(zip64_internal* zi, const char* filename, uInt size_extrafield_local, const void* extrafield_local)\n{\n  /* write the local header */\n  int err;\n  uInt size_filename = (uInt)strlen(filename);\n  uInt size_extrafield = size_extrafield_local;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);\n\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);\n\n  // CRC / Compressed size / Uncompressed size will be filled in later and rewritten later\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */\n  }\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);\n\n  if(zi->ci.zip64)\n  {\n    size_extrafield += 20;\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);\n\n  if ((err==ZIP_OK) && (size_filename > 0))\n  {\n    if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)\n      err = ZIP_ERRNO;\n  }\n\n  if ((err==ZIP_OK) && (size_extrafield_local > 0))\n  {\n    if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)\n      err = ZIP_ERRNO;\n  }\n\n\n  if ((err==ZIP_OK) && (zi->ci.zip64))\n  {\n      // write the Zip64 extended info\n      short HeaderID = 1;\n      short DataSize = 16;\n      ZPOS64_T CompressedSize = 0;\n      ZPOS64_T UncompressedSize = 0;\n\n      // Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)\n      zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);\n\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)HeaderID,2);\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)DataSize,2);\n\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);\n  }\n\n  return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "85f48369cf583e6a9fc9045cac346e583d0e28509711ca50208320d618bdd695": [
  "extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_size, uLong crc32)\n{\n    zip64_internal* zi;\n    ZPOS64_T compressed_size;\n    uLong invalidValue = 0xffffffff;\n    unsigned datasize = 0;\n    int err=ZIP_OK;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 0)\n        return ZIP_PARAMERROR;\n    zi->ci.stream.avail_in = 0;\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n                {\n                        while (err==ZIP_OK)\n                        {\n                                uLong uTotalOutBefore;\n                                if (zi->ci.stream.avail_out == 0)\n                                {\n                                        if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n                                                err = ZIP_ERRNO;\n                                        zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n                                        zi->ci.stream.next_out = zi->ci.buffered_data;\n                                }\n                                uTotalOutBefore = zi->ci.stream.total_out;\n                                err=deflate(&zi->ci.stream,  Z_FINISH);\n                                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n                        }\n                }\n    else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n#ifdef HAVE_BZIP2\n      err = BZ_FINISH_OK;\n      while (err==BZ_FINISH_OK)\n      {\n        uLong uTotalOutBefore;\n        if (zi->ci.bstream.avail_out == 0)\n        {\n          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n            err = ZIP_ERRNO;\n          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;\n          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;\n        }\n        uTotalOutBefore = zi->ci.bstream.total_out_lo32;\n        err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);\n        if(err == BZ_STREAM_END)\n          err = Z_STREAM_END;\n\n        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);\n      }\n\n      if(err == BZ_FINISH_OK)\n        err = ZIP_OK;\n#endif\n    }\n\n    if (err==Z_STREAM_END)\n        err=ZIP_OK; /* this is normal */\n\n    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))\n                {\n        if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)\n            err = ZIP_ERRNO;\n                }\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n    {\n        int tmp_err = deflateEnd(&zi->ci.stream);\n        if (err == ZIP_OK)\n            err = tmp_err;\n        zi->ci.stream_initialised = 0;\n    }\n#ifdef HAVE_BZIP2\n    else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n      int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);\n                        if (err==ZIP_OK)\n                                err = tmperr;\n                        zi->ci.stream_initialised = 0;\n    }\n#endif\n\n    if (!zi->ci.raw)\n    {\n        crc32 = (uLong)zi->ci.crc32;\n        uncompressed_size = zi->ci.totalUncompressedData;\n    }\n    compressed_size = zi->ci.totalCompressedData;\n\n#    ifndef NOCRYPT\n    compressed_size += zi->ci.crypt_header_size;\n#    endif\n\n    // update Current Item crc and sizes,\n    if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)\n    {\n      /*version Made by*/\n      zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);\n      /*version needed*/\n      zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);\n\n    }\n\n    zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/\n\n\n    if(compressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/\n\n    /// set internal file attributes field\n    if (zi->ci.stream.data_type == Z_ASCII)\n        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);\n\n    if(uncompressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/\n\n    // Add ZIP64 extra info field for uncompressed size\n    if(uncompressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for compressed size\n    if(compressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for relative offset to local file header of current file\n    if(zi->ci.pos_local_header >= 0xffffffff)\n      datasize += 8;\n\n    if(datasize > 0)\n    {\n      char* p = NULL;\n\n      if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)\n      {\n        // we can not write more data to the buffer that we have room for.\n        return ZIP_BADZIPFILE;\n      }\n\n      p = zi->ci.central_header + zi->ci.size_centralheader;\n\n      // Add Extra Information Header for 'ZIP64 information'\n      zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID\n      p += 2;\n      zip64local_putValue_inmemory(p, datasize, 2); // DataSize\n      p += 2;\n\n      if(uncompressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, uncompressed_size, 8);\n        p += 8;\n      }\n\n      if(compressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, compressed_size, 8);\n        p += 8;\n      }\n\n      if(zi->ci.pos_local_header >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);\n        p += 8;\n      }\n\n      // Update how much extra free space we got in the memory buffer\n      // and increase the centralheader size so the new ZIP64 fields are included\n      // ( 4 below is the size of HeaderID and DataSize field )\n      zi->ci.size_centralExtraFree -= datasize + 4;\n      zi->ci.size_centralheader += datasize + 4;\n\n      // Update the extra info size field\n      zi->ci.size_centralExtra += datasize + 4;\n      zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);\n    }\n\n    if (err==ZIP_OK)\n        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);\n\n    free(zi->ci.central_header);\n\n    if (err==ZIP_OK)\n    {\n        // Update the LocalFileHeader with the new values.\n\n        ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n\n        if (err==ZIP_OK)\n            err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */\n\n        if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )\n        {\n          if(zi->ci.pos_zip64extrainfo > 0)\n          {\n            // Update the size in the ZIP64 extended field.\n            if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)\n              err = ZIP_ERRNO;\n\n            if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);\n\n            if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);\n          }\n          else\n              err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal\n        }\n        else\n        {\n          if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);\n\n          if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);\n        }\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n    }\n\n    zi->number_entry ++;\n    zi->in_opened_file_inzip = 0;\n\n    return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "9d3943b6d332a373bcb580866653ee4459c8265069fd020117aff87cc251caf4": [
  "local int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)\n{\n  int err = ZIP_OK;\n  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writing_offset;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);\n\n  /*num disks*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  /*relative offset*/\n    if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);\n\n  /*total disks*/ /* Do not support spawning of disk so always say 1 here*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);\n\n    return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "8b6317368dc3823c4fba5f347caa102d990ab993ef4530abb0938d01b6a9462b": [
  "local int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)\n{\n  int err = ZIP_OK;\n\n  uLong Zip64DataSize = 44;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?\n\n  if (err==ZIP_OK) /* version made by */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* version needed */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);\n  }\n  return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "308a357bd51f10e8fafc021df191cbe55eeb4dcb339129929a6655001e6f0e8e": [
  "local int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)\n{\n  int err = ZIP_OK;\n\n  /*signature*/\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n  {\n    {\n      if(zi->number_entry >= 0xFFFF)\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n      else\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n    }\n  }\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n  {\n    if(zi->number_entry >= 0xFFFF)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n  }\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    if(pos >= 0xffffffff)\n    {\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);\n    }\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writing_offset),4);\n  }\n\n   return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "90b3eaf83740b6a87987feeb9bf9f7f3b40e8c4f54f3d459a449e76f9fe8a1a5": [
  "local int Write_GlobalComment(zip64_internal* zi, const char* global_comment)\n{\n  int err = ZIP_OK;\n  uInt size_global_comment = 0;\n\n  if(global_comment != NULL)\n    size_global_comment = (uInt)strlen(global_comment);\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);\n\n  if (err == ZIP_OK && size_global_comment > 0)\n  {\n    if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)\n      err = ZIP_ERRNO;\n  }\n  return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "0d9747dc01b93b4c4e920d01acad4f1ce738aa7f46cead8f93f5601e87c5e9f3": [
  "extern int ZEXPORT zipRemoveExtraInfoBlock (char* pData, int* dataLen, short sHeader)\n{\n  char* p = pData;\n  int size = 0;\n  char* pNewHeader;\n  char* pTmp;\n  short header;\n  short dataSize;\n\n  int retVal = ZIP_OK;\n\n  if(pData == NULL || *dataLen < 4)\n    return ZIP_PARAMERROR;\n\n  pNewHeader = (char*)ALLOC((unsigned)*dataLen);\n  pTmp = pNewHeader;\n\n  while(p < (pData + *dataLen))\n  {\n    header = *(short*)p;\n    dataSize = *(((short*)p)+1);\n\n    if( header == sHeader ) // Header found.\n    {\n      p += dataSize + 4; // skip it. do not copy to temp buffer\n    }\n    else\n    {\n      // Extra Info block should not be removed, So copy it to the temp buffer.\n      memcpy(pTmp, p, dataSize + 4);\n      p += dataSize + 4;\n      size += dataSize + 4;\n    }\n\n  }\n\n  if(size < *dataLen)\n  {\n    // clean old extra info block.\n    memset(pData,0, *dataLen);\n\n    // copy the new extra info block over the old\n    if(size > 0)\n      memcpy(pData, pNewHeader, size);\n\n    // set the new extra info size\n    *dataLen = size;\n\n    retVal = ZIP_OK;\n  }\n  else\n    retVal = ZIP_ERRNO;\n\n  TRYFREE(pNewHeader);\n\n  return retVal;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "df0a331106ab178110b78b70934ab9075325bc8fc07a49ef7981eaff79643ae8": [
  "static void do_banner()\n{\n    printf(\"MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "243b7bf461753a27263d3a4767fc3258e4e966c96d30e72fcb19f03febc2bbe0": [
  "static void do_help()\n{\n    printf(\"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\\n\\n\" \\\n           \"  -e  Extract without pathname (junk paths)\\n\" \\\n           \"  -x  Extract with pathname\\n\" \\\n           \"  -v  list files\\n\" \\\n           \"  -l  list files\\n\" \\\n           \"  -d  directory to extract into\\n\" \\\n           \"  -o  overwrite files without prompting\\n\" \\\n           \"  -p  extract crypted file using password\\n\\n\");\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "ed92318f24f98a25681fc3d762b2d8b834d1125fbcd23bbe0c462eada64e3306": [
  "static void Display64BitsSize(ZPOS64_T n, int size_char)\n{\n  /* to avoid compatibility problem , we do here the conversion */\n  char number[21];\n  int offset=19;\n  int pos_string = 19;\n  number[20]=0;\n  for (;;) {\n      number[offset]=(char)((n%10)+'0');\n      if (number[offset] != '0')\n          pos_string=offset;\n      n/=10;\n      if (offset==0)\n          break;\n      offset--;\n  }\n  {\n      int size_display_string = 19-pos_string;\n      while (size_char > size_display_string)\n      {\n          size_char--;\n          printf(\" \");\n      }\n  }\n\n  printf(\"%s\",&number[pos_string]);\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/miniunz.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/miniunz.c"
   ]
  }
 ],
 "4b9e52c63eaf8b12a3eae849851505bf3162140926d4b4fcf4770ca5235be6bd": [
  "local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)\n{\n    unsigned char* buf;\n    ZPOS64_T uSizeFile;\n    ZPOS64_T uBackRead;\n    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n    ZPOS64_T uPosFound=0;\n\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n        return 0;\n\n\n    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n    if (uMaxBack>uSizeFile)\n        uMaxBack = uSizeFile;\n\n    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n    if (buf==NULL)\n        return 0;\n\n    uBackRead = 4;\n    while (uBackRead<uMaxBack)\n    {\n        uLong uReadSize;\n        ZPOS64_T uReadPos ;\n        int i;\n        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n            uBackRead = uMaxBack;\n        else\n            uBackRead+=BUFREADCOMMENT;\n        uReadPos = uSizeFile-uBackRead ;\n\n        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            break;\n\n        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n            break;\n\n        for (i=(int)uReadSize-3; (i--)>0;)\n            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n            {\n                uPosFound = uReadPos+(unsigned)i;\n                break;\n            }\n\n        if (uPosFound!=0)\n            break;\n    }\n    TRYFREE(buf);\n    return uPosFound;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "7fd8251a2385ce399605a264f5118b25a96cb0586ba483944e32559d7a867653": [
  "local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                                      voidpf filestream)\n{\n    unsigned char* buf;\n    ZPOS64_T uSizeFile;\n    ZPOS64_T uBackRead;\n    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n    ZPOS64_T uPosFound=0;\n    uLong uL;\n                ZPOS64_T relativeOffset;\n\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n        return 0;\n\n\n    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n    if (uMaxBack>uSizeFile)\n        uMaxBack = uSizeFile;\n\n    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n    if (buf==NULL)\n        return 0;\n\n    uBackRead = 4;\n    while (uBackRead<uMaxBack)\n    {\n        uLong uReadSize;\n        ZPOS64_T uReadPos;\n        int i;\n        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n            uBackRead = uMaxBack;\n        else\n            uBackRead+=BUFREADCOMMENT;\n        uReadPos = uSizeFile-uBackRead ;\n\n        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            break;\n\n        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n            break;\n\n        for (i=(int)uReadSize-3; (i--)>0;)\n            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n                ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))\n            {\n                uPosFound = uReadPos+(unsigned)i;\n                break;\n            }\n\n        if (uPosFound!=0)\n            break;\n    }\n    TRYFREE(buf);\n    if (uPosFound == 0)\n        return 0;\n\n    /* Zip64 end of central directory locator */\n    if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return 0;\n\n    /* the signature, already checked */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n\n    /* number of the disk with the start of the zip64 end of  central directory */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n    if (uL != 0)\n        return 0;\n\n    /* relative offset of the zip64 end of central directory record */\n    if (unz64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=UNZ_OK)\n        return 0;\n\n    /* total number of disks */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n    if (uL != 1)\n        return 0;\n\n    /* Goto end of central directory record */\n    if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return 0;\n\n     /* the signature */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return 0;\n\n    if (uL != 0x06064b50)\n        return 0;\n\n    return relativeOffset;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "0317b48e2f1c911288f98f0a8b883e8c93271df33fbbc84dfa89d0f30897549b": [
  "local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)\n{\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (int)(uDate&0x1f) ;\n    ptm->tm_mon =  (int)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (int)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (int) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (int) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (int) (2*(ulDosDate&0x1f)) ;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "f36ecff7b9d61502dda4685f775b8bffabe9972bf96be0170185ae64aa7737a7": [
  "local int unz64local_GetCurrentFileInfoInternal (unzFile file,\n                                                  unz_file_info64 *pfile_info,\n                                                  unz_file_info64_internal\n                                                  *pfile_info_internal,\n                                                  char *szFileName,\n                                                  uLong fileNameBufferSize,\n                                                  void *extraField,\n                                                  uLong extraFieldBufferSize,\n                                                  char *szComment,\n                                                  uLong commentBufferSize)\n{\n    unz64_s* s;\n    unz_file_info64 file_info;\n    unz_file_info64_internal file_info_internal;\n    int err=UNZ_OK;\n    uLong uMagic;\n    long lSeek=0;\n    uLong uL;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (ZSEEK64(s->z_filefunc, s->filestream,\n              s->pos_in_central_dir+s->byte_before_the_zipfile,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n\n    /* we check the magic */\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x02014b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.compressed_size = uL;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.uncompressed_size = uL;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n                // relative offset of local header\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info_internal.offset_curfile = uL;\n\n    lSeek+=file_info.size_filename;\n    if ((err==UNZ_OK) && (szFileName!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_filename<fileNameBufferSize)\n        {\n            *(szFileName+file_info.size_filename)='\\0';\n            uSizeRead = file_info.size_filename;\n        }\n        else\n            uSizeRead = fileNameBufferSize;\n\n        if ((file_info.size_filename>0) && (fileNameBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek -= uSizeRead;\n    }\n\n    // Read extrafield\n    if ((err==UNZ_OK) && (extraField!=NULL))\n    {\n        ZPOS64_T uSizeRead ;\n        if (file_info.size_file_extra<extraFieldBufferSize)\n            uSizeRead = file_info.size_file_extra;\n        else\n            uSizeRead = extraFieldBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n\n        lSeek += file_info.size_file_extra - (uLong)uSizeRead;\n    }\n    else\n        lSeek += file_info.size_file_extra;\n\n\n    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))\n    {\n                                uLong acc = 0;\n\n        // since lSeek now points to after the extra field we need to move back\n        lSeek -= file_info.size_file_extra;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        while(acc < file_info.size_file_extra)\n        {\n            uLong headerId;\n                                                uLong dataSize;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            /* ZIP64 extra fields */\n            if (headerId == 0x0001)\n            {\n                                                        uLong uL;\n\n                                                                if(file_info.uncompressed_size == MAXU32)\n                                                                {\n                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)\n                                                                                        err=UNZ_ERRNO;\n                                                                }\n\n                                                                if(file_info.compressed_size == MAXU32)\n                                                                {\n                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)\n                                                                                  err=UNZ_ERRNO;\n                                                                }\n\n                                                                if(file_info_internal.offset_curfile == MAXU32)\n                                                                {\n                                                                        /* Relative Header offset */\n                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)\n                                                                                err=UNZ_ERRNO;\n                                                                }\n\n                                                                if(file_info.disk_num_start == MAXU32)\n                                                                {\n                                                                        /* Disk Start Number */\n                                                                        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n                                                                                err=UNZ_ERRNO;\n                                                                }\n\n            }\n            else\n            {\n                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)\n                    err=UNZ_ERRNO;\n            }\n\n            acc += 2 + 2 + dataSize;\n        }\n    }\n\n    if ((err==UNZ_OK) && (szComment!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_file_comment<commentBufferSize)\n        {\n            *(szComment+file_info.size_file_comment)='\\0';\n            uSizeRead = file_info.size_file_comment;\n        }\n        else\n            uSizeRead = commentBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_comment>0) && (commentBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek+=file_info.size_file_comment - uSizeRead;\n    }\n    else\n        lSeek+=file_info.size_file_comment;\n\n\n    if ((err==UNZ_OK) && (pfile_info!=NULL))\n        *pfile_info=file_info;\n\n    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n        *pfile_info_internal=file_info_internal;\n\n    return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "14f749a6efc9dbe3406a81b033586061b693c04312db256a965990be3be10a1c": [
  "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)\n{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if (pfile_in_zip_read_info->read_buffer == NULL)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : (int)iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            /* Detect overflow, because z_stream.total_out is uLong (32 bits) */\n            if (uTotalOutAfter<uTotalOutBefore)\n                uTotalOutAfter += 1LL << 32; /* Add maximum value of uLong + 1 */\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : (int)iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return (int)iRead;\n    return err;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "f99ce8a6fee029d946fe29e6bc1c0fadf3f6645453e9f557cc10ac831552a68e": [
  "ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)\n{\n    if (pfilefunc->zfile_func64.zseek64_file != NULL)\n        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);\n    else\n    {\n        uLong tell_uLong = (uLong)(*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);\n        if ((tell_uLong) == MAXU32)\n            return (ZPOS64_T)-1;\n        else\n            return tell_uLong;\n    }\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "47c5b5839ae3e472165ce54445c9a7362406da27e7875220ec3fac6f4277cc5b": [
  "static voidpf ZCALLBACK fopen_file_func (voidpf opaque, const char* filename, int mode)\n{\n    (void)opaque;\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = fopen(filename, mode_fopen);\n    return file;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "30b12518e9f065348b3da3fdf683f6dc8ab30f6aafd37c2c2a89d7eb9fb49366": [
  "static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)\n{\n    (void)opaque;\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = FOPEN_FUNC((const char*)filename, mode_fopen);\n    return file;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "bc47b5f33d9ea92cb26c5cad124bef4922770a4ef912b2f18a33910684aa5f81": [
  "static uLong ZCALLBACK fread_file_func (voidpf opaque, voidpf stream, void* buf, uLong size)\n{\n    (void)opaque;\n    uLong ret;\n    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "12904986500528c368ca8c8370a37e490e430835cbf5dec7847889a5137e0e45": [
  "static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const void* buf, uLong size)\n{\n    (void)opaque;\n    uLong ret;\n    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "34c0632fdcc6e232fd74f2c66e851d2300d383fcea06b52e48724096efe019d9": [
  "static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)\n{\n    (void)opaque;\n    long ret;\n    ret = ftell((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "1bee61769ae80ebc4c3fbd9fa4141033018e4a3bb8535246631437f8e9e1f245": [
  "static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)\n{\n    (void)opaque;\n    ZPOS64_T ret;\n    ret = (ZPOS64_T)FTELLO_FUNC((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "d6ca05eddba3148d1e82258ba378edc7d86b3cdf551995d0d95866d04997416f": [
  "static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)\n{\n    (void)opaque;\n    int fseek_origin=0;\n    long ret;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n    if (fseek((FILE *)stream, (long)offset, fseek_origin) != 0)\n        ret = -1;\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "d616ef114e7c6272d22421c2546f9054c1edaed64d15566c97abd32da9d66291": [
  "static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)\n{\n    (void)opaque;\n    int fseek_origin=0;\n    long ret;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n\n    if(FSEEKO_FUNC((FILE *)stream, (long)offset, fseek_origin) != 0)\n                        ret = -1;\n\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "1b006bad2a95b975e1ec4a42599032029e470ac87495ce5825d6d94db6f69743": [
  "static int ZCALLBACK fclose_file_func (voidpf opaque, voidpf stream)\n{\n    (void)opaque;\n    int ret;\n    ret = fclose((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "f3ca82a697b68a6fa94cbc23e9b2b7d673d732fa0faf2fb69cb8b912d9219efc": [
  "static int ZCALLBACK ferror_file_func (voidpf opaque, voidpf stream)\n{\n    (void)opaque;\n    int ret;\n    ret = ferror((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "ac5b20265d852ae9a7a05eefdd83ae205408dfd55cd8bd0ec45f6a7663ef50ca": [
  "local void make_crc_table()\n{\n    unsigned i, j, n;\n    z_crc_t p;\n\n    /* initialize the CRC of bytes tables */\n    for (i = 0; i < 256; i++) {\n        p = i;\n        for (j = 0; j < 8; j++)\n            p = p & 1 ? (p >> 1) ^ POLY : p >> 1;\n        crc_table[i] = p;\n#ifdef W\n        crc_big_table[i] = byte_swap(p);\n#endif\n    }\n\n    /* initialize the x^2^n mod p(x) table */\n    p = (z_crc_t)1 << 30;         /* x^1 */\n    x2n_table[0] = p;\n    for (n = 1; n < 32; n++)\n        x2n_table[n] = p = multmodp(p, p);\n\n#ifdef W\n    /* initialize the braiding tables -- needs x2n_table[] */\n    braid(crc_braid_table, crc_braid_big_table, N, W);\n#endif\n\n#ifdef MAKECRCH\n    {\n        /*\n          The crc32.h header file contains tables for both 32-bit and 64-bit\n          z_word_t's, and so requires a 64-bit type be available. In that case,\n          z_word_t must be defined to be 64-bits. This code then also generates\n          and writes out the tables for the case that z_word_t is 32 bits.\n         */\n#if !defined(W) || W != 8\n#  error Need a 64-bit integer type in order to generate crc32.h.\n#endif\n        FILE *out;\n        int k, n;\n        z_crc_t ltl[8][256];\n        z_word_t big[8][256];\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n\n        /* write out little-endian CRC table to crc32.h */\n        fprintf(out,\n            \"/* crc32.h -- tables for rapid CRC calculation\\n\"\n            \" * Generated automatically by crc32.c\\n */\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_table[] = {\\n\"\n            \"    \");\n        write_table(out, crc_table, 256);\n        fprintf(out,\n            \"};\\n\");\n\n        /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"#ifdef W\\n\"\n            \"\\n\"\n            \"#if W == 8\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_big_table[] = {\\n\"\n            \"    \");\n        write_table64(out, crc_big_table, 256);\n        fprintf(out,\n            \"};\\n\");\n\n        /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"#else /* W == 4 */\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_big_table[] = {\\n\"\n            \"    \");\n        write_table32hi(out, crc_big_table, 256);\n        fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"#endif\\n\");\n\n        /* write out braid tables for each value of N */\n        for (n = 1; n <= 6; n++) {\n            fprintf(out,\n            \"\\n\"\n            \"#if N == %d\\n\", n);\n\n            /* compute braid tables for this N and 64-bit word_t */\n            braid(ltl, big, n, 8);\n\n            /* write out braid tables for 64-bit z_word_t to crc32.h */\n            fprintf(out,\n            \"\\n\"\n            \"#if W == 8\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n            for (k = 0; k < 8; k++) {\n                fprintf(out, \"   {\");\n                write_table(out, ltl[k], 256);\n                fprintf(out, \"}%s\", k < 7 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_braid_big_table[][256] = {\\n\");\n            for (k = 0; k < 8; k++) {\n                fprintf(out, \"   {\");\n                write_table64(out, big[k], 256);\n                fprintf(out, \"}%s\", k < 7 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\");\n\n            /* compute braid tables for this N and 32-bit word_t */\n            braid(ltl, big, n, 4);\n\n            /* write out braid tables for 32-bit z_word_t to crc32.h */\n            fprintf(out,\n            \"\\n\"\n            \"#else /* W == 4 */\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n            for (k = 0; k < 4; k++) {\n                fprintf(out, \"   {\");\n                write_table(out, ltl[k], 256);\n                fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_braid_big_table[][256] = {\\n\");\n            for (k = 0; k < 4; k++) {\n                fprintf(out, \"   {\");\n                write_table32hi(out, big[k], 256);\n                fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"#endif\\n\"\n            \"\\n\"\n            \"#endif\\n\");\n        }\n        fprintf(out,\n            \"\\n\"\n            \"#endif\\n\");\n\n        /* write out zeros operator table to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"local const z_crc_t FAR x2n_table[] = {\\n\"\n            \"    \");\n        write_table(out, x2n_table, 32);\n        fprintf(out,\n            \"};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "crc32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "crc32.c"
   ]
  }
 ],
 "d9b8219343149574efb8f520e6b5731caed96d86b696ac64f79ef44fc5ff4eb9": [
  "int main()\n{\n    make_crc_table();\n    return 0;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "crc32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "crc32.c"
   ]
  }
 ],
 "c7aa21cd1dcace9e8b60095e2f7369c1037781de2fe59dfed569f5fb57a8da52": [
  "const z_crc_t FAR * ZEXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n    return (const z_crc_t FAR *)crc_table;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "crc32.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "crc32.c"
   ]
  }
 ],
 "4021a67e755d8d08a73e4c79e48fbded9a20be15bb6b4b30fe62f373fd4a3271": [
  "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)\n{\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memmove(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}",
  {
   "v1.2.12": [
    "2022-03-27 15:47:03",
    "gzwrite.c"
   ],
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "gzwrite.c"
   ]
  }
 ],
 "442e05a450d57d51f032aa607331c7f13f82bc2edb7f4c2a44c124d53e399bae": [
  "static int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)\n{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = FOPEN_FUNC(filenameinzip,\"rb\");\n\n   unsigned long size_read = 0;\n   /* unsigned long total_read = 0; */\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32_z(calculate_crc,buf,size_read);\n            /* total_read += size_read; */\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\", filenameinzip, calculate_crc);\n    return err;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "82548e30e5e3c651997f79f06e062fbafb7a1324cf5d420a7e7b2a8c9136f1b5": [
  "extern int ZEXPORT zipWriteInFileInZip (zipFile file,const void* buf,unsigned int len)\n{\n    zip64_internal* zi;\n    int err=ZIP_OK;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 0)\n        return ZIP_PARAMERROR;\n\n    zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);\n\n#ifdef HAVE_BZIP2\n    if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))\n    {\n      zi->ci.bstream.next_in = (void*)buf;\n      zi->ci.bstream.avail_in = len;\n      err = BZ_RUN_OK;\n\n      while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))\n      {\n        if (zi->ci.bstream.avail_out == 0)\n        {\n          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n            err = ZIP_ERRNO;\n          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;\n          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;\n        }\n\n\n        if(err != BZ_RUN_OK)\n          break;\n\n        if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n        {\n          uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;\n//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;\n          err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);\n\n          zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;\n        }\n      }\n\n      if(err == BZ_RUN_OK)\n        err = ZIP_OK;\n    }\n    else\n#endif\n    {\n      zi->ci.stream.next_in = (Bytef*)buf;\n      zi->ci.stream.avail_in = len;\n\n      while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))\n      {\n          if (zi->ci.stream.avail_out == 0)\n          {\n              if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n                  err = ZIP_ERRNO;\n              zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n              zi->ci.stream.next_out = zi->ci.buffered_data;\n          }\n\n\n          if(err != ZIP_OK)\n              break;\n\n          if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n          {\n              uLong uTotalOutBefore = zi->ci.stream.total_out;\n              err=deflate(&zi->ci.stream,  Z_NO_FLUSH);\n\n              zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n          }\n          else\n          {\n              uInt copy_this,i;\n              if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)\n                  copy_this = zi->ci.stream.avail_in;\n              else\n                  copy_this = zi->ci.stream.avail_out;\n\n              for (i = 0; i < copy_this; i++)\n                  *(((char*)zi->ci.stream.next_out)+i) =\n                      *(((const char*)zi->ci.stream.next_in)+i);\n              {\n                  zi->ci.stream.avail_in -= copy_this;\n                  zi->ci.stream.avail_out-= copy_this;\n                  zi->ci.stream.next_in+= copy_this;\n                  zi->ci.stream.next_out+= copy_this;\n                  zi->ci.stream.total_in+= copy_this;\n                  zi->ci.stream.total_out+= copy_this;\n                  zi->ci.pos_in_buffered_data += copy_this;\n              }\n          }\n      }// while(...)\n    }\n\n    return err;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "ad96aeffb6ee0dd185b04bea7bef07152243d9be1bec92cb584b5af8ca6a32cc": [
  "extern int ZEXPORT zipRemoveExtraInfoBlock (char* pData, int* dataLen, short sHeader)\n{\n  char* p = pData;\n  int size = 0;\n  char* pNewHeader;\n  char* pTmp;\n  short header;\n  short dataSize;\n\n  int retVal = ZIP_OK;\n\n  if(pData == NULL || dataLen == NULL || *dataLen < 4)\n    return ZIP_PARAMERROR;\n\n  pNewHeader = (char*)ALLOC((unsigned)*dataLen);\n  pTmp = pNewHeader;\n\n  while(p < (pData + *dataLen))\n  {\n    header = *(short*)p;\n    dataSize = *(((short*)p)+1);\n\n    if( header == sHeader ) // Header found.\n    {\n      p += dataSize + 4; // skip it. do not copy to temp buffer\n    }\n    else\n    {\n      // Extra Info block should not be removed, So copy it to the temp buffer.\n      memcpy(pTmp, p, dataSize + 4);\n      p += dataSize + 4;\n      size += dataSize + 4;\n    }\n\n  }\n\n  if(size < *dataLen)\n  {\n    // clean old extra info block.\n    memset(pData,0, *dataLen);\n\n    // copy the new extra info block over the old\n    if(size > 0)\n      memcpy(pData, pNewHeader, size);\n\n    // set the new extra info size\n    *dataLen = size;\n\n    retVal = ZIP_OK;\n  }\n  else\n    retVal = ZIP_ERRNO;\n\n  TRYFREE(pNewHeader);\n\n  return retVal;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "7a4508d32b8cac388159e807ffd5e31efb0cc20b7fcc4a2c0ad5e2c835c82275": [
  "extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,\n                                            int* level, int raw, const char* password)\n{\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        TRYFREE(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\n        err=UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info->read_buffer);\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        TRYFREE(pfile_in_zip_read_info->read_buffer);\n        TRYFREE(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "7d508bf1ace6c1e597bd7ac2b99bc66a57d3e1576d2107aebe049c369352a5e2": [
  "static voidpf ZCALLBACK fopen_file_func (voidpf opaque, const char* filename, int mode)\n{\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    (void)opaque;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = fopen(filename, mode_fopen);\n    return file;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "482eef1fe8901a14338ad5fa6015dd1b68d1dd9271d157ec9765e4e74803ce99": [
  "static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)\n{\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    (void)opaque;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = FOPEN_FUNC((const char*)filename, mode_fopen);\n    return file;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "715c31792b0cf9ee224027ff7fd5ef1c04264687a354876b54a5f1f8a25baa00": [
  "static uLong ZCALLBACK fread_file_func (voidpf opaque, voidpf stream, void* buf, uLong size)\n{\n    uLong ret;\n    (void)opaque;\n    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "3a440e47a4152c948631e68a797be93281585ee591b3b725fa775028ae23aa9b": [
  "static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const void* buf, uLong size)\n{\n    uLong ret;\n    (void)opaque;\n    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "4f3191c136a128fb31ba97117964961dbcb077a0326f55655966ad827d0f106f": [
  "static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)\n{\n    long ret;\n    (void)opaque;\n    ret = ftell((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "e46c58714df64e2a083866f3ee6c95866d10508c7001474562bcb021942b9106": [
  "static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)\n{\n    ZPOS64_T ret;\n    (void)opaque;\n    ret = (ZPOS64_T)FTELLO_FUNC((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "a7cf9ef2eb11d21777f704be2d588f9c9994fa88e5eaac9f1ca9f67896bef5a8": [
  "static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)\n{\n    int fseek_origin=0;\n    long ret;\n    (void)opaque;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n    if (fseek((FILE *)stream, (long)offset, fseek_origin) != 0)\n        ret = -1;\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "fa3d7e9b869b2501db0baf915a870098e2ae556b0bc281dbc1373d9bd64e4223": [
  "static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)\n{\n    int fseek_origin=0;\n    long ret;\n    (void)opaque;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n\n    if(FSEEKO_FUNC((FILE *)stream, (z_off_t)offset, fseek_origin) != 0)\n                        ret = -1;\n\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "20f5dc89a3180e0b567d6e67f0f4d9c27d684bf388e196b449d9589586c32f9b": [
  "static int ZCALLBACK fclose_file_func (voidpf opaque, voidpf stream)\n{\n    int ret;\n    (void)opaque;\n    ret = fclose((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "0e09fae68cf212c09638dc226827014f3b39d52bd1c4b17fe0709fee1b118706": [
  "static int ZCALLBACK ferror_file_func (voidpf opaque, voidpf stream)\n{\n    int ret;\n    (void)opaque;\n    ret = ferror((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "343592858a44d257e800ab9e9847a9032810c2cb131088e2b6a55f1e5c5f58c1": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef ZLIB_DEBUG\n    flags += 1 << 8;\n#endif\n    /*\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n     */\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifdef NO_vsnprintf\n    flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#else\n    flags += 1L << 24;\n#  ifdef NO_snprintf\n    flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.13": [
    "2022-10-12 17:54:34",
    "zutil.c"
   ]
  }
 ],
 "d346551c626f047fb6d2a509f4b2ad7c6201ce71ea38e9b16610c304d9939a8d": [
  "int def(FILE *source, FILE *dest, int level)\n{\n    int ret, flush;\n    unsigned have;\n    z_stream strm;\n    char in[CHUNK];\n    char out[CHUNK];\n\n    /* allocate deflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = deflateInit(&strm, level);\n    if (ret != Z_OK)\n        return ret;\n\n    /* compress until end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)deflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n        strm.next_in = in;\n\n        /* run deflate() on input until output buffer not full, finish\n           compression if all of source has been read in */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = deflate(&strm, flush);    /* no bad return value */\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)deflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);     /* all input will be used */\n\n        /* done when last data in file processed */\n    } while (flush != Z_FINISH);\n    assert(ret == Z_STREAM_END);        /* stream will be complete */\n\n    /* clean up and return */\n    (void)deflateEnd(&strm);\n    return Z_OK;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/zpipe.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/zpipe.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zpipe.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zpipe.c"
   ]
  }
 ],
 "641018d58f1933309af00da60d3a91dadbaa82bccc0dce1ecd2661aa87a3333d": [
  "int inf(FILE *source, FILE *dest)\n{\n    int ret;\n    unsigned have;\n    z_stream strm;\n    char in[CHUNK];\n    char out[CHUNK];\n\n    /* allocate inflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);\n    if (ret != Z_OK)\n        return ret;\n\n    /* decompress until deflate stream ends or end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)inflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        if (strm.avail_in == 0)\n            break;\n        strm.next_in = in;\n\n        /* run inflate() on input until output buffer not full */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = inflate(&strm, Z_NO_FLUSH);\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            switch (ret) {\n            case Z_NEED_DICT:\n                ret = Z_DATA_ERROR;     /* and fall through */\n            case Z_DATA_ERROR:\n            case Z_MEM_ERROR:\n                (void)inflateEnd(&strm);\n                return ret;\n            }\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)inflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);     /* all input will be used */\n\n        /* done when inflate() says it's done */\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return */\n    (void)inflateEnd(&strm);\n    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/zpipe.c"
   ]
  }
 ],
 "bdfe7e5dff5e4c7cc11676e5b407e74c2f6e26cac10876ca2e0d73a2428d1056": [
  "int main(int argc, char **argv)\n{\n    int ret;\n\n    /* do compression if no arguments */\n    if (argc == 1) {\n        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* do decompression if -d specified */\n    else if (argc == 2 && strcmp(argv[1], \"-d\") == 0) {\n        ret = inf(stdin, stdout);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* otherwise, report usage */\n    else {\n        fputs(\"zpipe usage: zpipe [-d] < source > dest\\n\", stderr);\n        return 1;\n    }\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/zpipe.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/zpipe.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zpipe.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zpipe.c"
   ]
  }
 ],
 "3084015faf078c3e6f7c2edf62bed41d72e27edc211dbbc722cb263b42b4d56a": [
  "local int partcompress(FILE *in, z_streamp def)\n{\n    int ret, flush;\n    char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        def->avail_in = fread(raw, 1, RAWLEN, in);\n        if (ferror(in))\n            return Z_ERRNO;\n        def->next_in = raw;\n        if (feof(in))\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (def->avail_out != 0 && flush == Z_NO_FLUSH);\n    return ret;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/fitblk.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/fitblk.c"
   ]
  }
 ],
 "78641619913897443916a66a67f12264f778ed60d03d1ad561346f472ccf40bf": [
  "local int recompress(z_streamp inf, z_streamp def)\n{\n    int ret, flush;\n    char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        /* decompress */\n        inf->avail_out = RAWLEN;\n        inf->next_out = raw;\n        ret = inflate(inf, Z_NO_FLUSH);\n        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&\n               ret != Z_NEED_DICT);\n        if (ret == Z_MEM_ERROR)\n            return ret;\n\n        /* compress what was decompresed until done or no room */\n        def->avail_in = RAWLEN - inf->avail_out;\n        def->next_in = raw;\n        if (inf->avail_out != 0)\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (ret != Z_STREAM_END && def->avail_out != 0);\n    return ret;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/fitblk.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/fitblk.c"
   ]
  }
 ],
 "dbde9caf8eecc7afb71fd40930f1c5e29b6bc6f77b09a888e5873a708e4a2db5": [
  "int main(int argc, char **argv)\n{\n    int ret;                /* return code */\n    unsigned size;          /* requested fixed output block size */\n    unsigned have;          /* bytes written by deflate() call */\n    char *blk;              /* intermediate and final stream */\n    char *tmp;              /* close to desired size stream */\n    z_stream def, inf;      /* zlib deflate and inflate states */\n\n    /* get requested output size */\n    if (argc != 2)\n        quit(\"need one argument: size of output block\");\n    ret = strtol(argv[1], argv + 1, 10);\n    if (argv[1][0] != 0)\n        quit(\"argument must be a number\");\n    if (ret < 8)            /* 8 is minimum zlib stream size */\n        quit(\"need positive size of 8 or greater\");\n    size = (unsigned)ret;\n\n    /* allocate memory for buffers and compression engine */\n    blk = malloc(size + EXCESS);\n    def.zalloc = Z_NULL;\n    def.zfree = Z_NULL;\n    def.opaque = Z_NULL;\n    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);\n    if (ret != Z_OK || blk == NULL)\n        quit(\"out of memory\");\n\n    /* compress from stdin until output full, or no more input */\n    def.avail_out = size + EXCESS;\n    def.next_out = blk;\n    ret = partcompress(stdin, &def);\n    if (ret == Z_ERRNO)\n        quit(\"error reading input\");\n\n    /* if it all fit, then size was undersubscribed -- done! */\n    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {\n        /* write block to stdout */\n        have = size + EXCESS - def.avail_out;\n        ret = fwrite(blk, 1, have, stdout);\n        if (ret != have || ferror(stdout))\n            quit(\"error writing output\");\n\n        /* clean up and print results to stderr */\n        ret = deflateEnd(&def);\n        assert(ret != Z_STREAM_ERROR);\n        free(blk);\n        fprintf(stderr,\n                \"%u bytes unused out of %u requested (all input)\\n\",\n                size - have, size);\n        return 0;\n    }\n\n    /* it didn't all fit -- set up for recompression */\n    inf.zalloc = Z_NULL;\n    inf.zfree = Z_NULL;\n    inf.opaque = Z_NULL;\n    inf.avail_in = 0;\n    inf.next_in = Z_NULL;\n    ret = inflateInit(&inf);\n    tmp = malloc(size + EXCESS);\n    if (ret != Z_OK || tmp == NULL)\n        quit(\"out of memory\");\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do first recompression close to the right amount */\n    inf.avail_in = size + EXCESS;\n    inf.next_in = blk;\n    def.avail_out = size + EXCESS;\n    def.next_out = tmp;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n\n    /* set up for next reocmpression */\n    ret = inflateReset(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do second and final recompression (third compression) */\n    inf.avail_in = size - MARGIN;   /* assure stream will complete */\n    inf.next_in = tmp;\n    def.avail_out = size;\n    def.next_out = blk;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */\n\n    /* done -- write block to stdout */\n    have = size - def.avail_out;\n    ret = fwrite(blk, 1, have, stdout);\n    if (ret != have || ferror(stdout))\n        quit(\"error writing output\");\n\n    /* clean up and print results to stderr */\n    free(tmp);\n    ret = inflateEnd(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateEnd(&def);\n    assert(ret != Z_STREAM_ERROR);\n    free(blk);\n    fprintf(stderr,\n            \"%u bytes unused out of %u requested (%lu input)\\n\",\n            size - have, size, def.total_in);\n    return 0;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/fitblk.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/fitblk.c"
   ]
  }
 ],
 "cb7666b2d54713b69531cc76886c8f39222c16b66ccda552f6b390143164b02d": [
  "local int bload(bin *in)\n{\n    ssize_t len;\n\n    if (in == NULL)\n        return -1;\n    if (in->left != 0)\n        return 0;\n    in->next = in->buf;\n    do {\n        len = read(in->fd, in->buf + in->left, CHUNK - in->left);\n        if (len < 0)\n            return -1;\n        in->left += (unsigned)len;\n    } while (len != 0 && in->left < CHUNK);\n    return len == 0 ? 1 : 0;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ]
  }
 ],
 "fa2394ae95aefa48cac6d5ff191e9f99ae042fc37d0e43dac89f8b4712492e56": [
  "local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,\n                  FILE *out)\n{\n    int ret;                /* return value from zlib functions */\n    int pos;                /* where the \"last block\" bit is in byte */\n    int last;               /* true if processing the last block */\n    bin *in;                /* buffered input file */\n    unsigned char *start;   /* start of compressed data in buffer */\n    unsigned char *junk;    /* buffer for uncompressed data -- discarded */\n    z_off_t len;            /* length of uncompressed data (support > 4 GB) */\n    z_stream strm;          /* zlib inflate stream */\n\n    /* open gzip file and skip header */\n    in = bopen(name);\n    if (in == NULL)\n        bail(\"could not open \", name);\n    gzhead(in);\n\n    /* allocate buffer for uncompressed data and initialize raw inflate\n       stream */\n    junk = malloc(CHUNK);\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, -15);\n    if (junk == NULL || ret != Z_OK)\n        bail(\"out of memory\", \"\");\n\n    /* inflate and copy compressed data, clear last-block bit if requested */\n    len = 0;\n    zpull(&strm, in);\n    start = strm.next_in;\n    last = start[0] & 1;\n    if (last && clr)\n        start[0] &= ~1;\n    strm.avail_out = 0;\n    for (;;) {\n        /* if input used and output done, write used input and get more */\n        if (strm.avail_in == 0 && strm.avail_out != 0) {\n            fwrite(start, 1, strm.next_in - start, out);\n            start = in->buf;\n            in->left = 0;\n            zpull(&strm, in);\n        }\n\n        /* decompress -- return early when end-of-block reached */\n        strm.avail_out = CHUNK;\n        strm.next_out = junk;\n        ret = inflate(&strm, Z_BLOCK);\n        switch (ret) {\n        case Z_MEM_ERROR:\n            bail(\"out of memory\", \"\");\n        case Z_DATA_ERROR:\n            bail(\"invalid compressed data in \", in->name);\n        }\n\n        /* update length of uncompressed data */\n        len += CHUNK - strm.avail_out;\n\n        /* check for block boundary (only get this when block copied out) */\n        if (strm.data_type & 128) {\n            /* if that was the last block, then done */\n            if (last)\n                break;\n\n            /* number of unused bits in last byte */\n            pos = strm.data_type & 7;\n\n            /* find the next last-block bit */\n            if (pos != 0) {\n                /* next last-block bit is in last used byte */\n                pos = 0x100 >> pos;\n                last = strm.next_in[-1] & pos;\n                if (last && clr)\n                    strm.next_in[-1] &= ~pos;\n            }\n            else {\n                /* next last-block bit is in next unused byte */\n                if (strm.avail_in == 0) {\n                    /* don't have that byte yet -- get it */\n                    fwrite(start, 1, strm.next_in - start, out);\n                    start = in->buf;\n                    in->left = 0;\n                    zpull(&strm, in);\n                }\n                last = strm.next_in[0] & 1;\n                if (last && clr)\n                    strm.next_in[0] &= ~1;\n            }\n        }\n    }\n\n    /* update buffer with unused input */\n    in->left = strm.avail_in;\n    in->next = strm.next_in;\n\n    /* copy used input, write empty blocks to get to byte boundary */\n    pos = strm.data_type & 7;\n    fwrite(start, 1, in->next - start - 1, out);\n    last = in->next[-1];\n    if (pos == 0 || !clr)\n        /* already at byte boundary, or last file: write last byte */\n        putc(last, out);\n    else {\n        /* append empty blocks to last byte */\n        last &= ((0x100 >> pos) - 1);       /* assure unused bits are zero */\n        if (pos & 1) {\n            /* odd -- append an empty stored block */\n            putc(last, out);\n            if (pos == 1)\n                putc(0, out);               /* two more bits in block header */\n            fwrite(\"\\0\\0\\xff\\xff\", 1, 4, out);\n        }\n        else {\n            /* even -- append 1, 2, or 3 empty fixed blocks */\n            switch (pos) {\n            case 6:\n                putc(last | 8, out);\n                last = 0;\n            case 4:\n                putc(last | 0x20, out);\n                last = 0;\n            case 2:\n                putc(last | 0x80, out);\n                putc(0, out);\n            }\n        }\n    }\n\n    /* update crc and tot */\n    *crc = crc32_combine(*crc, bget4(in), len);\n    *tot += (unsigned long)len;\n\n    /* clean up */\n    inflateEnd(&strm);\n    free(junk);\n    bclose(in);\n\n    /* write trailer if this is the last gzip file */\n    if (!clr) {\n        put4(*crc, out);\n        put4(*tot, out);\n    }\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzjoin.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzjoin.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzjoin.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzjoin.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzjoin.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzjoin.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzjoin.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzjoin.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzjoin.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzjoin.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzjoin.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzjoin.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzjoin.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzjoin.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzjoin.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzjoin.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzjoin.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzjoin.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzjoin.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzjoin.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzjoin.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzjoin.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzjoin.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzjoin.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzjoin.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzjoin.c"
   ]
  }
 ],
 "a42d000294f255cadd7091999e15ef9b2c09709b730f8d82095c1bf897384c56": [
  "local int lock(int fd)\n{\n    int patience;\n\n    /* try to lock every LOCK_RETRY seconds for LOCK_PATIENCE seconds */\n    patience = LOCK_PATIENCE;\n    do {\n        if (flock(fd, LOCK_EX + LOCK_NB) == 0)\n            return 0;\n        (void)sleep(LOCK_RETRY);\n        patience -= LOCK_RETRY;\n    } while (patience > 0);\n\n    /* we've run out of patience -- give up */\n    return -1;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "678bbb1ba59c67ee823c19fca4377fd7b579b655f4e429718df8f589999ebca3": [
  "local void unlock(int fd)\n{\n    (void)flock(fd, LOCK_UN);\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "b1b87532bb74278da98f2b58ae9a51ef48682edf67251baa018ca5221d40b432": [
  "local void log_clean(gz_log *log)\n{\n    unlock(log->fd);\n    (void)close(log->fd);\n    free(log);\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "b092e80eb8f9ebfe000274792ac54bd2fb861fcb22ab6c4fb6a1d7a9e44e5dfa": [
  "long make_ulg(unsigned char *buf)\n{\n    int n;\n    unsigned long val;\n\n    val = (unsigned long)(*buf++);\n    for (n = 8; n < 32; n += 8)\n        val += (unsigned long)(*buf++) << n;\n    return val;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "c7dc443c4faece49b06c87bdd6bb9be87e89010e645ffb0ae780c40fd2f08a4c": [
  "local off_t make_off(unsigned char *buf)\n{\n    int n;\n    off_t val;\n\n    val = (off_t)(*buf++);\n    for (n = 8; n < 64; n += 8)\n        val += (off_t)(*buf++) << n;\n    return val;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "b188a4e6ed7fb32510b9908339f95823f3f98cb96e5fb4933efa5eeef71a6a96": [
  "local void dice_ulg(unsigned long val, unsigned char *buf)\n{\n    int n;\n\n    for (n = 0; n < 4; n++) {\n        *buf++ = val & 0xff;\n        val >>= 8;\n    }\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "3adf8b9f8884c2aec1f5412e152cfe3f0b0f59e7fb94d7d4d78c2a56df2c6ca0": [
  "local void dice_off(off_t val, unsigned char *buf)\n{\n    int n;\n\n    for (n = 0; n < 8; n++) {\n        *buf++ = val & 0xff;\n        val >>= 8;\n    }\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "8041d72d64dcdf2067e097d82e557b8c7c00d049d752cd3b7fd899d6d199c4eb": [
  "void *gzlog_open(char *path)\n{\n    unsigned xlen;\n    unsigned char temp[20];\n    unsigned sub_len;\n    int good;\n    gz_log *log;\n\n    /* allocate log structure */\n    log = malloc(sizeof(gz_log));\n    if (log == NULL)\n        return NULL;\n    log->id = GZLOGID;\n\n    /* open file, creating it if necessary, and locking it */\n    log->fd = open(path, O_RDWR | O_CREAT, 0600);\n    if (log->fd < 0) {\n        free(log);\n        return NULL;\n    }\n    if (lock(log->fd)) {\n        close(log->fd);\n        free(log);\n        return NULL;\n    }\n\n    /* if file is empty, write new gzip stream */\n    if (lseek(log->fd, 0, SEEK_END) == 0) {\n        if (write(log->fd, empty_gz, sizeof(empty_gz)) != sizeof(empty_gz)) {\n            log_clean(log);\n            return NULL;\n        }\n    }\n\n    /* check gzip header */\n    (void)lseek(log->fd, 0, SEEK_SET);\n    if (read(log->fd, temp, 12) != 12 || temp[0] != 0x1f ||\n        temp[1] != 0x8b || temp[2] != 8 || (temp[3] & 4) == 0) {\n        log_clean(log);\n        return NULL;\n    }\n\n    /* process extra field to find \"ap\" sub-field */\n    xlen = temp[10] + (temp[11] << 8);\n    good = 0;\n    while (xlen) {\n        if (xlen < 4 || read(log->fd, temp, 4) != 4)\n            break;\n        sub_len = temp[2];\n        sub_len += temp[3] << 8;\n        xlen -= 4;\n        if (memcmp(temp, \"ap\", 2) == 0 && sub_len == 16) {\n            good = 1;\n            break;\n        }\n        if (xlen < sub_len)\n            break;\n        (void)lseek(log->fd, sub_len, SEEK_CUR);\n        xlen -= sub_len;\n    }\n    if (!good) {\n        log_clean(log);\n        return NULL;\n    }\n\n    /* read in \"ap\" sub-field */\n    log->extra = lseek(log->fd, 0, SEEK_CUR);\n    if (read(log->fd, temp, 16) != 16) {\n        log_clean(log);\n        return NULL;\n    }\n    log->mark_off = make_off(temp);\n    log->last_off = make_off(temp + 8);\n\n    /* get crc, length of gzip file */\n    (void)lseek(log->fd, log->last_off, SEEK_SET);\n    if (read(log->fd, temp, 13) != 13 ||\n        memcmp(temp, \"\\001\\000\\000\\377\\377\", 5) != 0) {\n        log_clean(log);\n        return NULL;\n    }\n    log->crc = make_ulg(temp + 5);\n    log->len = make_ulg(temp + 9);\n\n    /* set up to write over empty last block */\n    (void)lseek(log->fd, log->last_off + 5, SEEK_SET);\n    log->stored = 0;\n    return (void *)log;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "514704fccb96f10b26adc17cfe6865d1d446c49a651388d859ce7641c5acc3ca": [
  "int gzlog_write(void *obj, char *data, size_t len)\n{\n    size_t some;\n    unsigned char temp[5];\n    gz_log *log;\n\n    /* check object */\n    log = (gz_log *)obj;\n    if (log == NULL || log->id != GZLOGID)\n        return 1;\n\n    /* write stored blocks until all of the input is written */\n    do {\n        some = MAX_BLOCK - log->stored;\n        if (some > len)\n            some = len;\n        if (write(log->fd, data, some) != some)\n            return 1;\n        log->crc = crc32(log->crc, data, some);\n        log->len += some;\n        len -= some;\n        data += some;\n        log->stored += some;\n\n        /* if the stored block is full, end it and start another */\n        if (log->stored == MAX_BLOCK) {\n            (void)lseek(log->fd, log->last_off, SEEK_SET);\n            temp[0] = 0;\n            dice_ulg(log->stored + ((unsigned long)(~log->stored) << 16),\n                     temp + 1);\n            if (write(log->fd, temp, 5) != 5)\n                return 1;\n            log->last_off = lseek(log->fd, log->stored, SEEK_CUR);\n            (void)lseek(log->fd, 5, SEEK_CUR);\n            log->stored = 0;\n        }\n    } while (len);\n    return 0;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ]
  }
 ],
 "0a3f78084e76351baf261c874b0b73c99df1eff890ce02b84da2b8aa065eb43f": [
  "local int recomp(gz_log *log)\n{\n    z_stream strm;\n    size_t len, max;\n    unsigned char *in;\n    unsigned char *out;\n    unsigned char temp[16];\n\n    /* allocate space and read it all in (it's around 1 MB) */\n    len = log->last_off - log->mark_off;\n    max = len + (len >> 12) + (len >> 14) + 11;\n    out = malloc(max);\n    if (out == NULL)\n        return 1;\n    in = malloc(len);\n    if (in == NULL) {\n        free(out);\n        return 1;\n    }\n    (void)lseek(log->fd, log->mark_off, SEEK_SET);\n    if (read(log->fd, in, len) != len) {\n        free(in);\n        free(out);\n        return 1;\n    }\n\n    /* recompress in memory, decoding stored data as we go */\n    /* note: this assumes that unsigned is four bytes or more */\n    /*       consider not making that assumption */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    if (deflateInit2(&strm, Z_BEST_COMPRESSION, Z_DEFLATED, -15, 8,\n        Z_DEFAULT_STRATEGY) != Z_OK) {\n        free(in);\n        free(out);\n        return 1;\n    }\n    strm.next_in = in;\n    strm.avail_out = max;\n    strm.next_out = out;\n    while (len >= 5) {\n        if (strm.next_in[0] != 0)\n            break;\n        strm.avail_in = strm.next_in[1] + (strm.next_in[2] << 8);\n        strm.next_in += 5;\n        len -= 5;\n        if (strm.avail_in != 0) {\n            if (len < strm.avail_in)\n                break;\n            len -= strm.avail_in;\n            (void)deflate(&strm, Z_NO_FLUSH);\n            if (strm.avail_in != 0 || strm.avail_out == 0)\n                break;\n        }\n    }\n    (void)deflate(&strm, Z_SYNC_FLUSH);\n    (void)deflateEnd(&strm);\n    free(in);\n    if (len != 0 || strm.avail_out == 0) {\n        free(out);\n        return 1;\n    }\n\n    /* overwrite stored data with compressed data */\n    (void)lseek(log->fd, log->mark_off, SEEK_SET);\n    len = max - strm.avail_out;\n    if (write(log->fd, out, len) != len) {\n        free(out);\n        return 1;\n    }\n    free(out);\n\n    /* write last empty block, crc, and length */\n    log->mark_off = log->last_off = lseek(log->fd, 0, SEEK_CUR);\n    temp[0] = 1;\n    dice_ulg(0xffffL << 16, temp + 1);\n    dice_ulg(log->crc, temp + 5);\n    dice_ulg(log->len, temp + 9);\n    if (write(log->fd, temp, 13) != 13)\n        return 1;\n\n    /* truncate file to discard remaining stored data and old trailer */\n    ftruncate(log->fd, lseek(log->fd, 0, SEEK_CUR));\n\n    /* update extra field to point to new last empty block */\n    (void)lseek(log->fd, log->extra, SEEK_SET);\n    dice_off(log->mark_off, temp);\n    dice_off(log->last_off, temp + 8);\n    if (write(log->fd, temp, 16) != 16)\n        return 1;\n    return 0;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "e4c2680865351d1b4b6eeaa10b5c8eab99b4f261278f423a96ed86e02ddfd6c6": [
  "int gzlog_close(void *obj)\n{\n    unsigned char temp[8];\n    gz_log *log;\n\n    /* check object */\n    log = (gz_log *)obj;\n    if (log == NULL || log->id != GZLOGID)\n        return 1;\n\n    /* go to start of most recent block being written */\n    (void)lseek(log->fd, log->last_off, SEEK_SET);\n\n    /* if some stuff was put there, update block */\n    if (log->stored) {\n        temp[0] = 0;\n        dice_ulg(log->stored + ((unsigned long)(~log->stored) << 16),\n                 temp + 1);\n        if (write(log->fd, temp, 5) != 5)\n            return 1;\n        log->last_off = lseek(log->fd, log->stored, SEEK_CUR);\n    }\n\n    /* write last block (empty) */\n    if (write(log->fd, \"\\001\\000\\000\\377\\377\", 5) != 5)\n        return 1;\n\n    /* write updated crc and uncompressed length */\n    dice_ulg(log->crc, temp);\n    dice_ulg(log->len, temp + 4);\n    if (write(log->fd, temp, 8) != 8)\n        return 1;\n\n    /* put offset of that last block in gzip extra block */\n    (void)lseek(log->fd, log->extra + 8, SEEK_SET);\n    dice_off(log->last_off, temp);\n    if (write(log->fd, temp, 8) != 8)\n        return 1;\n\n    /* if more than 1 MB stored, then time to compress it */\n    if (log->last_off - log->mark_off > MAX_STORED) {\n        if (recomp(log))\n            return 1;\n    }\n\n    /* unlock and close file */\n    log_clean(log);\n    return 0;\n}",
  {
   "v1.2.2.2": [
    "2011-09-09 23:24:33",
    "examples/gzlog.c"
   ],
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gzlog.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gzlog.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "409ae04dd07b81c861c41fe63c3a3461d8298145d292b529491980d685b700b0": [
  "int inf(FILE *source, FILE *dest)\n{\n    int ret;\n    unsigned have;\n    z_stream strm;\n    char in[CHUNK];\n    char out[CHUNK];\n\n    /* allocate inflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);\n    if (ret != Z_OK)\n        return ret;\n\n    /* decompress until deflate stream ends or end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)inflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        if (strm.avail_in == 0)\n            break;\n        strm.next_in = in;\n\n        /* run inflate() on input until output buffer not full */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = inflate(&strm, Z_NO_FLUSH);\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            switch (ret) {\n            case Z_NEED_DICT:\n                ret = Z_DATA_ERROR;     /* and fall through */\n            case Z_DATA_ERROR:\n            case Z_MEM_ERROR:\n                (void)inflateEnd(&strm);\n                return ret;\n            }\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)inflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n\n        /* done when inflate() says it's done */\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return */\n    (void)inflateEnd(&strm);\n    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/zpipe.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zpipe.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zpipe.c"
   ]
  }
 ],
 "0b30da136db8e46e0f68a7621281b0a2f431b9496d8d7253ef2c9aaab3b66ec5": [
  "local unsigned in(void *in_desc, unsigned char **buf)\n{\n    int ret;\n    unsigned len;\n    unsigned char *next;\n    struct ind *me = (struct ind *)in_desc;\n\n    next = me->inbuf;\n    *buf = next;\n    len = 0;\n    do {\n        ret = PIECE;\n        if ((unsigned)ret > SIZE - len)\n            ret = (int)(SIZE - len);\n        ret = (int)read(me->infile, next, ret);\n        if (ret == -1) {\n            len = 0;\n            break;\n        }\n        next += ret;\n        len += ret;\n    } while (ret != 0 && len < SIZE);\n    return len;\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gun.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gun.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gun.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gun.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gun.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gun.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gun.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gun.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gun.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gun.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gun.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gun.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gun.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gun.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gun.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gun.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gun.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gun.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gun.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gun.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gun.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gun.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gun.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gun.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gun.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gun.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gun.c"
   ]
  }
 ],
 "585bf19697e6a8d2c0a18a9a073e0b4a07ad7fefe6ac3a7d53210c2ccaf6865f": [
  "local int lunpipe(unsigned have, unsigned char *next, struct ind *indp,\n                  int outfile, z_stream *strm)\n{\n    int last;                   /* last byte read by NEXT(), or -1 if EOF */\n    int chunk;                  /* bytes left in current chunk */\n    int left;                   /* bits left in rem */\n    unsigned rem;               /* unused bits from input */\n    int bits;                   /* current bits per code */\n    unsigned code;              /* code, table traversal index */\n    unsigned mask;              /* mask for current bits codes */\n    int max;                    /* maximum bits per code for this stream */\n    int flags;                  /* compress flags, then block compress flag */\n    unsigned end;               /* last valid entry in prefix/suffix tables */\n    unsigned temp;              /* current code */\n    unsigned prev;              /* previous code */\n    unsigned final;             /* last character written for previous code */\n    unsigned stack;             /* next position for reversed string */\n    unsigned outcnt;            /* bytes in output buffer */\n    struct outd outd;           /* output structure */\n\n    /* set up output */\n    outd.outfile = outfile;\n    outd.check = 0;\n\n    /* process remainder of compress header -- a flags byte */\n    flags = NEXT();\n    if (last == -1)\n        return Z_BUF_ERROR;\n    if (flags & 0x60) {\n        strm->msg = \"unknown lzw flags set\";\n        return Z_DATA_ERROR;\n    }\n    max = flags & 0x1f;\n    if (max < 9 || max > 16) {\n        strm->msg = \"lzw bits out of range\";\n        return Z_DATA_ERROR;\n    }\n    if (max == 9)                           /* 9 doesn't really mean 9 */\n        max = 10;\n    flags &= 0x80;                          /* true if block compress */\n\n    /* clear table */\n    bits = 9;\n    mask = 0x1ff;\n    end = flags ? 256 : 255;\n\n    /* set up: get first 9-bit code, which is the first decompressed byte, but\n       don't create a table entry until the next code */\n    if (NEXT() == -1)                       /* no compressed data is ok */\n        return Z_OK;\n    final = prev = (unsigned)last;          /* low 8 bits of code */\n    if (NEXT() == -1)                       /* missing a bit */\n        return Z_BUF_ERROR;\n    if (last & 1) {                         /* code must be < 256 */\n        strm->msg = \"invalid lzw code\";\n        return Z_DATA_ERROR;\n    }\n    rem = (unsigned)last >> 1;              /* remaining 7 bits */\n    left = 7;\n    chunk = bits - 2;                       /* 7 bytes left in this chunk */\n    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */\n    outcnt = 1;\n\n    /* decode codes */\n    stack = 0;\n    for (;;) {\n        /* if the table will be full after this, increment the code size */\n        if (end >= mask && bits < max) {\n            FLUSHCODE();\n            bits++;\n            mask <<= 1;\n            mask++;\n        }\n\n        /* get a code of length bits */\n        if (chunk == 0)                     /* decrement chunk modulo bits */\n            chunk = bits;\n        code = rem;                         /* low bits of code */\n        if (NEXT() == -1) {                 /* EOF is end of compressed data */\n            /* write remaining buffered output */\n            if (outcnt && out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf;     /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            return Z_OK;\n        }\n        code += (unsigned)last << left;     /* middle (or high) bits of code */\n        left += 8;\n        chunk--;\n        if (bits > left) {                  /* need more bits */\n            if (NEXT() == -1)               /* can't end in middle of code */\n                return Z_BUF_ERROR;\n            code += (unsigned)last << left; /* high bits of code */\n            left += 8;\n            chunk--;\n        }\n        code &= mask;                       /* mask to current code length */\n        left -= bits;                       /* number of unused bits */\n        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */\n\n        /* process clear code (256) */\n        if (code == 256 && flags) {\n            FLUSHCODE();\n            bits = 9;                       /* initialize bits and mask */\n            mask = 0x1ff;\n            end = 255;                      /* empty table */\n            continue;                       /* get next code */\n        }\n\n        /* special code to reuse last match */\n        temp = code;                        /* save the current code */\n        if (code > end) {\n            /* Be picky on the allowed code here, and make sure that the code\n               we drop through (prev) will be a valid index so that random\n               input does not cause an exception.  The code != end + 1 check is\n               empirically derived, and not checked in the original uncompress\n               code.  If this ever causes a problem, that check could be safely\n               removed.  Leaving this check in greatly improves gun's ability\n               to detect random or corrupted input after a compress header.\n               In any case, the prev > end check must be retained. */\n            if (code != end + 1 || prev > end) {\n                strm->msg = \"invalid lzw code\";\n                return Z_DATA_ERROR;\n            }\n            match[stack++] = (unsigned char)final;\n            code = prev;\n        }\n\n        /* walk through linked list to generate output in reverse order */\n        while (code >= 256) {\n            match[stack++] = suffix[code];\n            code = prefix[code];\n        }\n        match[stack++] = (unsigned char)code;\n        final = code;\n\n        /* link new table entry */\n        if (end < mask) {\n            end++;\n            prefix[end] = (unsigned short)prev;\n            suffix[end] = (unsigned char)final;\n        }\n\n        /* set previous code for next iteration */\n        prev = temp;\n\n        /* write output in forward order */\n        while (stack > SIZE - outcnt) {\n            while (outcnt < SIZE)\n                outbuf[outcnt++] = match[--stack];\n            if (out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf; /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            outcnt = 0;\n        }\n        do {\n            outbuf[outcnt++] = match[--stack];\n        } while (stack);\n\n        /* loop for next code with final and prev as the last match, rem and\n           left provide the first 0..7 bits of the next code, end is the last\n           valid table entry */\n    }\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gun.c"
   ]
  }
 ],
 "e5424cb710939c9fa6b98ae6584154e59ad2c1d414d3d74928e9f13a47a03e92": [
  "local int gunpipe(z_stream *strm, int infile, int outfile)\n{\n    int ret, first, last;\n    unsigned have, flags, len;\n    unsigned char *next;\n    struct ind ind, *indp;\n    struct outd outd;\n\n    /* setup input buffer */\n    ind.infile = infile;\n    ind.inbuf = inbuf;\n    indp = &ind;\n\n    /* decompress concatenated gzip streams */\n    have = 0;                               /* no input data read in yet */\n    first = 1;                              /* looking for first gzip header */\n    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */\n    for (;;) {\n        /* look for the two magic header bytes for a gzip stream */\n        if (NEXT() == -1) {\n            ret = Z_OK;\n            break;                          /* empty gzip stream is ok */\n        }\n        if (last != 31 || (NEXT() != 139 && last != 157)) {\n            strm->msg = \"incorrect header check\";\n            ret = first ? Z_DATA_ERROR : Z_ERRNO;\n            break;                          /* not a gzip or compress header */\n        }\n        first = 0;                          /* next non-header is junk */\n\n        /* process a compress (LZW) file -- can't be concatenated after this */\n        if (last == 157) {\n            ret = lunpipe(have, next, indp, outfile, strm);\n            break;\n        }\n\n        /* process remainder of gzip header */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != 8) {                  /* only deflate method allowed */\n            if (last == -1) break;\n            strm->msg = \"unknown compression method\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        flags = NEXT();                     /* header flags */\n        NEXT();                             /* discard mod time, xflgs, os */\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        if (last == -1) break;\n        if (flags & 0xe0) {\n            strm->msg = \"unknown header flags set\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        if (flags & 4) {                    /* extra field */\n            len = NEXT();\n            len += (unsigned)(NEXT()) << 8;\n            if (last == -1) break;\n            while (len > have) {\n                len -= have;\n                have = 0;\n                if (NEXT() == -1) break;\n                len--;\n            }\n            if (last == -1) break;\n            have -= len;\n            next += len;\n        }\n        if (flags & 8)                      /* file name */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 16)                     /* comment */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 2) {                    /* header crc */\n            NEXT();\n            NEXT();\n        }\n        if (last == -1) break;\n\n        /* set up output */\n        outd.outfile = outfile;\n        outd.check = 1;\n        outd.crc = crc32(0L, Z_NULL, 0);\n        outd.total = 0;\n\n        /* decompress data to output */\n        strm->next_in = next;\n        strm->avail_in = have;\n        ret = inflateBack(strm, in, indp, out, &outd);\n        if (ret != Z_STREAM_END) break;\n        next = strm->next_in;\n        have = strm->avail_in;\n        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */\n\n        /* check trailer */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != (outd.crc & 0xff) ||\n            NEXT() != ((outd.crc >> 8) & 0xff) ||\n            NEXT() != ((outd.crc >> 16) & 0xff) ||\n            NEXT() != ((outd.crc >> 24) & 0xff)) {\n            /* crc error */\n            if (last != -1) {\n                strm->msg = \"incorrect data check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n        if (NEXT() != (outd.total & 0xff) ||\n            NEXT() != ((outd.total >> 8) & 0xff) ||\n            NEXT() != ((outd.total >> 16) & 0xff) ||\n            NEXT() != ((outd.total >> 24) & 0xff)) {\n            /* length error */\n            if (last != -1) {\n                strm->msg = \"incorrect length check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n\n        /* go back and look for another gzip stream */\n    }\n\n    /* clean up and return */\n    return ret;\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gun.c"
   ]
  }
 ],
 "e424a5a6c7960d90143d5ded3fc0549a8dd74773ea63c77895b71634dd06635e": [
  "int main(int argc, char **argv)\n{\n    int ret, len, test;\n    char *outname;\n    unsigned char *window;\n    z_stream strm;\n\n    /* initialize inflateBack state for repeated use */\n    window = match;                         /* reuse LZW match buffer */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = inflateBackInit(&strm, 15, window);\n    if (ret != Z_OK) {\n        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n        return 1;\n    }\n\n    /* decompress each file to the same name with the suffix removed */\n    argc--;\n    argv++;\n    test = 0;\n    if (argc && strcmp(*argv, \"-h\") == 0) {\n        fprintf(stderr, \"gun 1.2 (20 Mar 2005)\\n\");\n        fprintf(stderr, \"Copyright (c) 2005 Mark Adler\\n\");\n        fprintf(stderr, \"usage: gun [-t] [file1.gz [file2.Z ...]]\\n\");\n        return 0;\n    }\n    if (argc && strcmp(*argv, \"-t\") == 0) {\n        test = 1;\n        argc--;\n        argv++;\n    }\n    if (argc)\n        do {\n            if (test)\n                outname = NULL;\n            else {\n                len = (int)strlen(*argv);\n                if (strcmp(*argv + len - 3, \".gz\") == 0 ||\n                    strcmp(*argv + len - 3, \"-gz\") == 0)\n                    len -= 3;\n                else if (strcmp(*argv + len - 2, \".z\") == 0 ||\n                    strcmp(*argv + len - 2, \"-z\") == 0 ||\n                    strcmp(*argv + len - 2, \"_z\") == 0 ||\n                    strcmp(*argv + len - 2, \".Z\") == 0)\n                    len -= 2;\n                else {\n                    fprintf(stderr, \"gun error: no gz type on %s--skipping\\n\",\n                            *argv);\n                    continue;\n                }\n                outname = malloc(len + 1);\n                if (outname == NULL) {\n                    fprintf(stderr, \"gun out of memory error--aborting\\n\");\n                    ret = 1;\n                    break;\n                }\n                memcpy(outname, *argv, len);\n                outname[len] = 0;\n            }\n            ret = gunzip(&strm, *argv, outname, test);\n            if (outname != NULL) free(outname);\n            if (ret) break;\n        } while (argv++, --argc);\n    else\n        ret = gunzip(&strm, NULL, NULL, test);\n\n    /* clean up */\n    inflateBackEnd(&strm);\n    return ret;\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "examples/gun.c"
   ]
  }
 ],
 "0c8f854eaadd72981fcba09f6915b6807446a75f85ee17871addbad204b22532": [
  "void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\r\n{\r\n //   printf(\"rdtsc = %I64x\\n\",myrdtsc());\r\n   pbeginTime64->QuadPart=myrdtsc();\r\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "fd4f37ce6ff26cb73cc5914aa8128cf9417c6dc7acb18be78602f758c9d132fd": [
  "LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\r\n{\r\n    LARGE_INTEGER LIres;\r\n    unsigned _int64 res=myrdtsc()-((unsigned _int64)(beginTime64.QuadPart));\r\n    LIres.QuadPart=res;\r\n   // printf(\"rdtsc = %I64x\\n\",myrdtsc());\r\n    return LIres;\r\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/testzlib/testzlib.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/testzlib/testzlib.c"
   ]
  }
 ],
 "60105fde3e8fc650ca22bbfc9bc81c3140b616d49fc5f7db2ad2360d4b5a5058": [
  "void match_init ()\r\n{\r\n    iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\r\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/masmx86/gvmat32c.c"
   ]
  }
 ],
 "a5a6fe1452be354a277f74c8c2dcf3e9493a6d27c2581d1bdb19aa7109fcebad": [
  "uInt longest_match(\r\n    deflate_state *s,\r\n    IPos cur_match)                             /* current match */\r\n{\r\n    if (iIsPPro!=0)\r\n        return longest_match_686(s,cur_match);\r\n\r\n    if (s->w_mask != 0x7fff)\r\n        return longest_match_686(s,cur_match);\r\n\r\n    /* now ((s->w_mask == 0x7fff) && (iIsPPro==0)) */\r\n        return longest_match_7fff(s,cur_match);\r\n}",
  {
   "v1.2.2.3": [
    "2011-09-09 23:24:43",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/masmx86/gvmat32c.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/masmx86/gvmat32c.c"
   ]
  }
 ],
 "3b3c2f69532a5950c9cbdca483dc801b867ac951d375a200039dc9e17160664e": [
  "local int lunpipe(unsigned have, unsigned char *next, struct ind *indp,\n                  int outfile, z_stream *strm)\n{\n    int last;                   /* last byte read by NEXT(), or -1 if EOF */\n    int chunk;                  /* bytes left in current chunk */\n    int left;                   /* bits left in rem */\n    unsigned rem;               /* unused bits from input */\n    int bits;                   /* current bits per code */\n    unsigned code;              /* code, table traversal index */\n    unsigned mask;              /* mask for current bits codes */\n    int max;                    /* maximum bits per code for this stream */\n    int flags;                  /* compress flags, then block compress flag */\n    unsigned end;               /* last valid entry in prefix/suffix tables */\n    unsigned temp;              /* current code */\n    unsigned prev;              /* previous code */\n    unsigned final;             /* last character written for previous code */\n    unsigned stack;             /* next position for reversed string */\n    unsigned outcnt;            /* bytes in output buffer */\n    struct outd outd;           /* output structure */\n\n    /* set up output */\n    outd.outfile = outfile;\n    outd.check = 0;\n\n    /* process remainder of compress header -- a flags byte */\n    flags = NEXT();\n    if (last == -1)\n        return Z_BUF_ERROR;\n    if (flags & 0x60) {\n        strm->msg = (char *)\"unknown lzw flags set\";\n        return Z_DATA_ERROR;\n    }\n    max = flags & 0x1f;\n    if (max < 9 || max > 16) {\n        strm->msg = (char *)\"lzw bits out of range\";\n        return Z_DATA_ERROR;\n    }\n    if (max == 9)                           /* 9 doesn't really mean 9 */\n        max = 10;\n    flags &= 0x80;                          /* true if block compress */\n\n    /* clear table */\n    bits = 9;\n    mask = 0x1ff;\n    end = flags ? 256 : 255;\n\n    /* set up: get first 9-bit code, which is the first decompressed byte, but\n       don't create a table entry until the next code */\n    if (NEXT() == -1)                       /* no compressed data is ok */\n        return Z_OK;\n    final = prev = (unsigned)last;          /* low 8 bits of code */\n    if (NEXT() == -1)                       /* missing a bit */\n        return Z_BUF_ERROR;\n    if (last & 1) {                         /* code must be < 256 */\n        strm->msg = (char *)\"invalid lzw code\";\n        return Z_DATA_ERROR;\n    }\n    rem = (unsigned)last >> 1;              /* remaining 7 bits */\n    left = 7;\n    chunk = bits - 2;                       /* 7 bytes left in this chunk */\n    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */\n    outcnt = 1;\n\n    /* decode codes */\n    stack = 0;\n    for (;;) {\n        /* if the table will be full after this, increment the code size */\n        if (end >= mask && bits < max) {\n            FLUSHCODE();\n            bits++;\n            mask <<= 1;\n            mask++;\n        }\n\n        /* get a code of length bits */\n        if (chunk == 0)                     /* decrement chunk modulo bits */\n            chunk = bits;\n        code = rem;                         /* low bits of code */\n        if (NEXT() == -1) {                 /* EOF is end of compressed data */\n            /* write remaining buffered output */\n            if (outcnt && out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf;     /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            return Z_OK;\n        }\n        code += (unsigned)last << left;     /* middle (or high) bits of code */\n        left += 8;\n        chunk--;\n        if (bits > left) {                  /* need more bits */\n            if (NEXT() == -1)               /* can't end in middle of code */\n                return Z_BUF_ERROR;\n            code += (unsigned)last << left; /* high bits of code */\n            left += 8;\n            chunk--;\n        }\n        code &= mask;                       /* mask to current code length */\n        left -= bits;                       /* number of unused bits */\n        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */\n\n        /* process clear code (256) */\n        if (code == 256 && flags) {\n            FLUSHCODE();\n            bits = 9;                       /* initialize bits and mask */\n            mask = 0x1ff;\n            end = 255;                      /* empty table */\n            continue;                       /* get next code */\n        }\n\n        /* special code to reuse last match */\n        temp = code;                        /* save the current code */\n        if (code > end) {\n            /* Be picky on the allowed code here, and make sure that the code\n               we drop through (prev) will be a valid index so that random\n               input does not cause an exception.  The code != end + 1 check is\n               empirically derived, and not checked in the original uncompress\n               code.  If this ever causes a problem, that check could be safely\n               removed.  Leaving this check in greatly improves gun's ability\n               to detect random or corrupted input after a compress header.\n               In any case, the prev > end check must be retained. */\n            if (code != end + 1 || prev > end) {\n                strm->msg = (char *)\"invalid lzw code\";\n                return Z_DATA_ERROR;\n            }\n            match[stack++] = (unsigned char)final;\n            code = prev;\n        }\n\n        /* walk through linked list to generate output in reverse order */\n        while (code >= 256) {\n            match[stack++] = suffix[code];\n            code = prefix[code];\n        }\n        match[stack++] = (unsigned char)code;\n        final = code;\n\n        /* link new table entry */\n        if (end < mask) {\n            end++;\n            prefix[end] = (unsigned short)prev;\n            suffix[end] = (unsigned char)final;\n        }\n\n        /* set previous code for next iteration */\n        prev = temp;\n\n        /* write output in forward order */\n        while (stack > SIZE - outcnt) {\n            while (outcnt < SIZE)\n                outbuf[outcnt++] = match[--stack];\n            if (out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf; /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            outcnt = 0;\n        }\n        do {\n            outbuf[outcnt++] = match[--stack];\n        } while (stack);\n\n        /* loop for next code with final and prev as the last match, rem and\n           left provide the first 0..7 bits of the next code, end is the last\n           valid table entry */\n    }\n}",
  {
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gun.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gun.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gun.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gun.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gun.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gun.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gun.c"
   ]
  }
 ],
 "4f65ca242fd18bb8a4b3ea197b939abc1e83fa24bd438524bf114c1979d2d29b": [
  "local int gunpipe(z_stream *strm, int infile, int outfile)\n{\n    int ret, first, last;\n    unsigned have, flags, len;\n    unsigned char *next;\n    struct ind ind, *indp;\n    struct outd outd;\n\n    /* setup input buffer */\n    ind.infile = infile;\n    ind.inbuf = inbuf;\n    indp = &ind;\n\n    /* decompress concatenated gzip streams */\n    have = 0;                               /* no input data read in yet */\n    first = 1;                              /* looking for first gzip header */\n    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */\n    for (;;) {\n        /* look for the two magic header bytes for a gzip stream */\n        if (NEXT() == -1) {\n            ret = Z_OK;\n            break;                          /* empty gzip stream is ok */\n        }\n        if (last != 31 || (NEXT() != 139 && last != 157)) {\n            strm->msg = (char *)\"incorrect header check\";\n            ret = first ? Z_DATA_ERROR : Z_ERRNO;\n            break;                          /* not a gzip or compress header */\n        }\n        first = 0;                          /* next non-header is junk */\n\n        /* process a compress (LZW) file -- can't be concatenated after this */\n        if (last == 157) {\n            ret = lunpipe(have, next, indp, outfile, strm);\n            break;\n        }\n\n        /* process remainder of gzip header */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != 8) {                  /* only deflate method allowed */\n            if (last == -1) break;\n            strm->msg = (char *)\"unknown compression method\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        flags = NEXT();                     /* header flags */\n        NEXT();                             /* discard mod time, xflgs, os */\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        if (last == -1) break;\n        if (flags & 0xe0) {\n            strm->msg = (char *)\"unknown header flags set\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        if (flags & 4) {                    /* extra field */\n            len = NEXT();\n            len += (unsigned)(NEXT()) << 8;\n            if (last == -1) break;\n            while (len > have) {\n                len -= have;\n                have = 0;\n                if (NEXT() == -1) break;\n                len--;\n            }\n            if (last == -1) break;\n            have -= len;\n            next += len;\n        }\n        if (flags & 8)                      /* file name */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 16)                     /* comment */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 2) {                    /* header crc */\n            NEXT();\n            NEXT();\n        }\n        if (last == -1) break;\n\n        /* set up output */\n        outd.outfile = outfile;\n        outd.check = 1;\n        outd.crc = crc32(0L, Z_NULL, 0);\n        outd.total = 0;\n\n        /* decompress data to output */\n        strm->next_in = next;\n        strm->avail_in = have;\n        ret = inflateBack(strm, in, indp, out, &outd);\n        if (ret != Z_STREAM_END) break;\n        next = strm->next_in;\n        have = strm->avail_in;\n        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */\n\n        /* check trailer */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != (outd.crc & 0xff) ||\n            NEXT() != ((outd.crc >> 8) & 0xff) ||\n            NEXT() != ((outd.crc >> 16) & 0xff) ||\n            NEXT() != ((outd.crc >> 24) & 0xff)) {\n            /* crc error */\n            if (last != -1) {\n                strm->msg = (char *)\"incorrect data check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n        if (NEXT() != (outd.total & 0xff) ||\n            NEXT() != ((outd.total >> 8) & 0xff) ||\n            NEXT() != ((outd.total >> 16) & 0xff) ||\n            NEXT() != ((outd.total >> 24) & 0xff)) {\n            /* length error */\n            if (last != -1) {\n                strm->msg = (char *)\"incorrect length check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n\n        /* go back and look for another gzip stream */\n    }\n\n    /* clean up and return */\n    return ret;\n}",
  {
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gun.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gun.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gun.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gun.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gun.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gun.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gun.c"
   ]
  }
 ],
 "120bd26b561f909d16e56867afc9d5342f775afc4636a53ec5439bd92b79efbf": [
  "int main(int argc, char **argv)\n{\n    int ret, len, test;\n    char *outname;\n    unsigned char *window;\n    z_stream strm;\n\n    /* initialize inflateBack state for repeated use */\n    window = match;                         /* reuse LZW match buffer */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = inflateBackInit(&strm, 15, window);\n    if (ret != Z_OK) {\n        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n        return 1;\n    }\n\n    /* decompress each file to the same name with the suffix removed */\n    argc--;\n    argv++;\n    test = 0;\n    if (argc && strcmp(*argv, \"-h\") == 0) {\n        fprintf(stderr, \"gun 1.3 (12 Jun 2005)\\n\");\n        fprintf(stderr, \"Copyright (c) 2005 Mark Adler\\n\");\n        fprintf(stderr, \"usage: gun [-t] [file1.gz [file2.Z ...]]\\n\");\n        return 0;\n    }\n    if (argc && strcmp(*argv, \"-t\") == 0) {\n        test = 1;\n        argc--;\n        argv++;\n    }\n    if (argc)\n        do {\n            if (test)\n                outname = NULL;\n            else {\n                len = (int)strlen(*argv);\n                if (strcmp(*argv + len - 3, \".gz\") == 0 ||\n                    strcmp(*argv + len - 3, \"-gz\") == 0)\n                    len -= 3;\n                else if (strcmp(*argv + len - 2, \".z\") == 0 ||\n                    strcmp(*argv + len - 2, \"-z\") == 0 ||\n                    strcmp(*argv + len - 2, \"_z\") == 0 ||\n                    strcmp(*argv + len - 2, \".Z\") == 0)\n                    len -= 2;\n                else {\n                    fprintf(stderr, \"gun error: no gz type on %s--skipping\\n\",\n                            *argv);\n                    continue;\n                }\n                outname = malloc(len + 1);\n                if (outname == NULL) {\n                    fprintf(stderr, \"gun out of memory error--aborting\\n\");\n                    ret = 1;\n                    break;\n                }\n                memcpy(outname, *argv, len);\n                outname[len] = 0;\n            }\n            ret = gunzip(&strm, *argv, outname, test);\n            if (outname != NULL) free(outname);\n            if (ret) break;\n        } while (argv++, --argc);\n    else\n        ret = gunzip(&strm, NULL, NULL, test);\n\n    /* clean up */\n    inflateBackEnd(&strm);\n    return ret;\n}",
  {
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/gun.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/gun.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gun.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gun.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gun.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gun.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gun.c"
   ]
  }
 ],
 "d022ce51f6a761fa74d543f791e86d564d6c52948b2172bf7e6d70bb4e7332cb": [
  "local int build_index(FILE *in, off_t span, struct access **built)\n{\n    int ret;\n    off_t totin, totout;        /* our own total counters to avoid 4GB limit */\n    off_t last;                 /* totout value of last access point */\n    struct access *index;       /* access points being generated */\n    z_stream strm;\n    unsigned char input[CHUNK];\n    unsigned char window[WINSIZE];\n\n    /* initialize inflate */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, 47);      /* automatic zlib or gzip decoding */\n    if (ret != Z_OK)\n        return ret;\n\n    /* inflate the input, maintain a sliding window, and build an index -- this\n       also validates the integrity of the compressed data using the check\n       information at the end of the gzip or zlib stream */\n    totin = totout = last = 0;\n    index = NULL;               /* will be allocated by first addpoint() */\n    strm.avail_out = 0;\n    do {\n        /* get some compressed data from input file */\n        strm.avail_in = fread(input, 1, CHUNK, in);\n        if (ferror(in)) {\n            ret = Z_ERRNO;\n            goto build_index_error;\n        }\n        if (strm.avail_in == 0) {\n            ret = Z_DATA_ERROR;\n            goto build_index_error;\n        }\n        strm.next_in = input;\n\n        /* process all of that, or until end of stream */\n        do {\n            /* reset sliding window if necessary */\n            if (strm.avail_out == 0) {\n                strm.avail_out = WINSIZE;\n                strm.next_out = window;\n            }\n\n            /* inflate until out of input, output, or at end of block --\n               update the total input and output counters */\n            totin += strm.avail_in;\n            totout += strm.avail_out;\n            ret = inflate(&strm, Z_BLOCK);      /* return at end of block */\n            totin -= strm.avail_in;\n            totout -= strm.avail_out;\n            if (ret == Z_NEED_DICT)\n                ret = Z_DATA_ERROR;\n            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)\n                goto build_index_error;\n            if (ret == Z_STREAM_END)\n                break;\n\n            /* if at end of block, consider adding an index entry (note that if\n               data_type indicates an end-of-block, then all of the\n               uncompressed data from that block has been delivered, and none\n               of the compressed data after that block has been consumed,\n               except for up to seven bits) -- the totout == 0 provides an\n               entry point after the zlib or gzip header, and assures that the\n               index always has at least one access point; we avoid creating an\n               access point after the last block by checking bit 6 of data_type\n             */\n            if ((strm.data_type & 128) && !(strm.data_type & 64) &&\n                (totout == 0 || totout - last > span)) {\n                index = addpoint(index, strm.data_type & 7, totin,\n                                 totout, strm.avail_out, window);\n                if (index == NULL) {\n                    ret = Z_MEM_ERROR;\n                    goto build_index_error;\n                }\n                last = totout;\n            }\n        } while (strm.avail_in != 0);\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return index (release unused entries in list) */\n    (void)inflateEnd(&strm);\n    index = realloc(index, sizeof(struct point) * index->have);\n    index->size = index->have;\n    *built = index;\n    return index->size;\n\n    /* return error */\n  build_index_error:\n    (void)inflateEnd(&strm);\n    if (index != NULL)\n        free_index(index);\n    return ret;\n}",
  {
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zran.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zran.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/zran.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/zran.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/zran.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/zran.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/zran.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/zran.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/zran.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/zran.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/zran.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/zran.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/zran.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/zran.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/zran.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/zran.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/zran.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/zran.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/zran.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/zran.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/zran.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/zran.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/zran.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/zran.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/zran.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/zran.c"
   ]
  }
 ],
 "72b591142d27c6ed4ade81d5c055b3e29da4117c698ec3e59ae8ab86635e9b9c": [
  "int main(int argc, char **argv)\n{\n    int len;\n    off_t offset;\n    FILE *in;\n    struct access *index;\n    unsigned char buf[CHUNK];\n\n    /* open input file */\n    if (argc != 2) {\n        fprintf(stderr, \"usage: zran file.gz\\n\");\n        return 1;\n    }\n    in = fopen(argv[1], \"rb\");\n    if (in == NULL) {\n        fprintf(stderr, \"zran: could not open %s for reading\\n\", argv[1]);\n        return 1;\n    }\n\n    /* build index */\n    len = build_index(in, SPAN, &index);\n    if (len < 0) {\n        fclose(in);\n        switch (len) {\n        case Z_MEM_ERROR:\n            fprintf(stderr, \"zran: out of memory\\n\");\n            break;\n        case Z_DATA_ERROR:\n            fprintf(stderr, \"zran: compressed data error in %s\\n\", argv[1]);\n            break;\n        case Z_ERRNO:\n            fprintf(stderr, \"zran: read error on %s\\n\", argv[1]);\n            break;\n        default:\n            fprintf(stderr, \"zran: error %d while building index\\n\", len);\n        }\n        return 1;\n    }\n    fprintf(stderr, \"zran: built index with %d access points\\n\", len);\n\n    /* use index by reading some bytes from an arbitrary offset */\n    offset = (index->list[index->have - 1].out << 1) / 3;\n    len = extract(in, index, offset, buf, CHUNK);\n    if (len < 0)\n        fprintf(stderr, \"zran: extraction failed: %s error\\n\",\n                len == Z_MEM_ERROR ? \"out of memory\" : \"input corrupted\");\n    else {\n        fwrite(buf, 1, len, stdout);\n        fprintf(stderr, \"zran: extracted %d bytes at %llu\\n\", len, offset);\n    }\n\n    /* clean up and exit */\n    free_index(index);\n    fclose(in);\n    return 0;\n}",
  {
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "examples/zran.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "examples/zran.c"
   ]
  }
 ],
 "77bff76a10325d221f979b006adde60a9c6a43c849ec7924ec6997f1d268e70b": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch (sizeof(uInt)) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch (sizeof(uLong)) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch (sizeof(voidpf)) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch (sizeof(z_off_t)) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#else\n        flags += 1L << 24;\n#  ifdef NO_snprintf\n        flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.2.4": [
    "2011-09-09 23:24:52",
    "zutil.c"
   ],
   "v1.2.3": [
    "2011-09-09 23:25:17",
    "zutil.c"
   ],
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "zutil.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "zutil.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "zutil.c"
   ],
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "zutil.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "zutil.c"
   ]
  }
 ],
 "fca7cc0f848884def0763b69bc5c765af8c625b3107eef9764945130c00907f0": [
  "int gzlog_write(void *obj, char *data, size_t len)\n{\n    size_t some;\n    unsigned char temp[5];\n    gz_log *log;\n\n    /* check object */\n    log = (gz_log *)obj;\n    if (log == NULL || log->id != GZLOGID)\n        return 1;\n\n    /* write stored blocks until all of the input is written */\n    do {\n        some = MAX_BLOCK - log->stored;\n        if (some > len)\n            some = len;\n        if (write(log->fd, data, some) != some)\n            return 1;\n        log->crc = crc32(log->crc, (unsigned char *)data, some);\n        log->len += some;\n        len -= some;\n        data += some;\n        log->stored += some;\n\n        /* if the stored block is full, end it and start another */\n        if (log->stored == MAX_BLOCK) {\n            (void)lseek(log->fd, log->last_off, SEEK_SET);\n            temp[0] = 0;\n            dice_ulg(log->stored + ((unsigned long)(~log->stored) << 16),\n                     temp + 1);\n            if (write(log->fd, temp, 5) != 5)\n                return 1;\n            log->last_off = lseek(log->fd, log->stored, SEEK_CUR);\n            (void)lseek(log->fd, 5, SEEK_CUR);\n            log->stored = 0;\n        }\n    } while (len);\n    return 0;\n}",
  {
   "v1.2.3.1": [
    "2011-09-09 23:25:27",
    "examples/gzlog.c"
   ],
   "v1.2.3.2": [
    "2011-09-09 23:25:38",
    "examples/gzlog.c"
   ],
   "v1.2.3.3": [
    "2011-09-09 23:26:29",
    "examples/gzlog.c"
   ]
  }
 ],
 "56506f0955a0681088e5aec72b12d69e118353a87acfd1a0a3c925d777bb607a": [
  "local big_t count(int syms, int len, int left)\n{\n    big_t sum;          /* number of possible codes from this juncture */\n    big_t got;          /* value returned from count() */\n    int least;          /* least number of syms to use at this juncture */\n    int most;           /* most number of syms to use at this juncture */\n    int use;            /* number of bit patterns to use in next call */\n    size_t index;       /* index of this case in *num */\n\n    /* see if only one possible code */\n    if (syms == left)\n        return 1;\n\n    /* note and verify the expected state */\n    assert(syms > left && left > 0 && len < max);\n\n    /* see if we've done this one already */\n    index = INDEX(syms, left, len);\n    got = num[index];\n    if (got)\n        return got;         /* we have -- return the saved result */\n\n    /* we need to use at least this many bit patterns so that the code won't be\n       incomplete at the next length (more bit patterns than symbols) */\n    least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    /* we can use at most this many bit patterns, lest there not be enough\n       available for the remaining symbols at the maximum length (if there were\n       no limit to the code length, this would become: most = left - 1) */\n    most = (((code_t)left << (max - len)) - syms) /\n            (((code_t)1 << (max - len)) - 1);\n\n    /* count all possible codes from this juncture and add them up */\n    sum = 0;\n    for (use = least; use <= most; use++) {\n        got = count(syms - use, len + 1, (left - use) << 1);\n        sum += got;\n        if (got == -1 || sum < got)         /* overflow */\n            return -1;\n    }\n\n    /* verify that all recursive calls are productive */\n    assert(sum != 0);\n\n    /* save the result and return it */\n    num[index] = sum;\n    return sum;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/enough.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/enough.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/enough.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/enough.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/enough.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/enough.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/enough.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/enough.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/enough.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/enough.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/enough.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/enough.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/enough.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/enough.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/enough.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/enough.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/enough.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/enough.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/enough.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/enough.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/enough.c"
   ]
  }
 ],
 "cb8e1760efce82d11e6d1eefe138d3dd9f9a7b5837f40b1326df43d4f7016999": [
  "int main(int argc, char **argv)\n{\n    int syms;           /* total number of symbols to code */\n    int n;              /* number of symbols to code for this run */\n    big_t got;          /* return value of count() */\n    big_t sum;          /* accumulated number of codes over n */\n\n    /* set up globals for cleanup() */\n    code = NULL;\n    num = NULL;\n    done = NULL;\n\n    /* get arguments -- default to the deflate literal/length code */\n    syms = 286;\n\troot = 9;\n    max = 15;\n    if (argc > 1) {\n        syms = atoi(argv[1]);\n        if (argc > 2) {\n            root = atoi(argv[2]);\n\t\t\tif (argc > 3)\n\t\t\t\tmax = atoi(argv[3]);\n\t\t}\n    }\n    if (argc > 4 || syms < 2 || root < 1 || max < 1) {\n        fputs(\"invalid arguments, need: [sym >= 2 [root >= 1 [max >= 1]]]\\n\",\n\t\t\t  stderr);\n        return 1;\n    }\n\n    /* if not restricting the code length, the longest is syms - 1 */\n    if (max > syms - 1)\n        max = syms - 1;\n\n    /* determine the number of bits in a code_t */\n    n = 0;\n    while (((code_t)1 << n) != 0)\n        n++;\n\n    /* make sure that the calculation of most will not overflow */\n    if (max > n || syms - 2 >= (((code_t)0 - 1) >> (max - 1))) {\n        fputs(\"abort: code length too long for internal types\\n\", stderr);\n        return 1;\n    }\n\n    /* reject impossible code requests */\n    if (syms - 1 > ((code_t)1 << max) - 1) {\n        fprintf(stderr, \"%d symbols cannot be coded in %d bits\\n\",\n                syms, max);\n        return 1;\n    }\n\n    /* allocate code vector */\n    code = calloc(max + 1, sizeof(int));\n    if (code == NULL) {\n        fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n        return 1;\n    }\n\n    /* determine size of saved results array, checking for overflows,\n       allocate and clear the array (set all to zero with calloc()) */\n    if (syms == 2)              /* iff max == 1 */\n        num = NULL;             /* won't be saving any results */\n    else {\n        size = syms >> 1;\n        if (size > ((size_t)0 - 1) / (n = (syms - 1) >> 1) ||\n                (size *= n, size > ((size_t)0 - 1) / (n = max - 1)) ||\n                (size *= n, size > ((size_t)0 - 1) / sizeof(big_t)) ||\n                (num = calloc(size, sizeof(big_t))) == NULL) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            return 1;\n        }\n    }\n\n    /* count possible codes for all numbers of symbols, add up counts */\n    sum = 0;\n    for (n = 2; n <= syms; n++) {\n        got = count(n, 1, 2);\n        sum += got;\n        if (got == -1 || sum < got) {       /* overflow */\n            fputs(\"abort: can't count that high!\\n\", stderr);\n            cleanup();\n            return 1;\n        }\n        printf(\"%llu %d-codes\\n\", got, n);\n    }\n    printf(\"%llu total codes for 2 to %d symbols\", sum, syms);\n    if (max < syms - 1)\n        printf(\" (%d-bit length limit)\\n\", max);\n    else\n        puts(\" (no length limit)\");\n\n    /* allocate and clear done array for beenhere() */\n    if (syms == 2)\n        done = NULL;\n    else if (size > ((size_t)0 - 1) / sizeof(struct tab) ||\n             (done = calloc(size, sizeof(struct tab))) == NULL) {\n        fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n        cleanup();\n        return 1;\n    }\n\n    /* find and show maximum inflate table usage */\n\tif (root > max)                 /* reduce root to max length */\n\t\troot = max;\n    if (syms < ((code_t)1 << (root + 1)))\n        enough(syms);\n    else\n        puts(\"cannot handle minimum code lengths > root\");\n\n    /* done */\n    cleanup();\n    return 0;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/enough.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/enough.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/enough.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/enough.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/enough.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/enough.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/enough.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/enough.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/enough.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/enough.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/enough.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/enough.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/enough.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/enough.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/enough.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/enough.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/enough.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/enough.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/enough.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/enough.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/enough.c"
   ]
  }
 ],
 "846a82a8f36732e391dfb156e9b66f7a26e0f90396f9a717c03dca98702ffe87": [
  "local int log_recover(struct log *log, int op)\n{\n    int fd, ret = 0;\n    unsigned char *data = NULL;\n    size_t len = 0;\n    struct stat st;\n\n    /* log recovery */\n    log_log(log, op, \"start\");\n\n    /* load foo.add file if expected and present */\n    if (op == APPEND_OP || op == COMPRESS_OP) {\n        strcpy(log->end, \".add\");\n        if (stat(log->path, &st) == 0 && st.st_size) {\n            len = (size_t)(st.st_size);\n            if (len != st.st_size || (data = malloc(st.st_size)) == NULL) {\n                log_log(log, op, \"allocation failure\");\n                return -2;\n            }\n            if ((fd = open(log->path, O_RDONLY, 0)) < 0) {\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            ret = read(fd, data, len) != len;\n            close(fd);\n            if (ret) {\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            log_log(log, op, \"loaded .add file\");\n        }\n        else\n            log_log(log, op, \"missing .add file!\");\n    }\n\n    /* recover the interrupted operation */\n    switch (op) {\n    case APPEND_OP:\n        ret = log_append(log, data, len);\n        break;\n    case COMPRESS_OP:\n        ret = log_compress(log, data, len);\n        break;\n    case REPLACE_OP:\n        ret = log_replace(log);\n    }\n\n    /* log status */\n    log_log(log, op, ret ? \"failure\" : \"complete\");\n\n    /* clean up */\n    if (data != NULL)\n        free(data);\n    return ret;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ]
  }
 ],
 "bb78f29e3d2c9b80dad1880f110aec7fe7c6c3543c17abf55c126c6f285f1349": [
  "int gzlog_compress(gzlog *logd)\n{\n    int fd, ret;\n    uint block;\n    size_t len, next;\n    unsigned char *data, buf[5];\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID) || len < 0)\n        return -3;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create space for uncompressed data */\n    len = ((size_t)(log->last - log->first) & ~(((size_t)1 << 10) - 1)) +\n          log->stored;\n    if ((data = malloc(len)) == NULL)\n        return -2;\n\n    /* do statement here is just a cheap trick for error handling */\n    do {\n        /* read in the uncompressed data */\n        if (lseek(log->fd, log->first - 1, SEEK_SET) < 0)\n            break;\n        next = 0;\n        while (next < len) {\n            if (read(log->fd, buf, 5) != 5)\n                break;\n            block = PULL2(buf + 1);\n            if (next + block > len ||\n                read(log->fd, (char *)data + next, block) != block)\n                break;\n            next += block;\n        }\n        if (lseek(log->fd, 0, SEEK_CUR) != log->last + 4 + log->stored)\n            break;\n        log_touch(log);\n\n        /* write the uncompressed data to the .add file */\n        strcpy(log->end, \".add\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        ret = write(fd, data, len) != len;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* write the dictionary for the next compress to the .temp file */\n        strcpy(log->end, \".temp\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        next = DICT > len ? len : DICT;\n        ret = write(fd, (char *)data + len - next, next) != next;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* roll back to compressed data, mark the compress in progress */\n        log->last = log->first;\n        log->stored = 0;\n        if (log_mark(log, COMPRESS_OP))\n            break;\n        BAIL(7);\n\n        /* compress and append the data (clears mark) */\n        ret = log_compress(log, data, len);\n        free(data);\n        return ret;\n    } while (0);\n\n    /* broke out of do above on i/o error */\n    free(data);\n    return -1;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ]
  }
 ],
 "293bfc779b4e6b87d921541ce35bb948222a544e546940a830ea281e83f45702": [
  "int gzlog_write(gzlog *logd, void *data, size_t len)\n{\n    int fd, ret;\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID) || len < 0)\n        return -3;\n    if (data == NULL || len == 0)\n        return 0;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create and write .add file */\n    strcpy(log->end, \".add\");\n    fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (fd < 0)\n        return -1;\n    ret = write(fd, data, len) != len;\n    if (ret | close(fd))\n        return -1;\n    log_touch(log);\n\n    /* mark log file with append in progress */\n    if (log_mark(log, APPEND_OP))\n        return -1;\n    BAIL(8);\n\n    /* append data (clears mark) */\n    if (log_append(log, data, len))\n        return -1;\n\n    /* check to see if it's time to compress -- if not, then done */\n    if (((log->last - log->first) >> 10) + (log->stored >> 10) < TRIGGER)\n        return 0;\n\n    /* time to compress */\n    return gzlog_compress(log);\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/gzlog.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/gzlog.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gzlog.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gzlog.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gzlog.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gzlog.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gzlog.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gzlog.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gzlog.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gzlog.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gzlog.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gzlog.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gzlog.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gzlog.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gzlog.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gzlog.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gzlog.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gzlog.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gzlog.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gzlog.c"
   ]
  }
 ],
 "23bc1535c01264c917e1eea9ba9978565cf71eacc712dbe33fca8f8c18b953d6": [
  "local void bail(char *msg)\n{\n    fprintf(stderr, \"pigz abort: %s\\n\", msg);\n    exit(1);\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "87f6512fc44ff11e93a9ba623abfa6213137c3aff9fb985a4fcfd27c1c5b6ae7": [
  "local size_t readn(int desc, unsigned char *buf, size_t len)\n{\n    ssize_t ret;\n    size_t got;\n\n    got = 0;\n    while (len) {\n        ret = read(desc, buf, len);\n        if (ret < 0)\n            bail(\"read error\");\n        if (ret == 0)\n            break;\n        buf += ret;\n        len -= ret;\n        got += ret;\n    }\n    return got;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "36eb08d8c65e9eea2e731554d5a6cd16b4a59de1a7e3a83e909c6086bedb88bc": [
  "local void writen(int desc, unsigned char *buf, size_t len)\n{\n    ssize_t ret;\n\n    while (len) {\n        ret = write(desc, buf, len);\n        if (ret < 1)\n            bail(\"write error\");\n        buf += ret;\n        len -= ret;\n    }\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "3044231c1bed153d8e45dcc81c765337e47c6af59a53e33100364e8989e88162": [
  "local void flag_init(struct flag *me, int val)\n{\n    me->value = val;\n    pthread_mutex_init(&(me->lock), NULL);\n    pthread_cond_init(&(me->cond), NULL);\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "88188d34ccb5ae5cbbd2eaf736a9625711b0a950882b941064b732ea7931b177": [
  "local void flag_set(struct flag *me, int val)\n{\n    pthread_mutex_lock(&(me->lock));\n    me->value = val;\n    pthread_cond_signal(&(me->cond));\n    pthread_mutex_unlock(&(me->lock));\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "f28e1f4d4a71485535c6c76b7a41055ecdca53cb4aea5c23d08f3b2afdf7b2c6": [
  "local void flag_wait(struct flag *me, int val)\n{\n    pthread_mutex_lock(&(me->lock));\n    while (me->value != val)\n        pthread_cond_wait(&(me->cond), &(me->lock));\n    pthread_mutex_unlock(&(me->lock));\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "c641aceb18473fbb3668ade8be582440765f3435100a954ab5f818013b5d9839": [
  "local void flag_wait_not(struct flag *me, int val)\n{\n    pthread_mutex_lock(&(me->lock));\n    while (me->value == val)\n        pthread_cond_wait(&(me->cond), &(me->lock));\n    pthread_mutex_unlock(&(me->lock));\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "389e74973e9266b3447cfd5000b187c6c9816443c448d993e252e3b58ba8d1e0": [
  "local void flag_done(struct flag *me)\n{\n    pthread_cond_destroy(&(me->cond));\n    pthread_mutex_destroy(&(me->lock));\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "2b0cbde4360b6e82d933e100ca9be57cd6670bb64983d7b91880668a1cda312e": [
  "local void *compress_thread(void *arg)\n{\n    size_t len;                     /* input length for this work unit */\n    unsigned long crc;              /* crc of input data */\n    struct work *prev;              /* previous work unit */\n    struct work *job = arg;         /* work unit for this thread */\n    z_stream *strm = &(job->strm);  /* zlib stream for this work unit */\n\n    /* reset state for a new compressed stream */\n    (void)deflateReset(strm);\n\n    /* initialize input, output, and crc */\n    strm->next_in = job->buf;\n    strm->next_out = job->out;\n    len = job->len;\n    crc = crc32(0L, Z_NULL, 0);\n\n    /* set dictionary if this isn't the first work unit, and if we will be\n       compressing something (the read thread assures that the dictionary\n       data in the previous work unit is still there) */\n    prev = jobs + PREV(job - jobs);\n    if (prev->buf != NULL && len != 0)\n        deflateSetDictionary(strm, prev->buf + (size - DICT), DICT);\n\n    /* run MAX-sized amounts of input through deflate and crc32 -- this loop\n       is needed for those cases where the integer type is smaller than the\n       size_t type, or when len is close to the limit of the size_t type */\n    while (len > MAX) {\n        strm->avail_in = MAX;\n        strm->avail_out = (unsigned)-1;\n        crc = crc32(crc, strm->next_in, strm->avail_in);\n        (void)deflate(strm, Z_NO_FLUSH);\n        len -= MAX;\n    }\n\n    /* run last piece through deflate and crc32, follow with a sync marker */\n    if (len) {\n        strm->avail_in = len;\n        strm->avail_out = (unsigned)-1;\n        crc = crc32(crc, strm->next_in, strm->avail_in);\n        (void)deflate(strm, Z_SYNC_FLUSH);\n    }\n\n    /* don't need to Z_FINISH, since we'd delete the last two bytes anyway */\n\n    /* return result */\n    job->crc = crc;\n    return NULL;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "1d7848157ee87012e8e3b9d474c0207fb490afbd48761e9f7c7a417e87440a4d": [
  "local void *write_thread(void *arg)\n{\n    int n;                          /* compress thread index */\n    size_t len;                     /* length of input processed */\n    unsigned long tot;              /* total uncompressed size (overflow ok) */\n    unsigned long crc;              /* CRC-32 of uncompressed data */\n    unsigned char wrap[10];         /* gzip header or trailer */\n\n    /* write simple gzip header */\n    memcpy(wrap, \"\\037\\213\\10\\0\\0\\0\\0\\0\\0\\3\", 10);\n    wrap[8] = level == 9 ? 2 : (level == 1 ? 4 : 0);\n    writen(outd, wrap, 10);\n\n    /* process output of compress threads until end of input */    \n    tot = 0;\n    crc = crc32(0L, Z_NULL, 0);\n    n = 0;\n    do {\n        /* wait for compress thread to start, then wait to complete */\n        flag_wait(&(jobs[n].busy), COMP);\n        pthread_join(jobs[n].comp, NULL);\n\n        /* now that compress is done, allow read thread to use input buffer */\n        flag_set(&(jobs[n].busy), WRITE);\n\n        /* write compressed data and update length and crc */\n        writen(outd, jobs[n].out, jobs[n].strm.next_out - jobs[n].out);\n        len = jobs[n].len;\n        tot += len;\n        crc = crc32_combine(crc, jobs[n].crc, len);\n\n        /* release this work unit and go to the next work unit */\n        flag_set(&(jobs[n].busy), IDLE);\n        n = NEXT(n);\n\n        /* an input buffer less than size in length indicates end of input */\n    } while (len == size);\n\n    /* write final static block and gzip trailer (crc and len mod 2^32) */\n    wrap[0] = 3;  wrap[1] = 0;\n    PUT4(wrap + 2, crc);\n    PUT4(wrap + 6, tot);\n    writen(outd, wrap, 10);\n    return NULL;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "771d6a5f36efcee5464831f56ee5c121b662cfc4992265e5e9b9c8ed6723272e": [
  "local void job_init(struct work *job)\n{\n    int ret;                        /* deflateInit2() return value */\n\n    job->buf = malloc(size);\n    job->out = malloc(size + (size >> 11) + 10);\n    job->strm.zfree = Z_NULL;\n    job->strm.zalloc = Z_NULL;\n    job->strm.opaque = Z_NULL;\n    ret = deflateInit2(&(job->strm), level, Z_DEFLATED, -15, 8,\n                       Z_DEFAULT_STRATEGY);\n    if (job->buf == NULL || job->out == NULL || ret != Z_OK)\n        bail(\"not enough memory\");\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "7c26a0c385a8570244410523fe02fe687bfe616b5279dd414ff96dda80ddff82": [
  "local void read_thread(void)\n{\n    int n;                          /* general index */\n    size_t got;                     /* amount read */\n    pthread_attr_t attr;            /* thread attributes (left at defaults) */\n    pthread_t write;                /* write thread */\n\n    /* set defaults (not all pthread implementations default to joinable) */\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    /* allocate and set up work list (individual work units will be initialized\n       as needed, in case the input is short), assure that allocation size\n       arithmetic does not overflow */\n    if (size + (size >> 11) + 10 < (size >> 11) + 10 ||\n        (ssize_t)(size + (size >> 11) + 10) < 0 ||\n        ((size_t)0 - 1) / procs <= sizeof(struct work) ||\n        (jobs = malloc(procs * sizeof(struct work))) == NULL)\n        bail(\"not enough memory\");\n    for (n = 0; n < procs; n++) {\n        jobs[n].buf = NULL;\n        flag_init(&(jobs[n].busy), IDLE);\n    }\n\n    /* start write thread */\n    pthread_create(&write, &attr, write_thread, NULL);\n\n    /* read from input and start compress threads (write thread will pick up\n       the output of the compress threads) */\n    n = 0;\n    do {\n        /* initialize this work unit if it's the first time it's used */\n        if (jobs[n].buf == NULL)\n            job_init(jobs + n);\n\n        /* read input data, but wait for last compress on this work unit to be\n           done, and wait for the dictionary to be used by the last compress on\n           the next work unit */\n        flag_wait_not(&(jobs[n].busy), COMP);\n        flag_wait_not(&(jobs[NEXT(n)].busy), COMP);\n        got = readn(ind, jobs[n].buf, size);\n\n        /* start compress thread, but wait for write to be done first */\n        flag_wait(&(jobs[n].busy), IDLE);\n        jobs[n].len = got;\n        pthread_create(&(jobs[n].comp), &attr, compress_thread, jobs + n);\n\n        /* mark work unit so write thread knows compress was started */\n        flag_set(&(jobs[n].busy), COMP);\n\n        /* go to the next work unit */\n        n = NEXT(n);\n\n        /* do until end of input, indicated by a read less than size */\n    } while (got == size);\n\n    /* wait for the write thread to complete -- the write thread will join with\n       all of the compress threads, so this waits for all of the threads to\n       complete */\n    pthread_join(write, NULL);\n\n    /* free up all requested resources and return */\n    for (n = procs - 1; n >= 0; n--) {\n        flag_done(&(jobs[n].busy));\n        (void)deflateEnd(&(jobs[n].strm));\n        free(jobs[n].out);\n        free(jobs[n].buf);\n    }\n    free(jobs);\n    pthread_attr_destroy(&attr);\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "6a738a9d7ae0c1c1b2ca5b74b24bd259af9c6344984a928a76e348344740d363": [
  "int main(int argc, char **argv)\n{\n    int n;                          /* general index */\n    int get;                        /* command line parameters to get */\n    char *arg;                      /* command line argument */\n\n    /* set defaults -- 32 processes and 128K buffers was found to provide\n       good utilization of four cores (about 97%) and balanced the overall\n       execution time impact of more threads against more dictionary\n       processing for a fixed amount of memory -- the memory usage for these\n       settings and full use of all work units (at least 4 MB of input) is\n       16.2 MB\n       */\n    level = Z_DEFAULT_COMPRESSION;\n    procs = 32;\n    size = 131072UL;\n\n    /* process command-line arguments */\n    get = 0;\n    for (n = 1; n < argc; n++) {\n        arg = argv[n];\n        if (*arg == '-') {\n            while (*++arg)\n                if (*arg >= '0' && *arg <= '9')     /* compression level */\n                    level = *arg - '0';\n                else if (*arg == 'b')               /* chunk size in K */\n                    get |= 1;\n                else if (*arg == 'p')               /* number of processes */\n                    get |= 2;\n                else if (*arg == 'h') {             /* help */\n                    fputs(\"usage: pigz [-0..9] [-b blocksizeinK]\", stderr);\n                    fputs(\" [-p processes] < foo > foo.gz\\n\", stderr);\n                    return 0;\n                }\n                else\n                    bail(\"invalid option\");\n        }\n        else if (get & 1) {\n            if (get & 2)\n                bail(\"you need to separate the -b and -p options\");\n            size = (size_t)(atol(arg)) << 10;       /* chunk size */\n            if (size < DICT)\n                bail(\"invalid option\");\n            get = 0;\n        }\n        else if (get & 2) {\n            procs = atoi(arg);                      /* processes */\n            if (procs < 2)\n                bail(\"invalid option\");\n            get = 0;\n        }\n        else\n            bail(\"invalid option (you need to pipe input and output)\");\n    }\n    if (get)\n        bail(\"missing option argument\");\n\n    /* do parallel compression from stdin to stdout (the read thread starts up\n       the write thread and the compression threads, and they all join before\n       the read thread returns) */\n    ind = 0;\n    outd = 1;\n    read_thread();\n\n    /* done */\n    return 0;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "examples/pigz.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "examples/pigz.c"
   ]
  }
 ],
 "cbab4d51000c1616db0a56f3af4407ae569075117651b26294b15321486b1e18": [
  "local int decode(struct state *s, struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n\n    code = first = index = 0;\n    for (len = 1; len <= MAXBITS; len++) {\n        code |= bits(s, 1);             /* get next bit */\n        count = h->count[len];\n        if (code - count < first)       /* if length len, return symbol */\n            return h->symbol[index + (code - first)];\n        index += count;                 /* else update for next length */\n        first += count;\n        first <<= 1;\n        code <<= 1;\n    }\n    return -10;                         /* ran out of codes */\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "cfd85340d73f115ecfb871e2f3ecefd0f045b9272739282126ea02e6f213a854": [
  "local int decode(struct state *s, struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n    int bitbuf;         /* bits from stream */\n    int left;           /* bits left in next or left to process */\n    short *next;        /* next number of codes */\n\n    bitbuf = s->bitbuf;\n    left = s->bitcnt;\n    code = first = index = 0;\n    len = 1;\n    next = h->count + 1;\n    while (1) {\n        while (left--) {\n            code |= bitbuf & 1;\n            bitbuf >>= 1;\n            count = *next++;\n            if (code - count < first) { /* if length len, return symbol */\n                s->bitbuf = bitbuf;\n                s->bitcnt = (s->bitcnt - len) & 7;\n                return h->symbol[index + (code - first)];\n            }\n            index += count;             /* else update for next length */\n            first += count;\n            first <<= 1;\n            code <<= 1;\n            len++;\n        }\n        left = (MAXBITS+1) - len;\n        if (left == 0) break;\n        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */\n        bitbuf = s->in[s->incnt++];\n        if (left > 8) left = 8;\n    }\n    return -10;                         /* ran out of codes */\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "2acd4c5d6a9c2a8f083bfb0ad63f55f27628b8e65bb65ed256ceed505b13fa76": [
  "local int codes(struct state *s,\n                struct huffman *lencode,\n                struct huffman *distcode)\n{\n    int symbol;         /* decoded symbol */\n    int len;            /* length for copy */\n    unsigned dist;      /* distance for copy */\n    static const short lens[29] = { /* Size base for length codes 257..285 */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n    static const short lext[29] = { /* Extra bits for length codes 257..285 */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n    static const short dists[30] = { /* Offset base for distance codes 0..29 */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\n    static const short dext[30] = { /* Extra bits for distance codes 0..29 */\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n    /* decode literals and length/distance pairs */\n    do {\n        symbol = decode(s, lencode);\n        if (symbol < 0) return symbol;  /* invalid symbol */\n        if (symbol < 256) {             /* literal: symbol is the byte */\n            /* write out the literal */\n            if (s->out != NIL) {\n                if (s->outcnt == s->outlen) return 1;\n                s->out[s->outcnt] = symbol;\n            }\n            s->outcnt++;\n        }\n        else if (symbol > 256) {        /* length */\n            /* get and compute length */\n            symbol -= 257;\n            if (symbol >= 29) return -10;       /* invalid fixed code */\n            len = lens[symbol] + bits(s, lext[symbol]);\n\n            /* get and check distance */\n            symbol = decode(s, distcode);\n            if (symbol < 0) return symbol;      /* invalid symbol */\n            dist = dists[symbol] + bits(s, dext[symbol]);\n#ifndef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n            if (dist > s->outcnt)\n                return -11;     /* distance too far back */\n#endif\n\n            /* copy length bytes from distance bytes back */\n            if (s->out != NIL) {\n                if (s->outcnt + len > s->outlen) return 1;\n                while (len--) {\n                    s->out[s->outcnt] =\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                        dist > s->outcnt ? 0 :\n#endif\n                        s->out[s->outcnt - dist];\n                    s->outcnt++;\n                }\n            }\n            else\n                s->outcnt += len;\n        }\n    } while (symbol != 256);            /* end of block symbol */\n\n    /* done with a valid fixed or dynamic block */\n    return 0;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "e7be62651ddf295c559ef9b06328122b15615a43b352a600f82d7c75da6c7ba6": [
  "local int dynamic(struct state *s)\n{\n    int nlen, ndist, ncode;             /* number of lengths in descriptor */\n    int index;                          /* index of lengths[] */\n    int err;                            /* construct() return value */\n    short lengths[MAXCODES];            /* descriptor code lengths */\n    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */\n    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */\n    struct huffman lencode = {lencnt, lensym};          /* length code */\n    struct huffman distcode = {distcnt, distsym};       /* distance code */\n    static const short order[19] =      /* permutation of code length codes */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* get number of lengths in each table, check lengths */\n    nlen = bits(s, 5) + 257;\n    ndist = bits(s, 5) + 1;\n    ncode = bits(s, 4) + 4;\n    if (nlen > MAXLCODES || ndist > MAXDCODES)\n        return -3;                      /* bad counts */\n\n    /* read code length code lengths (really), missing lengths are zero */\n    for (index = 0; index < ncode; index++)\n        lengths[order[index]] = bits(s, 3);\n    for (; index < 19; index++)\n        lengths[order[index]] = 0;\n\n    /* build huffman table for code lengths codes (use lencode temporarily) */\n    err = construct(&lencode, lengths, 19);\n    if (err != 0) return -4;            /* require complete code set here */\n\n    /* read length/literal and distance code length tables */\n    index = 0;\n    while (index < nlen + ndist) {\n        int symbol;             /* decoded value */\n        int len;                /* last length to repeat */\n\n        symbol = decode(s, &lencode);\n        if (symbol < 16)                /* length in 0..15 */\n            lengths[index++] = symbol;\n        else {                          /* repeat instruction */\n            len = 0;                    /* assume repeating zeros */\n            if (symbol == 16) {         /* repeat last length 3..6 times */\n                if (index == 0) return -5;      /* no last length! */\n                len = lengths[index - 1];       /* last length */\n                symbol = 3 + bits(s, 2);\n            }\n            else if (symbol == 17)      /* repeat zero 3..10 times */\n                symbol = 3 + bits(s, 3);\n            else                        /* == 18, repeat zero 11..138 times */\n                symbol = 11 + bits(s, 7);\n            if (index + symbol > nlen + ndist)\n                return -6;              /* too many lengths! */\n            while (symbol--)            /* repeat last or zero symbol times */\n                lengths[index++] = len;\n        }\n    }\n\n    /* check for end-of-block code -- there better be one! */\n    if (lengths[256] == 0)\n        return -9;\n\n    /* build huffman table for literal/length codes */\n    err = construct(&lencode, lengths, nlen);\n    if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))\n        return -7;      /* only allow incomplete codes if just one code */\n\n    /* build huffman table for distance codes */\n    err = construct(&distcode, lengths + nlen, ndist);\n    if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))\n        return -8;      /* only allow incomplete codes if just one code */\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "33e00560c23365af6f09e8e63d538db8412701035034ee5d1213d3b985a95302": [
  "local void *load(char *name, size_t *len)\n{\n    size_t size;\n    void *buf, *swap;\n    FILE *in;\n\n    *len = 0;\n    buf = malloc(size = 4096);\n    if (buf == NULL)\n        return NULL;\n    in = name == NULL ? stdin : fopen(name, \"rb\");\n    if (in != NULL) {\n        for (;;) {\n            *len += fread((char *)buf + *len, 1, size - *len, in);\n            if (*len < size) break;\n            size = bythirds(size);\n            if (size == *len || (swap = realloc(buf, size)) == NULL) {\n                free(buf);\n                buf = NULL;\n                break;\n            }\n            buf = swap;\n        }\n        fclose(in);\n    }\n    return buf;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "8655a2005b92e07dbbbbb451d65cba85bb41de6db614fe1a00f2fd03e55b8baf": [
  "int main(int argc, char **argv)\n{\n    int ret, skip = 0, put = 0;\n    char *arg, *name = NULL;\n    unsigned char *source = NULL, *dest;\n    size_t len = 0;\n    unsigned long sourcelen, destlen;\n\n    /* process arguments */\n    while (arg = *++argv, --argc)\n        if (arg[0] == '-') {\n            if (arg[1] == 'w' && arg[2] == 0)\n                put = 1;\n            else if (arg[1] >= '0' && arg[1] <= '9')\n                skip = atoi(arg + 1);\n            else {\n                fprintf(stderr, \"invalid option %s\\n\", arg);\n                return 3;\n            }\n        }\n        else if (name != NULL) {\n            fprintf(stderr, \"only one file name allowed\\n\");\n            return 3;\n        }\n        else\n            name = arg;\n    source = load(name, &len);\n    if (source == NULL) {\n        fprintf(stderr, \"memory allocation failure\\n\");\n        return 4;\n    }\n    if (len == 0) {\n        fprintf(stderr, \"could not read %s, or it was empty\\n\",\n                name == NULL ? \"<stdin>\" : name);\n        free(source);\n        return 3;\n    }\n    if (skip >= len) {\n        fprintf(stderr, \"skip request of %d leaves no input\\n\", skip);\n        free(source);\n        return 3;\n    }\n\n    /* test inflate data with offset skip */\n    len -= skip;\n    sourcelen = (unsigned long)len;\n    ret = puff(NIL, &destlen, source + skip, &sourcelen);\n    if (ret)\n        fprintf(stderr, \"puff() failed with return code %d\\n\", ret);\n    else {\n        fprintf(stderr, \"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n        if (sourcelen < len) fprintf(stderr, \"%lu compressed bytes unused\\n\",\n                                     len - sourcelen);\n    }\n\n    /* if requested, inflate again and write decompressd data to stdout */\n    if (put) {\n        dest = malloc(destlen);\n        if (dest == NULL) {\n            fprintf(stderr, \"memory allocation failure\\n\");\n            free(source);\n            return 4;\n        }\n        puff(dest, &destlen, source + skip, &sourcelen);\n        fwrite(dest, 1, destlen, stdout);\n        free(dest);\n    }\n\n    /* clean up */\n    free(source);\n    return ret;\n}",
  {
   "v1.2.3.4": [
    "2011-09-09 23:26:40",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/puff/puff.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/puff/puff.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/puff/puff.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "f9d247bc99b0e1513cd95c0db4c25ff7ad5d3d85d70d1b8262183ce4635d0da0": [
  "void do_banner()\n{\n    printf(\"MiniZip64 1.0, demo of zLib + MiniZip64 package, written by Gilles Vollant\\n\");\n    printf(\"more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\\n\\n\");\n    printf(\"more info on MiniZip64 at http://result42.com/projects/MiniZip64\\n\\n\");\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/minizip.c"
   ]
  }
 ],
 "b2b0476e35e4bc7ed413954e1bd4b184769143dc64a8267adc84e51f4cf97021": [
  "int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)\n{\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = fopen64(filenameinzip,\"rb\");\n   unsigned long size_read = 0;\n   unsigned long total_read = 0;\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = (int)fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32(calculate_crc,buf,size_read);\n            total_read += size_read;\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\", filenameinzip, calculate_crc);\n    return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/minizip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "bb2a38edfcaf36b9b567b50e17fe8e4cfb51992c1f35f5dd2b7c491d38fb894e": [
  "int isLargeFile(const char* filename)\n{\n  int largeFile = 0;\n  ZPOS64_T pos = 0;\n  FILE* pFile = fopen64(filename, \"rb\");\n\n  if(pFile != NULL)\n  {\n    int n = fseeko64(pFile, 0, SEEK_END);\n\n    pos = ftello64(pFile);\n    \n\t\tprintf(\"File : %s is %lld bytes\\n\", filename, pos);\n    \n    if(pos >= 0xffffffff)\n     largeFile = 1;\n\n\t\tfclose(pFile);\n  }\n  \n return largeFile;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/minizip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/minizip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/minizip.c"
   ]
  }
 ],
 "d75e2e03888fce1c8d908d57fbf168009cb3c19c92a8e988cbb7ec256c6f2455": [
  "int LoadCentralDirectoryRecord(zip64_internal* pziinit)\n{\n  int err=ZIP_OK;\n  ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n\n  ZPOS64_T size_central_dir;     /* size of the central directory  */\n  ZPOS64_T offset_central_dir;   /* offset of start of central directory */\n  ZPOS64_T central_pos;\n  uLong uL;\n\n  uLong number_disk;          /* number of the current dist, used for\n                              spaning ZIP, unsupported, always 0*/\n  uLong number_disk_with_CD;  /* number the the disk with central dir, used\n                              for spaning ZIP, unsupported, always 0*/\n  ZPOS64_T number_entry;\n  ZPOS64_T number_entry_CD;      /* total number of entries in\n                                the central dir\n                                (same than number_entry on nospan) */\n  uLong VersionMadeBy;\n  uLong VersionNeeded;\n  uLong size_comment;\n\n  int hasZIP64Record = 0;\n\n  // check first if we find a ZIP64 record\n  central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);\n  if(central_pos > 0)\n  {\n    hasZIP64Record = 1;\n  }\n  else if(central_pos == 0)\n  {\n    central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);\n  }\n\n/* disable to allow appending to empty ZIP archive\n        if (central_pos==0)\n            err=ZIP_ERRNO;\n*/\n\n  if(hasZIP64Record)\n  {\n    ZPOS64_T sizeEndOfCentralDirectory;\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* size of zip64 end of central directory record */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version made by */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version needed to extract */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory on this disk */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* offset of start of central directory with respect to the\n    starting disk number */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    // TODO..\n    // read the comment from the standard central header.\n    size_comment = 0;\n  }\n  else\n  {\n    // Read End of central Directory info\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central dir on this disk */\n    number_entry = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      number_entry = uL;\n\n    /* total number of entries in the central dir */\n    number_entry_CD = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else \n      number_entry_CD = uL;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    size_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      size_central_dir = uL;\n\n    /* offset of start of central directory with respect to the starting disk number */\n    offset_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      offset_central_dir = uL;\n\n\n    /* zipfile global comment length */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)\n      err=ZIP_ERRNO;\n  }\n\n  if ((central_pos<offset_central_dir+size_central_dir) &&\n    (err==ZIP_OK))\n    err=ZIP_BADZIPFILE;\n\n  if (err!=ZIP_OK)\n  {\n    ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);\n    return ZIP_ERRNO;\n  }\n\n  if (size_comment>0)\n  {\n    pziinit->globalcomment = (char*)ALLOC(size_comment+1);\n    if (pziinit->globalcomment)\n    {\n      size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);\n      pziinit->globalcomment[size_comment]=0;\n    }\n  }\n\n  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);\n  pziinit->add_position_when_writting_offset = byte_before_the_zipfile;\n\n  {\n    ZPOS64_T size_central_dir_to_read = size_central_dir;\n    size_t buf_size = SIZEDATA_INDATABLOCK;\n    void* buf_read = (void*)ALLOC(buf_size);\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    while ((size_central_dir_to_read>0) && (err==ZIP_OK))\n    {\n      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;\n      if (read_this > size_central_dir_to_read)\n        read_this = size_central_dir_to_read;\n\n      if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)\n        err=ZIP_ERRNO;\n\n      if (err==ZIP_OK)\n        err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);\n\n      size_central_dir_to_read-=read_this;\n    }\n    TRYFREE(buf_read);\n  }\n  pziinit->begin_pos = byte_before_the_zipfile;\n  pziinit->number_entry = number_entry_CD;\n\n  if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)\n    err=ZIP_ERRNO;\n\n  return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "dc765df028d3edf135849e07fb09338cefa46f6b00c5cf538ead0a45c377998f": [
  "extern zipFile ZEXPORT zipOpen3 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def)\n{\n    zip64_internal ziinit;\n    zip64_internal* zi;\n    int err=ZIP_OK;\n\n    ziinit.z_filefunc.zseek32_file = NULL;\n    ziinit.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);\n    else\n        ziinit.z_filefunc = *pzlib_filefunc64_32_def;\n\n    ziinit.filestream = ZOPEN64(ziinit.z_filefunc,\n                  pathname,\n                  (append == APPEND_STATUS_CREATE) ?\n                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :\n                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));\n\n    if (ziinit.filestream == NULL)\n        return NULL;\n\n    if (append == APPEND_STATUS_CREATEAFTER)\n        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);\n\n    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);\n    ziinit.in_opened_file_inzip = 0;\n    ziinit.ci.stream_initialised = 0;\n    ziinit.number_entry = 0;\n    ziinit.add_position_when_writting_offset = 0;\n    init_linkedlist(&(ziinit.central_dir));\n\n\n\n    zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));\n    if (zi==NULL)\n    {\n        ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);\n        return NULL;\n    }\n\n    /* now we add file in a zipfile */\n#    ifndef NO_ADDFILEINEXISTINGZIP\n    ziinit.globalcomment = NULL;\n    if (append == APPEND_STATUS_ADDINZIP)\n    {\n      // Read and Cache Central Directory Records\n      err = LoadCentralDirectoryRecord(&ziinit);\n    }\n\n    if (globalcomment)\n    {\n      *globalcomment = ziinit.globalcomment;\n    }\n#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n\n    if (err != ZIP_OK)\n    {\n#    ifndef NO_ADDFILEINEXISTINGZIP\n        TRYFREE(ziinit.globalcomment);\n#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n        TRYFREE(zi);\n        return NULL;\n    }\n    else\n    {\n        *zi = ziinit;\n        return (zipFile)zi;\n    }\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "ee1cac6348ae1f101f1e0f656686efc1c77b8796ba3b04a1c2c6ab97423ee806": [
  "extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_size, uLong crc32)\n{\n    zip64_internal* zi;\n    ZPOS64_T compressed_size;\n    uLong invalidValue = 0xffffffff;\n    short datasize = 0;\n    int err=ZIP_OK;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 0)\n        return ZIP_PARAMERROR;\n    zi->ci.stream.avail_in = 0;\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n\t\t{\n\t\t\twhile (err==ZIP_OK)\n\t\t\t{\n\t\t\t\tuLong uTotalOutBefore;\n\t\t\t\tif (zi->ci.stream.avail_out == 0)\n\t\t\t\t{\n\t\t\t\t\tif (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n\t\t\t\t\t\terr = ZIP_ERRNO;\n\t\t\t\t\tzi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n\t\t\t\t\tzi->ci.stream.next_out = zi->ci.buffered_data;\n\t\t\t\t}\n\t\t\t\tuTotalOutBefore = zi->ci.stream.total_out;\n\t\t\t\terr=deflate(&zi->ci.stream,  Z_FINISH);\n\t\t\t\tzi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n\t\t\t}\n\t\t}\n    else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n#ifdef HAVE_BZIP2\n      err = BZ_FINISH_OK;\n      while (err==BZ_FINISH_OK)\n      {\n        uLong uTotalOutBefore;\n        if (zi->ci.bstream.avail_out == 0)\n        {\n          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n            err = ZIP_ERRNO;\n          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;\n          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;\n        }\n        uTotalOutBefore = zi->ci.bstream.total_out_lo32;\n        err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);\n        if(err == BZ_STREAM_END)\n          err = Z_STREAM_END;\n\n        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);\n      }\n\n      if(err == BZ_FINISH_OK)\n        err = ZIP_OK;\n#endif\n    }\n\n    if (err==Z_STREAM_END)\n        err=ZIP_OK; /* this is normal */\n\n    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))\n\t\t{\n        if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)\n            err = ZIP_ERRNO;\n\t\t}\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n    {\n        int tmp_err = deflateEnd(&zi->ci.stream);\n        if (err == ZIP_OK) \n            err = tmp_err;\n        zi->ci.stream_initialised = 0;\n    }\n#ifdef HAVE_BZIP2\n    else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n      int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);\n\t\t\tif (err==ZIP_OK) \n\t\t\t\terr = tmperr;\n\t\t\tzi->ci.stream_initialised = 0;\n    }\n#endif\n\n    if (!zi->ci.raw)\n    {\n        crc32 = (uLong)zi->ci.crc32;\n        uncompressed_size = zi->ci.totalUncompressedData;\n    }\n    compressed_size = zi->ci.totalCompressedData;\n\n#    ifndef NOCRYPT\n    compressed_size += zi->ci.crypt_header_size;\n#    endif\n\n    // update Current Item crc and sizes,\n    if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)\n    {\n      /*version Made by*/\n      zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);\n      /*version needed*/\n      zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);\n\n    }\n\n    zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/\n\n\n    if(compressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/\n\n    /// set internal file attributes field\n    if (zi->ci.stream.data_type == Z_ASCII)\n        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);\n\n    if(uncompressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/\n\n    // Add ZIP64 extra info field for uncompressed size\n    if(uncompressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for compressed size\n    if(compressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for relative offset to local file header of current file\n    if(zi->ci.pos_local_header >= 0xffffffff)\n      datasize += 8;\n\n    if(datasize > 0)\n    {\n      char* p = NULL;\n\n      if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)\n      {\n        // we can not write more data to the buffer that we have room for.\n        return ZIP_BADZIPFILE;\n      }\n\n      p = zi->ci.central_header + zi->ci.size_centralheader;\n\n      // Add Extra Information Header for 'ZIP64 information'\n      zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID\n      p += 2;\n      zip64local_putValue_inmemory(p, datasize, 2); // DataSize\n      p += 2;\n      \n      if(uncompressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, uncompressed_size, 8);\n        p += 8;\n      }\n\n      if(compressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, compressed_size, 8);\n        p += 8;\n      }\n\n      if(zi->ci.pos_local_header >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);\n        p += 8;\n      }\n      \n      // Update how much extra free space we got in the memory buffer\n      // and increase the centralheader size so the new ZIP64 fields are included\n      // ( 4 below is the size of HeaderID and DataSize field )\n      zi->ci.size_centralExtraFree -= datasize + 4;\n      zi->ci.size_centralheader += datasize + 4;\n\n      // Update the extra info size field\n      zi->ci.size_centralExtra += datasize + 4;\n      zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);\n    }\n    \n    if (err==ZIP_OK)\n        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);\n\n    free(zi->ci.central_header);\n\n    if (err==ZIP_OK)\n    {\n        // Update the LocalFileHeader with the new values.\n\n        ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n\n        if (err==ZIP_OK)\n            err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */\n\n        if(uncompressed_size >= 0xffffffff)\n        {\n          if(zi->ci.pos_zip64extrainfo > 0)\n          {\n            // Update the size in the ZIP64 extended field.\n            if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)\n              err = ZIP_ERRNO;\n\n            if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);\n\n            if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);\n          }\n        }\n        else\n        {\n          if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);\n\n          if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);\n        }\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n    }\n\n    zi->number_entry ++;\n    zi->in_opened_file_inzip = 0;\n\n    return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "5a172688948722a36b80eaf45462527e38d4d112c2a9046621c768df5daeaf57": [
  "int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)\n{\n  int err = ZIP_OK;\n  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;\n  \n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);\n  \n  /*num disks*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  /*relative offset*/\n    if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);\n\n  /*total disks*/ /* Do not support spawning of disk so always say 1 here*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);\n\n    return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "c409747a8994b5995d147d164d38bd60d5cd1ee4004fa4ca34ddedb171293a8c": [
  "int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)\n{\n  int err = ZIP_OK;\n\n  uLong Zip64DataSize = 44;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?\n\n  if (err==ZIP_OK) /* version made by */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* version needed */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);\n  }\n  return err;  \n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "089fd48bc1be3ff42ab92a8ab44e051548aff0823bec6b4c91cc0f25e796acbf": [
  "int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)\n{\n  int err = ZIP_OK;\n  \n  /*signature*/\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n  {\n    {\n      if(zi->number_entry >= 0xFFFF)\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n      else\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n    }\n  }\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n  {\n    if(zi->number_entry >= 0xFFFF)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n  }\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;\n    if(pos >= 0xffffffff)\n    {\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);\n    }\n    else\n\t\t  err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);\n  }\n\n   return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "62a558bf767af108e50775c8a9d9c6760ad1d891b05d6b397f0d786741275a85": [
  "extern int ZEXPORT zipClose (zipFile file, const char* global_comment)\n{\n    zip64_internal* zi;\n    int err = 0;\n    uLong size_centraldir = 0;\n    ZPOS64_T centraldir_pos_inzip;\n    ZPOS64_T pos;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 1)\n    {\n        err = zipCloseFileInZip (file);\n    }\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    if (global_comment==NULL)\n        global_comment = zi->globalcomment;\n#endif\n  \n    centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n    if (err==ZIP_OK)\n    {\n        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;\n        while (ldi!=NULL)\n        {\n            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))\n            {\n                if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)\n                    err = ZIP_ERRNO;\n            }\n\n            size_centraldir += ldi->filled_in_this_block;\n            ldi = ldi->next_datablock;\n        }\n    }\n    free_linkedlist(&(zi->central_dir));\n\n    pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;\n    if(pos >= 0xffffffff)\n    {\n      ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);\n      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n      \n      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);\n    }\n\n    if (err==ZIP_OK)\n      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n\n    if(err == ZIP_OK)\n      err = Write_GlobalComment(zi, global_comment);\n\n    if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)\n        if (err == ZIP_OK)\n            err = ZIP_ERRNO;\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    TRYFREE(zi->globalcomment);\n#endif\n    TRYFREE(zi);\n\n    return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/zip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/zip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "cd423780779c5ffbcffe67f74dc8e742d25e5376f1eef29c9109cc2bbc07c39e": [
  "local int unz64local_GetCurrentFileInfoInternal (unzFile file,\n                                                  unz_file_info64 *pfile_info,\n                                                  unz_file_info64_internal\n                                                  *pfile_info_internal,\n                                                  char *szFileName,\n                                                  uLong fileNameBufferSize,\n                                                  void *extraField,\n                                                  uLong extraFieldBufferSize,\n                                                  char *szComment,\n                                                  uLong commentBufferSize)\n{\n    unz64_s* s;\n    unz_file_info64 file_info;\n    unz_file_info64_internal file_info_internal;\n    int err=UNZ_OK;\n    uLong uMagic;\n    long lSeek=0;\n    uLong uL;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (ZSEEK64(s->z_filefunc, s->filestream,\n              s->pos_in_central_dir+s->byte_before_the_zipfile,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n\n    /* we check the magic */\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x02014b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.compressed_size = uL;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.uncompressed_size = uL;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n\t\t// relative offset of local header\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info_internal.offset_curfile = uL;\n\n    lSeek+=file_info.size_filename;\n    if ((err==UNZ_OK) && (szFileName!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_filename<fileNameBufferSize)\n        {\n            *(szFileName+file_info.size_filename)='\\0';\n            uSizeRead = file_info.size_filename;\n        }\n        else\n            uSizeRead = fileNameBufferSize;\n\n        if ((file_info.size_filename>0) && (fileNameBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek -= uSizeRead;\n    }\n\n    // Read extrafield\n    if ((err==UNZ_OK) && (extraField!=NULL))\n    {\n        ZPOS64_T uSizeRead ;\n        if (file_info.size_file_extra<extraFieldBufferSize)\n            uSizeRead = file_info.size_file_extra;\n        else\n            uSizeRead = extraFieldBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n\n        lSeek += file_info.size_file_extra - (uLong)uSizeRead;\n    }\n    else\n        lSeek += file_info.size_file_extra;\n\n\n    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))\n    {\n\t\t\t\tuLong acc = 0;\n        \n        // since lSeek now points to after the extra field we need to move back\n        lSeek -= file_info.size_file_extra;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        while(acc < file_info.size_file_extra)\n        {\n            uLong headerId;\n\t\t\t\t\t\tuLong dataSize;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            /* ZIP64 extra fields */\n            if (headerId == 0x0001)\n            {\n\t\t\t\t\t\t\tuLong uL;\n\n\t\t\t\t\t\t\t\tif(file_info.uncompressed_size == (ZPOS64_T)(unsigned long)-1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)\n\t\t\t\t\t\t\t\t\t\t\terr=UNZ_ERRNO;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(file_info.compressed_size == (ZPOS64_T)(unsigned long)-1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)\n\t\t\t\t\t\t\t\t\t\t  err=UNZ_ERRNO;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(file_info_internal.offset_curfile == (ZPOS64_T)(unsigned long)-1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/* Relative Header offset */\n\t\t\t\t\t\t\t\t\tif (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)\n\t\t\t\t\t\t\t\t\t\terr=UNZ_ERRNO;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(file_info.disk_num_start == (unsigned long)-1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/* Disk Start Number */\n\t\t\t\t\t\t\t\t\tif (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n\t\t\t\t\t\t\t\t\t\terr=UNZ_ERRNO;\n\t\t\t\t\t\t\t\t}\n\n            }\n            else\n            {\n                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)\n                    err=UNZ_ERRNO;\n            }\n\n            acc += 2 + 2 + dataSize;\n        }\n    }\n\n    if ((err==UNZ_OK) && (szComment!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_file_comment<commentBufferSize)\n        {\n            *(szComment+file_info.size_file_comment)='\\0';\n            uSizeRead = file_info.size_file_comment;\n        }\n        else\n            uSizeRead = commentBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_comment>0) && (commentBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek+=file_info.size_file_comment - uSizeRead;\n    }\n    else\n        lSeek+=file_info.size_file_comment;\n\n\n    if ((err==UNZ_OK) && (pfile_info!=NULL))\n        *pfile_info=file_info;\n\n    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n        *pfile_info_internal=file_info_internal;\n\n    return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "4825fbad559918fd2c6f12f46be89ba237a9de6701abafe85b1517c3a449a412": [
  "extern int ZEXPORT unzGetCurrentFileInfo (unzFile file,\n                                          unz_file_info * pfile_info,\n                                          char * szFileName, uLong fileNameBufferSize,\n                                          void *extraField, uLong extraFieldBufferSize,\n                                          char* szComment,  uLong commentBufferSize)\n{\n    int err;\n    unz_file_info64 file_info64;\n    err = unz64local_GetCurrentFileInfoInternal(file,&file_info64,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n    if (err==UNZ_OK)\n    {\n        pfile_info->version = file_info64.version;\n        pfile_info->version_needed = file_info64.version_needed;\n        pfile_info->flag = file_info64.flag;\n        pfile_info->compression_method = file_info64.compression_method;\n        pfile_info->dosDate = file_info64.dosDate;\n        pfile_info->crc = file_info64.crc;\n\n        pfile_info->size_filename = file_info64.size_filename;\n        pfile_info->size_file_extra = file_info64.size_file_extra;\n        pfile_info->size_file_comment = file_info64.size_file_comment;\n\n        pfile_info->disk_num_start = file_info64.disk_num_start;\n        pfile_info->internal_fa = file_info64.internal_fa;\n        pfile_info->external_fa = file_info64.external_fa;\n\n        pfile_info->tmu_date = file_info64.tmu_date,\n\n\n        pfile_info->compressed_size = (uLong)file_info64.compressed_size;\n        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;\n\n    }\n    return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "1a9c9a32b69e70b0acd57e7330af107771fd2f5d4574343daec250890036e543": [
  "extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)\n{\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->read_buffer == NULL))\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n            \n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return iRead;\n    return err;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "039edc82a30b838477426ad2d5396564acfb3f59a82aa8c0f107d3fd864b0cdd": [
  "extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)\n{\n    unz64_s* s;\n    uLong uReadThis ;\n    if (file==NULL)\n        return (uLong)UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    uReadThis = uSizeBuf;\n    if (uReadThis>s->gi.size_comment)\n        uReadThis = s->gi.size_comment;\n\n    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (uReadThis>0)\n    {\n      *szComment='\\0';\n      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)\n        return UNZ_ERRNO;\n    }\n\n    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n        *(szComment+s->gi.size_comment)='\\0';\n    return (int)uReadThis;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/unzip.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/unzip.c"
   ]
  }
 ],
 "a5c63b249d3e317a072aac82e40805a50f065e55e33c9c66d7fc02c2ce4fd02a": [
  "ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)\n{\n    if (pfilefunc->zfile_func64.zseek64_file != NULL)\n        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);\n    else\n    {\n        uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);\n        if ((tell_uLong) == ((uLong)-1))\n            return (ZPOS64_T)-1;\n        else\n            return tell_uLong;\n    }\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "a6f246d23f4ad35d249d340f9f3007d9f80a940254c0b3349aea4015ed8b51cf": [
  "static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)\n{\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = fopen64((const char*)filename, mode_fopen);\n    return file;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "1d4a3d4dff9cfe39df0bb8960eb6464ca556fb7a3537f402d45e7c460410e183": [
  "static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)\n{\n    ZPOS64_T ret;\n    ret = ftello64((FILE *)stream);\n    return ret;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "b9339f0344bef02683bf95f94a63f0e60fd30d2fd980f5de661f316d5f229db0": [
  "static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)\n{\n    int fseek_origin=0;\n    long ret;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n\n    if(fseeko64((FILE *)stream, offset, fseek_origin) != 0)\n\t\t\tret = -1;\n\n    return ret;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/ioapi.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/ioapi.c"
   ]
  }
 ],
 "cf8f8da97b0b45c147f56b5e612bc70e23581ecf6b7f7113a6aa1a6e7c3ba8ab": [
  "voidpf ZCALLBACK win32_open64_file_func (voidpf opaque,const void* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "f5e50bb81f92620e71b55558cee34653749be24b6f8752761af23016f52ded1a": [
  "voidpf ZCALLBACK win32_open64_file_funcA (voidpf opaque,const void* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFileA((LPCSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "155e32b292cd2a735ebc161081f35878ce23e8c320d04852eaab6cc4801df693": [
  "voidpf ZCALLBACK win32_open64_file_funcW (voidpf opaque,const void* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFileW((LPCWSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "87ac05a6619cc49c9e246e50d75e68e5d6a7396242aef9468d8dac5e849d12d9": [
  "voidpf ZCALLBACK win32_open_file_func (voidpf opaque,const char* filename,int mode)\n{\n    const char* mode_fopen = NULL;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n\n    return win32_build_iowin(hFile);\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "de9a1f38c9288bbc232ad8b149c6045caaffa9ad05f9e7483ad8ff3e5494af6a": [
  "long ZCALLBACK win32_tell_file_func (voidpf opaque,voidpf stream)\n{\n    long ret=-1;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n    if (hFile != NULL)\n    {\n        DWORD dwSet = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);\n        if (dwSet == INVALID_SET_FILE_POINTER)\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=(long)dwSet;\n    }\n    return ret;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "6bf567d393161b11837ef12362d616d7980101abe73ba9165925704eaf61cead": [
  "ZPOS64_T ZCALLBACK win32_tell64_file_func (voidpf opaque, voidpf stream)\n{\n    ZPOS64_T ret= (ZPOS64_T)-1;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream)->hf;\n\n    if (hFile)\n    {\n        LARGE_INTEGER li;\n        li.QuadPart = 0;\n        li.u.LowPart = SetFilePointer(hFile, li.u.LowPart, &li.u.HighPart, FILE_CURRENT);\n        if ( (li.LowPart == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = (ZPOS64_T)-1;\n        }\n        else\n            ret=li.QuadPart;\n    }\n    return ret;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "107d644b736483095bc6fb88aa190b180fa5098eb2ca8b2fc221a96d653ea1aa": [
  "long ZCALLBACK win32_seek_file_func (voidpf opaque,voidpf stream,uLong offset,int origin)\n{\n    DWORD dwMoveMethod=0xFFFFFFFF;\n    HANDLE hFile = NULL;\n\n    long ret=-1;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        dwMoveMethod = FILE_CURRENT;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        dwMoveMethod = FILE_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        dwMoveMethod = FILE_BEGIN;\n        break;\n    default: return -1;\n    }\n\n    if (hFile != NULL)\n    {\n        DWORD dwSet = SetFilePointer(hFile, offset, NULL, dwMoveMethod);\n        if (dwSet == INVALID_SET_FILE_POINTER)\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=0;\n    }\n    return ret;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "1403a5cdee9669899cfc716ec1eea039c27fbde49cb52af7746a07606e0a6905": [
  "long ZCALLBACK win32_seek64_file_func (voidpf opaque, voidpf stream,ZPOS64_T offset,int origin)\n{\n    DWORD dwMoveMethod=0xFFFFFFFF;\n    HANDLE hFile = NULL;\n    long ret=-1;\n\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream)->hf;\n\n    switch (origin)\n    {\n        case ZLIB_FILEFUNC_SEEK_CUR :\n            dwMoveMethod = FILE_CURRENT;\n            break;\n        case ZLIB_FILEFUNC_SEEK_END :\n            dwMoveMethod = FILE_END;\n            break;\n        case ZLIB_FILEFUNC_SEEK_SET :\n            dwMoveMethod = FILE_BEGIN;\n            break;\n        default: return -1;\n    }\n\n    if (hFile)\n    {\n        LARGE_INTEGER* li = (LARGE_INTEGER*)&offset;\n        DWORD dwSet = SetFilePointer(hFile, li->u.LowPart, &li->u.HighPart, dwMoveMethod);\n        if (dwSet == INVALID_SET_FILE_POINTER)\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=0;\n    }\n    return ret;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/iowin32.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "db70576f996ce2fa0c5e7fcb34e96faf1aac43e436f5e4286de1167adf296adc": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n    va_list va;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(state->in, format, va);\n    va_end(va);\n    for (len = 0; len < state->in; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf(state->in, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(state->in, size, format, va);\n    va_end(va);\n    len = strlen(state->in);\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* write out result of printf() */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->pos += len;\n    if (gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n    return len;\n}",
  {
   "v1.2.3.5": [
    "2011-09-09 23:26:49",
    "gzwrite.c"
   ]
  }
 ],
 "ba46cd840abfbe34b1126477cd969027791464af88bd9a72a5212c7306c92de5": [
  "local int lunpipe(unsigned have, unsigned char *next, struct ind *indp,\n                  int outfile, z_stream *strm)\n{\n    int last;                   /* last byte read by NEXT(), or -1 if EOF */\n    unsigned chunk;             /* bytes left in current chunk */\n    int left;                   /* bits left in rem */\n    unsigned rem;               /* unused bits from input */\n    int bits;                   /* current bits per code */\n    unsigned code;              /* code, table traversal index */\n    unsigned mask;              /* mask for current bits codes */\n    int max;                    /* maximum bits per code for this stream */\n    unsigned flags;             /* compress flags, then block compress flag */\n    unsigned end;               /* last valid entry in prefix/suffix tables */\n    unsigned temp;              /* current code */\n    unsigned prev;              /* previous code */\n    unsigned final;             /* last character written for previous code */\n    unsigned stack;             /* next position for reversed string */\n    unsigned outcnt;            /* bytes in output buffer */\n    struct outd outd;           /* output structure */\n    unsigned char *p;\n\n    /* set up output */\n    outd.outfile = outfile;\n    outd.check = 0;\n\n    /* process remainder of compress header -- a flags byte */\n    flags = NEXT();\n    if (last == -1)\n        return Z_BUF_ERROR;\n    if (flags & 0x60) {\n        strm->msg = (char *)\"unknown lzw flags set\";\n        return Z_DATA_ERROR;\n    }\n    max = flags & 0x1f;\n    if (max < 9 || max > 16) {\n        strm->msg = (char *)\"lzw bits out of range\";\n        return Z_DATA_ERROR;\n    }\n    if (max == 9)                           /* 9 doesn't really mean 9 */\n        max = 10;\n    flags &= 0x80;                          /* true if block compress */\n\n    /* clear table */\n    bits = 9;\n    mask = 0x1ff;\n    end = flags ? 256 : 255;\n\n    /* set up: get first 9-bit code, which is the first decompressed byte, but\n       don't create a table entry until the next code */\n    if (NEXT() == -1)                       /* no compressed data is ok */\n        return Z_OK;\n    final = prev = (unsigned)last;          /* low 8 bits of code */\n    if (NEXT() == -1)                       /* missing a bit */\n        return Z_BUF_ERROR;\n    if (last & 1) {                         /* code must be < 256 */\n        strm->msg = (char *)\"invalid lzw code\";\n        return Z_DATA_ERROR;\n    }\n    rem = (unsigned)last >> 1;              /* remaining 7 bits */\n    left = 7;\n    chunk = bits - 2;                       /* 7 bytes left in this chunk */\n    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */\n    outcnt = 1;\n\n    /* decode codes */\n    stack = 0;\n    for (;;) {\n        /* if the table will be full after this, increment the code size */\n        if (end >= mask && bits < max) {\n            FLUSHCODE();\n            bits++;\n            mask <<= 1;\n            mask++;\n        }\n\n        /* get a code of length bits */\n        if (chunk == 0)                     /* decrement chunk modulo bits */\n            chunk = bits;\n        code = rem;                         /* low bits of code */\n        if (NEXT() == -1) {                 /* EOF is end of compressed data */\n            /* write remaining buffered output */\n            if (outcnt && out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf;     /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            return Z_OK;\n        }\n        code += (unsigned)last << left;     /* middle (or high) bits of code */\n        left += 8;\n        chunk--;\n        if (bits > left) {                  /* need more bits */\n            if (NEXT() == -1)               /* can't end in middle of code */\n                return Z_BUF_ERROR;\n            code += (unsigned)last << left; /* high bits of code */\n            left += 8;\n            chunk--;\n        }\n        code &= mask;                       /* mask to current code length */\n        left -= bits;                       /* number of unused bits */\n        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */\n\n        /* process clear code (256) */\n        if (code == 256 && flags) {\n            FLUSHCODE();\n            bits = 9;                       /* initialize bits and mask */\n            mask = 0x1ff;\n            end = 255;                      /* empty table */\n            continue;                       /* get next code */\n        }\n\n        /* special code to reuse last match */\n        temp = code;                        /* save the current code */\n        if (code > end) {\n            /* Be picky on the allowed code here, and make sure that the code\n               we drop through (prev) will be a valid index so that random\n               input does not cause an exception.  The code != end + 1 check is\n               empirically derived, and not checked in the original uncompress\n               code.  If this ever causes a problem, that check could be safely\n               removed.  Leaving this check in greatly improves gun's ability\n               to detect random or corrupted input after a compress header.\n               In any case, the prev > end check must be retained. */\n            if (code != end + 1 || prev > end) {\n                strm->msg = (char *)\"invalid lzw code\";\n                return Z_DATA_ERROR;\n            }\n            match[stack++] = (unsigned char)final;\n            code = prev;\n        }\n\n        /* walk through linked list to generate output in reverse order */\n        p = match + stack;\n        while (code >= 256) {\n            *p++ = suffix[code];\n            code = prefix[code];\n        }\n        stack = p - match;\n        match[stack++] = (unsigned char)code;\n        final = code;\n\n        /* link new table entry */\n        if (end < mask) {\n            end++;\n            prefix[end] = (unsigned short)prev;\n            suffix[end] = (unsigned char)final;\n        }\n\n        /* set previous code for next iteration */\n        prev = temp;\n\n        /* write output in forward order */\n        while (stack > SIZE - outcnt) {\n            while (outcnt < SIZE)\n                outbuf[outcnt++] = match[--stack];\n            if (out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf; /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            outcnt = 0;\n        }\n        p = match + stack;\n        do {\n            outbuf[outcnt++] = *--p;\n        } while (p > match);\n        stack = 0;\n\n        /* loop for next code with final and prev as the last match, rem and\n           left provide the first 0..7 bits of the next code, end is the last\n           valid table entry */\n    }\n}",
  {
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gun.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gun.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gun.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gun.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gun.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gun.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gun.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gun.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gun.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gun.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gun.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gun.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gun.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gun.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gun.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gun.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gun.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gun.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gun.c"
   ]
  }
 ],
 "efc6164889b552ac0a4b8a847372f52007f849d8d8876bfb93b50ce21557097a": [
  "local int gunpipe(z_stream *strm, int infile, int outfile)\n{\n    int ret, first, last;\n    unsigned have, flags, len;\n    unsigned char *next = NULL;\n    struct ind ind, *indp;\n    struct outd outd;\n\n    /* setup input buffer */\n    ind.infile = infile;\n    ind.inbuf = inbuf;\n    indp = &ind;\n\n    /* decompress concatenated gzip streams */\n    have = 0;                               /* no input data read in yet */\n    first = 1;                              /* looking for first gzip header */\n    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */\n    for (;;) {\n        /* look for the two magic header bytes for a gzip stream */\n        if (NEXT() == -1) {\n            ret = Z_OK;\n            break;                          /* empty gzip stream is ok */\n        }\n        if (last != 31 || (NEXT() != 139 && last != 157)) {\n            strm->msg = (char *)\"incorrect header check\";\n            ret = first ? Z_DATA_ERROR : Z_ERRNO;\n            break;                          /* not a gzip or compress header */\n        }\n        first = 0;                          /* next non-header is junk */\n\n        /* process a compress (LZW) file -- can't be concatenated after this */\n        if (last == 157) {\n            ret = lunpipe(have, next, indp, outfile, strm);\n            break;\n        }\n\n        /* process remainder of gzip header */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != 8) {                  /* only deflate method allowed */\n            if (last == -1) break;\n            strm->msg = (char *)\"unknown compression method\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        flags = NEXT();                     /* header flags */\n        NEXT();                             /* discard mod time, xflgs, os */\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        if (last == -1) break;\n        if (flags & 0xe0) {\n            strm->msg = (char *)\"unknown header flags set\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        if (flags & 4) {                    /* extra field */\n            len = NEXT();\n            len += (unsigned)(NEXT()) << 8;\n            if (last == -1) break;\n            while (len > have) {\n                len -= have;\n                have = 0;\n                if (NEXT() == -1) break;\n                len--;\n            }\n            if (last == -1) break;\n            have -= len;\n            next += len;\n        }\n        if (flags & 8)                      /* file name */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 16)                     /* comment */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 2) {                    /* header crc */\n            NEXT();\n            NEXT();\n        }\n        if (last == -1) break;\n\n        /* set up output */\n        outd.outfile = outfile;\n        outd.check = 1;\n        outd.crc = crc32(0L, Z_NULL, 0);\n        outd.total = 0;\n\n        /* decompress data to output */\n        strm->next_in = next;\n        strm->avail_in = have;\n        ret = inflateBack(strm, in, indp, out, &outd);\n        if (ret != Z_STREAM_END) break;\n        next = strm->next_in;\n        have = strm->avail_in;\n        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */\n\n        /* check trailer */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != (int)(outd.crc & 0xff) ||\n            NEXT() != (int)((outd.crc >> 8) & 0xff) ||\n            NEXT() != (int)((outd.crc >> 16) & 0xff) ||\n            NEXT() != (int)((outd.crc >> 24) & 0xff)) {\n            /* crc error */\n            if (last != -1) {\n                strm->msg = (char *)\"incorrect data check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n        if (NEXT() != (int)(outd.total & 0xff) ||\n            NEXT() != (int)((outd.total >> 8) & 0xff) ||\n            NEXT() != (int)((outd.total >> 16) & 0xff) ||\n            NEXT() != (int)((outd.total >> 24) & 0xff)) {\n            /* length error */\n            if (last != -1) {\n                strm->msg = (char *)\"incorrect length check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n\n        /* go back and look for another gzip stream */\n    }\n\n    /* clean up and return */\n    return ret;\n}",
  {
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "examples/gun.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "examples/gun.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "examples/gun.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "examples/gun.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "examples/gun.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "examples/gun.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "examples/gun.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "examples/gun.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "examples/gun.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "examples/gun.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "examples/gun.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "examples/gun.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "examples/gun.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "examples/gun.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "examples/gun.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "examples/gun.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "examples/gun.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "examples/gun.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "examples/gun.c"
   ]
  }
 ],
 "9020b76898bfc30bbd0a35b873297307ceff1b599bf8e1c16022dbf3b2f6a55c": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#else\n        flags += 1L << 24;\n#  ifdef NO_snprintf\n        flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "zutil.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "zutil.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "zutil.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "zutil.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "zutil.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "zutil.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "zutil.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "zutil.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "zutil.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "zutil.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "zutil.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "zutil.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "zutil.c"
   ]
  }
 ],
 "85a1ab3cc867b9acfbd0eee9b7db235734a7c77291fa47662ec9972511815831": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n    va_list va;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(state->in, format, va);\n    va_end(va);\n    for (len = 0; len < state->in; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf(state->in, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(state->in, size, format, va);\n    va_end(va);\n    len = strlen(state->in);\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->pos += len;\n    return len;\n}",
  {
   "v1.2.3.6": [
    "2011-09-09 23:26:58",
    "gzwrite.c"
   ],
   "v1.2.3.7": [
    "2011-09-09 23:27:08",
    "gzwrite.c"
   ],
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "gzwrite.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "gzwrite.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "gzwrite.c"
   ]
  }
 ],
 "4ca32e0a480709a556728fabf49cb75378a61e6fc16b6187e16d0f36e2f0e645": [
  "extern void ZEXPORT fill_win32_filefunc (zlib_filefunc_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen_file = win32_open_file_func;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell_file = win32_tell_file_func;\n    pzlib_filefunc_def->zseek_file = win32_seek_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ]
  }
 ],
 "bb49dec79ee2d26f57fca8c6b05528dbc35c33994bb235f3bb5509db7fd8932b": [
  "extern void ZEXPORT fill_win32_filefunc64(zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_func;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ]
  }
 ],
 "80bfcf667a8d0e73de0f91319c074ea7e1ac2128f000cd52cb6bdbfe78c701f0": [
  "extern void ZEXPORT fill_win32_filefunc64A(zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcA;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ]
  }
 ],
 "ba5f50616c721629f2e6e04c2ee784b537b6a81979873c2e049e4a84b89aae56": [
  "extern void ZEXPORT fill_win32_filefunc64W(zlib_filefunc64_def* pzlib_filefunc_def)\n{\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcW;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
  {
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "contrib/contrib/minizip/iowin32.c"
   ]
  }
 ],
 "a4fff8f843fcbc280948533dfca17cfbd44a13c995dca8c1d798567b3da015de": [
  "unsigned ZEXPORT gz_intmax()\n{\n    unsigned p, q;\n\n    p = 1;\n    do {\n        q = p;\n        p <<= 1;\n        p++;\n    } while (p > q);\n    return q >> 1;\n}",
  {
   "v1.2.3.8": [
    "2011-09-09 23:27:17",
    "gzlib.c"
   ],
   "v1.2.3.9": [
    "2011-09-09 23:27:26",
    "gzlib.c"
   ],
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "gzlib.c"
   ],
   "v1.2.4-pre1": [
    "2011-09-09 23:32:36",
    "gzlib.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "gzlib.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "gzlib.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "gzlib.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "gzlib.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "gzlib.c"
   ]
  }
 ],
 "c77a119bedd560ff102d4a10dfc6e07b7ad90239c88ac9cad8ad468f0ca227cd": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n    va_list va;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(state->in, format, va);\n    va_end(va);\n    for (len = 0; len < size; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf(state->in, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(state->in, size, format, va);\n    va_end(va);\n    len = strlen(state->in);\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->pos += len;\n    return len;\n}",
  {
   "v1.2.4": [
    "2011-09-09 23:33:59",
    "gzwrite.c"
   ],
   "v1.2.4-pre2": [
    "2011-09-09 23:33:23",
    "gzwrite.c"
   ],
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "gzwrite.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "gzwrite.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "gzwrite.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "gzwrite.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "gzwrite.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "gzwrite.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "gzwrite.c"
   ]
  }
 ],
 "b5a9a36b1ab787cdb2b2515389eb2775bfdeb40c81346539c799bdb33432edf7": [
  "voidpf zcalloc (voidpf opaque, uInt items, uInt size)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n}",
  {
   "v1.2.4.1": [
    "2011-09-09 23:34:22",
    "zutil.c"
   ],
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "zutil.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "zutil.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "zutil.c"
   ]
  }
 ],
 "09996fb05fe031b4c99854fd55e4acf9649887be0701c592cf09efaec3acdaf9": [
  "local int fixed(struct state *s)\n{\n    static int virgin = 1;\n    static short lencnt[MAXBITS+1], lensym[FIXLCODES];\n    static short distcnt[MAXBITS+1], distsym[MAXDCODES];\n    static struct huffman lencode, distcode;\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        int symbol;\n        short lengths[FIXLCODES];\n\n        /* literal/length table */\n        for (symbol = 0; symbol < 144; symbol++)\n            lengths[symbol] = 8;\n        for (; symbol < 256; symbol++)\n            lengths[symbol] = 9;\n        for (; symbol < 280; symbol++)\n            lengths[symbol] = 7;\n        for (; symbol < FIXLCODES; symbol++)\n            lengths[symbol] = 8;\n        construct(&lencode, lengths, FIXLCODES);\n\n        /* distance table */\n        for (symbol = 0; symbol < MAXDCODES; symbol++)\n            lengths[symbol] = 5;\n        construct(&distcode, lengths, MAXDCODES);\n\n        /* construct lencode and distcode */\n        lencode.count = lencnt;\n        lencode.symbol = lensym;\n        distcode.count = distcnt;\n        distcode.symbol = distsym;\n\n        /* do this just once */\n        virgin = 0;\n    }\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "5eb3c1326bb31590f92ce640a36c9b1b6a605aec9195ed494484a2c83ee72649": [
  "local int dynamic(struct state *s)\n{\n    int nlen, ndist, ncode;             /* number of lengths in descriptor */\n    int index;                          /* index of lengths[] */\n    int err;                            /* construct() return value */\n    short lengths[MAXCODES];            /* descriptor code lengths */\n    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */\n    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */\n    struct huffman lencode, distcode;   /* length and distance codes */\n    static const short order[19] =      /* permutation of code length codes */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* construct lencode and distcode */\n    lencode.count = lencnt;\n    lencode.symbol = lensym;\n    distcode.count = distcnt;\n    distcode.symbol = distsym;\n\n    /* get number of lengths in each table, check lengths */\n    nlen = bits(s, 5) + 257;\n    ndist = bits(s, 5) + 1;\n    ncode = bits(s, 4) + 4;\n    if (nlen > MAXLCODES || ndist > MAXDCODES)\n        return -3;                      /* bad counts */\n\n    /* read code length code lengths (really), missing lengths are zero */\n    for (index = 0; index < ncode; index++)\n        lengths[order[index]] = bits(s, 3);\n    for (; index < 19; index++)\n        lengths[order[index]] = 0;\n\n    /* build huffman table for code lengths codes (use lencode temporarily) */\n    err = construct(&lencode, lengths, 19);\n    if (err != 0) return -4;            /* require complete code set here */\n\n    /* read length/literal and distance code length tables */\n    index = 0;\n    while (index < nlen + ndist) {\n        int symbol;             /* decoded value */\n        int len;                /* last length to repeat */\n\n        symbol = decode(s, &lencode);\n        if (symbol < 16)                /* length in 0..15 */\n            lengths[index++] = symbol;\n        else {                          /* repeat instruction */\n            len = 0;                    /* assume repeating zeros */\n            if (symbol == 16) {         /* repeat last length 3..6 times */\n                if (index == 0) return -5;      /* no last length! */\n                len = lengths[index - 1];       /* last length */\n                symbol = 3 + bits(s, 2);\n            }\n            else if (symbol == 17)      /* repeat zero 3..10 times */\n                symbol = 3 + bits(s, 3);\n            else                        /* == 18, repeat zero 11..138 times */\n                symbol = 11 + bits(s, 7);\n            if (index + symbol > nlen + ndist)\n                return -6;              /* too many lengths! */\n            while (symbol--)            /* repeat last or zero symbol times */\n                lengths[index++] = len;\n        }\n    }\n\n    /* check for end-of-block code -- there better be one! */\n    if (lengths[256] == 0)\n        return -9;\n\n    /* build huffman table for literal/length codes */\n    err = construct(&lencode, lengths, nlen);\n    if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))\n        return -7;      /* only allow incomplete codes if just one code */\n\n    /* build huffman table for distance codes */\n    err = construct(&distcode, lengths + nlen, ndist);\n    if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))\n        return -8;      /* only allow incomplete codes if just one code */\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "4dc52c6bb0af41c867764a1fdf76cbde3827ebac15dd40e358d3e091ffca10b8": [
  "int main(int argc, char **argv)\n{\n    int ret, put = 0;\n    unsigned skip = 0;\n    char *arg, *name = NULL;\n    unsigned char *source = NULL, *dest;\n    size_t len = 0;\n    unsigned long sourcelen, destlen;\n\n    /* process arguments */\n    while (arg = *++argv, --argc)\n        if (arg[0] == '-') {\n            if (arg[1] == 'w' && arg[2] == 0)\n                put = 1;\n            else if (arg[1] >= '0' && arg[1] <= '9')\n                skip = (unsigned)atoi(arg + 1);\n            else {\n                fprintf(stderr, \"invalid option %s\\n\", arg);\n                return 3;\n            }\n        }\n        else if (name != NULL) {\n            fprintf(stderr, \"only one file name allowed\\n\");\n            return 3;\n        }\n        else\n            name = arg;\n    source = load(name, &len);\n    if (source == NULL) {\n        fprintf(stderr, \"memory allocation failure\\n\");\n        return 4;\n    }\n    if (len == 0) {\n        fprintf(stderr, \"could not read %s, or it was empty\\n\",\n                name == NULL ? \"<stdin>\" : name);\n        free(source);\n        return 3;\n    }\n    if (skip >= len) {\n        fprintf(stderr, \"skip request of %d leaves no input\\n\", skip);\n        free(source);\n        return 3;\n    }\n\n    /* test inflate data with offset skip */\n    len -= skip;\n    sourcelen = (unsigned long)len;\n    ret = puff(NIL, &destlen, source + skip, &sourcelen);\n    if (ret)\n        fprintf(stderr, \"puff() failed with return code %d\\n\", ret);\n    else {\n        fprintf(stderr, \"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n        if (sourcelen < len) fprintf(stderr, \"%lu compressed bytes unused\\n\",\n                                     len - sourcelen);\n    }\n\n    /* if requested, inflate again and write decompressd data to stdout */\n    if (put) {\n        dest = malloc(destlen);\n        if (dest == NULL) {\n            fprintf(stderr, \"memory allocation failure\\n\");\n            free(source);\n            return 4;\n        }\n        puff(dest, &destlen, source + skip, &sourcelen);\n        fwrite(dest, 1, destlen, stdout);\n        free(dest);\n    }\n\n    /* clean up */\n    free(source);\n    return ret;\n}",
  {
   "v1.2.4.2": [
    "2011-09-09 23:34:30",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.3": [
    "2011-09-09 23:34:38",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.4": [
    "2011-09-09 23:34:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "contrib/puff/puff.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "21b5148cd74aba0b6b6c2c05f0f9f4230a105f189b286e2e04630052b2d72c09": [
  "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
  {
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "zutil.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "zutil.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "zutil.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "zutil.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "zutil.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "zutil.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "zutil.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "zutil.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "zutil.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "zutil.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "zutil.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "zutil.c"
   ]
  }
 ],
 "f9887e3f86317ed699c73bd85deee34cae4599c45c7e4997de4adb6e1f55b5e8": [
  "void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    ptr = opaque; /* just to make some compilers happy */\n    Assert(0, \"zcfree: ptr not found\");\n}",
  {
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "zutil.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "zutil.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "zutil.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "zutil.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "zutil.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "zutil.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "zutil.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "zutil.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "zutil.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "zutil.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "zutil.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "zutil.c"
   ]
  }
 ],
 "357122705c57b53f6474b34162133e01f975b296cec8ee051fb79799a7118c61": [
  "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n}",
  {
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "zutil.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "zutil.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "zutil.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "zutil.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "zutil.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "zutil.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "zutil.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "zutil.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "zutil.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "zutil.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "zutil.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "zutil.c"
   ]
  }
 ],
 "96a64e7f654bd479514b1f563502a0f6d3223382d8d4074f9e7cd11c07868147": [
  "void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    _hfree(ptr);\n}",
  {
   "v1.2.4.5": [
    "2011-09-09 23:34:55",
    "zutil.c"
   ],
   "v1.2.5": [
    "2011-09-09 23:35:10",
    "zutil.c"
   ],
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "zutil.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "zutil.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "zutil.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "zutil.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "zutil.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "zutil.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "zutil.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "zutil.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "zutil.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "zutil.c"
   ]
  }
 ],
 "18681831fd76021cec3ca240a6c9f8a9878101c3b4d3ab72826cbf3ebf0af04d": [
  "local int dynamic(struct state *s)\n{\n    int nlen, ndist, ncode;             /* number of lengths in descriptor */\n    int index;                          /* index of lengths[] */\n    int err;                            /* construct() return value */\n    short lengths[MAXCODES];            /* descriptor code lengths */\n    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */\n    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */\n    struct huffman lencode, distcode;   /* length and distance codes */\n    static const short order[19] =      /* permutation of code length codes */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* construct lencode and distcode */\n    lencode.count = lencnt;\n    lencode.symbol = lensym;\n    distcode.count = distcnt;\n    distcode.symbol = distsym;\n\n    /* get number of lengths in each table, check lengths */\n    nlen = bits(s, 5) + 257;\n    ndist = bits(s, 5) + 1;\n    ncode = bits(s, 4) + 4;\n    if (nlen > MAXLCODES || ndist > MAXDCODES)\n        return -3;                      /* bad counts */\n\n    /* read code length code lengths (really), missing lengths are zero */\n    for (index = 0; index < ncode; index++)\n        lengths[order[index]] = bits(s, 3);\n    for (; index < 19; index++)\n        lengths[order[index]] = 0;\n\n    /* build huffman table for code lengths codes (use lencode temporarily) */\n    err = construct(&lencode, lengths, 19);\n    if (err != 0)               /* require complete code set here */\n        return -4;\n\n    /* read length/literal and distance code length tables */\n    index = 0;\n    while (index < nlen + ndist) {\n        int symbol;             /* decoded value */\n        int len;                /* last length to repeat */\n\n        symbol = decode(s, &lencode);\n        if (symbol < 16)                /* length in 0..15 */\n            lengths[index++] = symbol;\n        else {                          /* repeat instruction */\n            len = 0;                    /* assume repeating zeros */\n            if (symbol == 16) {         /* repeat last length 3..6 times */\n                if (index == 0)\n                    return -5;          /* no last length! */\n                len = lengths[index - 1];       /* last length */\n                symbol = 3 + bits(s, 2);\n            }\n            else if (symbol == 17)      /* repeat zero 3..10 times */\n                symbol = 3 + bits(s, 3);\n            else                        /* == 18, repeat zero 11..138 times */\n                symbol = 11 + bits(s, 7);\n            if (index + symbol > nlen + ndist)\n                return -6;              /* too many lengths! */\n            while (symbol--)            /* repeat last or zero symbol times */\n                lengths[index++] = len;\n        }\n    }\n\n    /* check for end-of-block code -- there better be one! */\n    if (lengths[256] == 0)\n        return -9;\n\n    /* build huffman table for literal/length codes */\n    err = construct(&lencode, lengths, nlen);\n    if (err && (err < 0 || nlen != lencode.count[0] + lencode.count[1]))\n        return -7;      /* incomplete code ok only for single length 1 code */\n\n    /* build huffman table for distance codes */\n    err = construct(&distcode, lengths + nlen, ndist);\n    if (err && (err < 0 || ndist != distcode.count[0] + distcode.count[1]))\n        return -8;      /* incomplete code ok only for single length 1 code */\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
  {
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "contrib/puff/puff.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "contrib/puff/puff.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/puff/puff.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/puff/puff.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/puff/puff.c"
   ]
  }
 ],
 "40755f3d07b863e15da266c9593e47e59187091b3b6265c5279b3d3574b0e8a4": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifdef NO_vsnprintf\n        flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#else\n        flags += 1L << 24;\n#  ifdef NO_snprintf\n        flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "zutil.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "zutil.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "zutil.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "zutil.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "zutil.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "zutil.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "zutil.c"
   ]
  }
 ],
 "c0a4b6b2b503dfa18690b305cb5ea853a5af68bf11e9bf24229ccdc281c56581": [
  "local void make_crc_table()\n{\n    crc_table_t c;\n    int n, k;\n    crc_table_t poly;                   /* polynomial exclusive-or pattern */\n    /* terms of polynomial defining this crc (except x^32): */\n    static volatile int first = 1;      /* flag to limit concurrent making */\n    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n    /* See if another task is already doing this (not thread-safe, but better\n       than nothing -- significantly reduces duration of vulnerability in\n       case the advice about DYNAMIC_CRC_TABLE is ignored) */\n    if (first) {\n        first = 0;\n\n        /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n        poly = 0;\n        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)\n            poly |= (crc_table_t)1 << (31 - p[n]);\n\n        /* generate a crc for every 8-bit value */\n        for (n = 0; n < 256; n++) {\n            c = (crc_table_t)n;\n            for (k = 0; k < 8; k++)\n                c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n            crc_table[0][n] = c;\n        }\n\n#ifdef BYFOUR\n        /* generate crc for each value followed by one, two, and three zeros,\n           and then the byte reversal of those as well as the first table */\n        for (n = 0; n < 256; n++) {\n            c = crc_table[0][n];\n            crc_table[4][n] = REV(c);\n            for (k = 1; k < 4; k++) {\n                c = crc_table[0][c & 0xff] ^ (c >> 8);\n                crc_table[k][n] = c;\n                crc_table[k + 4][n] = REV(c);\n            }\n        }\n#endif /* BYFOUR */\n\n        crc_table_empty = 0;\n    }\n    else {      /* not first */\n        /* wait for the other guy to finish (not efficient, but rare) */\n        while (crc_table_empty)\n            ;\n    }\n\n#ifdef MAKECRCH\n    /* write out CRC tables to crc32.h */\n    {\n        FILE *out;\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n        fprintf(out, \"local const crc_table_t FAR \");\n        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n        write_table(out, crc_table[0]);\n#  ifdef BYFOUR\n        fprintf(out, \"#ifdef BYFOUR\\n\");\n        for (k = 1; k < 8; k++) {\n            fprintf(out, \"  },\\n  {\\n\");\n            write_table(out, crc_table[k]);\n        }\n        fprintf(out, \"#endif\\n\");\n#  endif /* BYFOUR */\n        fprintf(out, \"  }\\n};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
  {
   "v1.2.5.1": [
    "2011-09-11 11:04:49",
    "crc32.c"
   ],
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "crc32.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "crc32.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "crc32.c"
   ]
  }
 ],
 "cce99ee20e476c9e0a729b9fc2811fbea28075391e48b6aea450db61001d0e28": [
  "char *h2b(const char *hex, unsigned *len)\n{\n    unsigned char *in;\n    unsigned next, val;\n\n    in = malloc((strlen(hex) + 1) >> 1);\n    if (in == NULL)\n        return NULL;\n    next = 0;\n    val = 1;\n    do {\n        if (*hex >= '0' && *hex <= '9')\n            val = (val << 4) + *hex - '0';\n        else if (*hex >= 'A' && *hex <= 'F')\n            val = (val << 4) + *hex - 'A' + 10;\n        else if (*hex >= 'a' && *hex <= 'f')\n            val = (val << 4) + *hex - 'a' + 10;\n        else if (val != 1 && val < 32)  /* one digit followed by delimiter */\n            val += 240;                 /* make it look like two digits */\n        if (val > 255) {                /* have two digits */\n            in[next++] = val & 0xff;    /* save the decoded byte */\n            val = 1;                    /* start over */\n        }\n    } while (*hex++);       /* go through the loop with the terminating null */\n    if (len != NULL)\n        *len = next;\n    in = reallocf(in, next);\n    return in;\n}",
  {
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/infcover.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/infcover.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/infcover.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/infcover.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/infcover.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/infcover.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/infcover.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/infcover.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/infcover.c"
   ]
  }
 ],
 "cb2c7465a8ab42cb30966ce411534022ae21176d7183c0338b35719af07f8655": [
  "void myfree(void *q, void *p)\n{\n    q = Z_NULL;\n    free(p);\n}",
  {
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "test/example.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "test/example.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "test/example.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "test/example.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "test/example.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "test/example.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "test/example.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "test/example.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "test/example.c"
   ]
  }
 ],
 "aa6db635978b3df67a64b6611168ae2bd0777655e0e727a27e3927b12ca803a1": [
  "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#ifdef Z_SOLO\n    return flags;\n#else\n    return flags + gzflags();\n#endif\n}",
  {
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "zutil.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "zutil.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "zutil.c"
   ]
  }
 ],
 "f011708717d05c7c4b77385ffad880432b588ebec1686ead0210cba95efc710f": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n    va_list va;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(state->in, format, va);\n    va_end(va);\n    for (len = 0; len < size; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf(state->in, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(state->in, size, format, va);\n    va_end(va);\n    len = strlen(state->in);\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->x.pos += len;\n    return len;\n}",
  {
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "gzwrite.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "gzwrite.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "gzwrite.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "gzwrite.c"
   ]
  }
 ],
 "66d7c04e1f2aa352a084ca675b22d30aac092b8bb5fdbff4f0c5efbd1b6e5211": [
  "unsigned long ZEXPORT gzflags()\n{\n    unsigned long flags = 0;\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifdef NO_vsnprintf\n    flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#else\n    flags += 1L << 24;\n#  ifdef NO_snprintf\n    flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
  {
   "v1.2.5.2": [
    "2011-12-18 10:39:45",
    "gzwrite.c"
   ],
   "v1.2.5.3": [
    "2012-01-15 18:58:21",
    "gzwrite.c"
   ],
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "gzwrite.c"
   ]
  }
 ],
 "484365057bdb4ed21455f41e1a0b81b1cd3665f1da00bc66692631ed462533ee": [
  "extern int ZEXPORT zipClose (zipFile file, const char* global_comment)\n{\n    zip64_internal* zi;\n    int err = 0;\n    uLong size_centraldir = 0;\n    ZPOS64_T centraldir_pos_inzip;\n    ZPOS64_T pos;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 1)\n    {\n        err = zipCloseFileInZip (file);\n    }\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    if (global_comment==NULL)\n        global_comment = zi->globalcomment;\n#endif\n\n    centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n    if (err==ZIP_OK)\n    {\n        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;\n        while (ldi!=NULL)\n        {\n            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))\n            {\n                if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)\n                    err = ZIP_ERRNO;\n            }\n\n            size_centraldir += ldi->filled_in_this_block;\n            ldi = ldi->next_datablock;\n        }\n    }\n    free_linkedlist(&(zi->central_dir));\n\n    pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;\n    if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)\n    {\n      ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);\n      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n\n      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);\n    }\n\n    if (err==ZIP_OK)\n      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n\n    if(err == ZIP_OK)\n      err = Write_GlobalComment(zi, global_comment);\n\n    if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)\n        if (err == ZIP_OK)\n            err = ZIP_ERRNO;\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    TRYFREE(zi->globalcomment);\n#endif\n    TRYFREE(zi);\n\n    return err;\n}",
  {
   "v1.2.6": [
    "2012-01-29 10:13:15",
    "contrib/minizip/zip.c"
   ],
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "contrib/minizip/zip.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "contrib/minizip/zip.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/zip.c"
   ]
  }
 ],
 "bd9408126ab26e8ed1a0919f2f2018dc77f16f51123dea5ee826cf36de61064c": [
  "local void make_crc_table()\n{\n    crc_table_t c;\n    int n, k;\n    crc_table_t poly;                   /* polynomial exclusive-or pattern */\n    /* terms of polynomial defining this crc (except x^32): */\n    static volatile int first = 1;      /* flag to limit concurrent making */\n    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n    /* See if another task is already doing this (not thread-safe, but better\n       than nothing -- significantly reduces duration of vulnerability in\n       case the advice about DYNAMIC_CRC_TABLE is ignored) */\n    if (first) {\n        first = 0;\n\n        /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n        poly = 0;\n        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)\n            poly |= (crc_table_t)1 << (31 - p[n]);\n\n        /* generate a crc for every 8-bit value */\n        for (n = 0; n < 256; n++) {\n            c = (crc_table_t)n;\n            for (k = 0; k < 8; k++)\n                c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n            crc_table[0][n] = c;\n        }\n\n#ifdef BYFOUR\n        /* generate crc for each value followed by one, two, and three zeros,\n           and then the byte reversal of those as well as the first table */\n        for (n = 0; n < 256; n++) {\n            c = crc_table[0][n];\n            crc_table[4][n] = ZSWAP32(c);\n            for (k = 1; k < 4; k++) {\n                c = crc_table[0][c & 0xff] ^ (c >> 8);\n                crc_table[k][n] = c;\n                crc_table[k + 4][n] = ZSWAP32(c);\n            }\n        }\n#endif /* BYFOUR */\n\n        crc_table_empty = 0;\n    }\n    else {      /* not first */\n        /* wait for the other guy to finish (not efficient, but rare) */\n        while (crc_table_empty)\n            ;\n    }\n\n#ifdef MAKECRCH\n    /* write out CRC tables to crc32.h */\n    {\n        FILE *out;\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n        fprintf(out, \"local const crc_table_t FAR \");\n        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n        write_table(out, crc_table[0]);\n#  ifdef BYFOUR\n        fprintf(out, \"#ifdef BYFOUR\\n\");\n        for (k = 1; k < 8; k++) {\n            fprintf(out, \"  },\\n  {\\n\");\n            write_table(out, crc_table[k]);\n        }\n        fprintf(out, \"#endif\\n\");\n#  endif /* BYFOUR */\n        fprintf(out, \"  }\\n};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
  {
   "v1.2.6.1": [
    "2012-02-12 14:11:48",
    "crc32.c"
   ]
  }
 ],
 "5a6457eb035b5c21c6fa507b2003f90311b021630ada60500587f9ff3011f1a1": [
  "int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n    va_list va;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf((char *)(state->in), format, va);\n    va_end(va);\n    for (len = 0; len < size; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf((char *)(state->in), format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n    len = strlen((char *)(state->in));\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->x.pos += len;\n    return len;\n}",
  {
   "v1.2.7": [
    "2012-05-02 20:32:41",
    "gzwrite.c"
   ]
  }
 ],
 "8b82ac79a56c5a57fb93e0a564b282313b507759154dadede0b1ecce574d051a": [
  "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)\n{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf((char *)(state->in), format, va);\n    for (len = 0; len < size; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf((char *)(state->in), format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf((char *)(state->in), size, format, va);\n    len = strlen((char *)(state->in));\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->x.pos += len;\n    return len;\n}",
  {
   "v1.2.7.1": [
    "2013-03-24 22:46:40",
    "gzwrite.c"
   ],
   "v1.2.7.2": [
    "2013-04-13 18:15:42",
    "gzwrite.c"
   ],
   "v1.2.7.3": [
    "2013-04-13 21:18:35",
    "gzwrite.c"
   ],
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "gzwrite.c"
   ]
  }
 ],
 "0805f000c198c84f155e3dcefafbef7b9febdcebb401d636102172c8fc3facca": [
  "static BOOL MySetFilePointerEx(HANDLE hFile, LARGE_INTEGER pos, LARGE_INTEGER *newPos,  DWORD dwMoveMethod)\n{\n#ifdef IOWIN32_USING_WINRT_API\n    return SetFilePointerEx(hFile, pos, newPos, dwMoveMethod);\n#else\n    LONG lHigh = pos.HighPart;\n    DWORD dwNewPos = SetFilePointer(hFile, pos.LowPart, &lHigh, FILE_CURRENT);\n    BOOL fOk = TRUE;\n    if (dwNewPos == 0xFFFFFFFF)\n        if (GetLastError() != NO_ERROR)\n            fOk = FALSE;\n    if ((newPos != NULL) && (fOk))\n    {\n        newPos->LowPart = dwNewPos;\n        newPos->HighPart = lHigh;\n    }\n    return fOk;\n#endif\n}",
  {
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ]
  }
 ],
 "8db1c6a623290a641f7c9449f4effa2729dfcc6d00fcc41aa0a5c49073f71f4d": [
  "long ZCALLBACK win32_seek64_file_func (voidpf opaque, voidpf stream,ZPOS64_T offset,int origin)\n{\n    DWORD dwMoveMethod=0xFFFFFFFF;\n    HANDLE hFile = NULL;\n    long ret=-1;\n\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream)->hf;\n\n    switch (origin)\n    {\n        case ZLIB_FILEFUNC_SEEK_CUR :\n            dwMoveMethod = FILE_CURRENT;\n            break;\n        case ZLIB_FILEFUNC_SEEK_END :\n            dwMoveMethod = FILE_END;\n            break;\n        case ZLIB_FILEFUNC_SEEK_SET :\n            dwMoveMethod = FILE_BEGIN;\n            break;\n        default: return -1;\n    }\n\n    if (hFile)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = offset;\n        if (!MySetFilePointerEx(hFile, pos, NULL, FILE_CURRENT))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=0;\n    }\n    return ret;\n}",
  {
   "v1.2.8": [
    "2013-04-28 16:03:34",
    "contrib/minizip/iowin32.c"
   ]
  }
 ]
}